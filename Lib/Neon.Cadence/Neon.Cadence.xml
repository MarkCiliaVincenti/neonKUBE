<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Neon.Cadence</name>
    </assembly>
    <members>
        <member name="T:Neon.Cadence.Activity">
            <summary>
            Provides useful information and functionality for workflow implementations.
            This will be available via the <see cref="P:Neon.Cadence.WorkflowBase.Workflow"/> property.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Activity.#ctor(Neon.Cadence.ActivityBase)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parent">The parent activity implementation.</param>
        </member>
        <member name="P:Neon.Cadence.Activity.Client">
            <summary>
            Returns the <see cref="T:Neon.Cadence.CadenceClient"/> managing this activity.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Activity.IsLocal">
            <summary>
            Returns <c>true</c> for a local activity execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Activity.CancellationToken">
            <summary>
            Returns the activity's cancellation token.  Activities can monitor this
            to gracefully handle activity cancellation.
            </summary>
            <remarks>
            <para>
            We recommend that all non-local activities that execute for relatively long periods,
            monitor <see cref="P:Neon.Cadence.Activity.CancellationToken"/> for activity cancellation so that they
            can gracefully terminate including potentially calling <see cref="M:Neon.Cadence.Activity.RecordHeartbeatAsync(System.Byte[])"/>
            to checkpoint the current activity state.
            </para>
            <para>
            Cancelled activities should throw a <see cref="T:System.Threading.Tasks.TaskCanceledException"/> from
            their entry point method rather than returning a result so that Cadence will 
            reschedule the activity if necessary.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Cadence.Activity.Task">
            <summary>
            Returns the additional information about the activity and the workflow
            that invoked it.  Note that this is not supported for local activities.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown for local activities.</exception>
        </member>
        <member name="P:Neon.Cadence.Activity.Logger">
            <summary>
            Returns the logger to be used for logging activity related events.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Activity.RecordHeartbeatAsync(System.Byte[])">
            <summary>
            <para>
            Records a heartbeat with optional details to Cadence.
            </para>
            <note>
            <b>IMPORTANT:</b> Heartbeats are not supported for local activities.
            </note>
            </summary>
            <param name="details">Optional heartbeart details.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown for local activity executions.</exception>
            <remarks>
            <para>
            Long running activities need to send periodic heartbeats back to
            Cadence to prove that the activity is still alive.  This can also
            be used by activities to implement checkpoints or record other
            details.  This method sends a heartbeat with optional details
            encoded as a byte array.
            </para>
            <note>
            The maximum allowed time period between heartbeats is specified in 
            <see cref="T:Neon.Cadence.ActivityOptions"/> when activities are executed and it's
            also possible to enable automatic heartbeats sent by the Cadence client.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Activity.HasLastHeartbeatDetailsAsync">
            <summary>
            <para>
            Determines whether the details from the last recorded heartbeat last
            failed attempt exist.
            </para>
            <note>
            <b>IMPORTANT:</b> Heartbeats are not supported for local activities.
            </note>
            </summary>
            <returns>The details from the last heartbeat or <c>null</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown for local activity executions.</exception>
        </member>
        <member name="M:Neon.Cadence.Activity.GetLastHeartbeatDetailsAsync">
            <summary>
            <para>
            Returns the details from the last recorded heartbeat last failed attempt
            at running the activity.
            </para>
            <note>
            <b>IMPORTANT:</b> Heartbeats are not supported for local activities.
            </note>
            </summary>
            <returns>The details from the last heartbeat or <c>null</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown for local activity executions.</exception>
        </member>
        <member name="M:Neon.Cadence.Activity.DoNotCompleteOnReturn">
            <summary>
            This method may be called within the activity entry point to indicate that the
            activity will be completed externally.
            </summary>
            <remarks>
            <note>
            This method is not supported for local activities.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Activity.HeartbeatAsync(System.Func{System.Byte[]},System.Nullable{System.TimeSpan})">
            <summary>
            Used to record heartbeats at a specific interval.
            </summary>
            <param name="detailsFunc">Optionally specifies a function that returns the heartbeat details.</param>
            <param name="interval">
            Optionally specifies the interval between heartbeats.  This defaults
            to 1/2 of activity's heartbeat timeout.
            </param>
            <returns><c>true</c> if a heartbeat was recorded.</returns>
            <remarks>
            <para>
            This is a convienence method that can be used to make it easy to
            restrict how often activity heartbeats are actually recorded.
            The activity can call this as often as it likes but the method
            schedules heartbeat times and only transmits a heartbeat when
            this time has been reached.
            </para>
            <para>
            By default, the method records heartbeats at 1/2 the activity's heartbeat
            timeout, but this can be customized via the <paramref name="interval"/>
            parameter.  No heartbeat details will be recorded by default, but you
            can customize this by passing a <paramref name="detailsFunc"/>.
            </para>
            <note>
            Any <paramref name="detailsFunc"/> passed will only be called when a
            heartbeat is scheduled.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.ActivityAttribute">
            <summary>
            Used to tag activity implementations that inherit from
            <see cref="T:Neon.Cadence.ActivityBase"/> to customize the how the activity is
            registered.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">
            Optionally specifies the activity type name used to
            register an activity implementation with Cadence.
            </param>
        </member>
        <member name="P:Neon.Cadence.ActivityAttribute.Name">
            <summary>
            The activity type name.  This defaults to the fully qualified name
            of the implemented activity interface (without an leading "I").
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityAttribute.AutoRegister">
            <summary>
            Indicates that <see cref="M:Neon.Cadence.CadenceClient.RegisterAssemblyActivitiesAsync(System.Reflection.Assembly,System.String)"/> will
            automatically register the tagged activity implementation for the specified assembly.
            This defaults to <c>false</c>
            </summary>
        </member>
        <member name="T:Neon.Cadence.ActivityBase">
            <summary>
            Base class that must be inherited by all implementations.
            </summary>
        </member>
        <member name="T:Neon.Cadence.ActivityBase.ActivityKey">
            <summary>
            Used to map a Cadence client ID and workflow context ID into a
            key that can be used to dereference <see cref="F:Neon.Cadence.ActivityBase.idToActivity"/>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.ActivityBase.ActivityRegistration">
            <summary>
            Used for mapping an activity type name to its underlying type 
            and entry point method.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityBase.ActivityRegistration.ActivityType">
            <summary>
            The activity type.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityBase.ActivityRegistration.ActivityMethod">
            <summary>
            The activity entry point method.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityBase.ActivityRegistration.ActivityMethodParameterTypes">
            <summary>
            The activity method parameter types.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.Reset">
            <summary>
            Restores the class to its initial state.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.GetActivityTypeKey(Neon.Cadence.CadenceClient,System.String,Neon.Cadence.ActivityMethodAttribute)">
            <summary>
            Prepends the Cadence client ID to the activity type name and optional
            activity method attribute name to generate the key used to dereference the 
            <see cref="F:Neon.Cadence.ActivityBase.nameToRegistration"/> dictionary.
            </summary>
            <param name="client">The Cadence client.</param>
            <param name="activityTypeName">The activity type name.</param>
            <param name="activityMethodAttribute">Optionally specifies the activity method attribute. </param>
            <returns>The prepended activity registration key.</returns>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.GetActivityTypeNameFromKey(System.String)">
            <summary>
            Strips the leading client ID from the activity type key passed
            and returns the type name actually registered with Cadence.
            </summary>
            <param name="activityTypeKey">The activity type key.</param>
            <returns>The Cadence workflow type name.</returns>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.RegisterAsync(Neon.Cadence.CadenceClient,System.Type,System.String,System.String)">
            <summary>
            Registers an activity type.
            </summary>
            <param name="client">The associated client.</param>
            <param name="activityType">The activity type.</param>
            <param name="activityTypeName">The name used to identify the implementation.</param>
            <param name="domain">Specifies the target domain.</param>
            <returns><c>true</c> if the activity was already registered.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if a different activity class has already been registered for <paramref name="activityTypeName"/>.</exception>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.UnregisterClient(Neon.Cadence.CadenceClient)">
            <summary>
            Removes all type activity type registrations for a Cadence client (when it's being disposed).
            </summary>
            <param name="client">The client being disposed.</param>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.GetActivityInvokeInfo(System.Type,System.String)">
            <summary>
            Returns the <see cref="T:Neon.Cadence.ActivityBase.ActivityRegistration"/> for any activity type and activity type name.
            </summary>
            <param name="activityType">The target activity type.</param>
            <param name="activityTypeName">The target activity type name.</param>
            <returns>The <see cref="T:Neon.Cadence.ActivityBase.ActivityRegistration"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.CreateNormal(Neon.Cadence.CadenceClient,Neon.Cadence.ActivityBase.ActivityRegistration,System.Int64)">
            <summary>
            Constructs an activity instance suitable for executing a normal activity.
            </summary>
            <param name="client">The associated client.</param>
            <param name="invokeInfo">The activity invocation information.</param>
            <param name="contextId">The activity context ID.</param>
            <returns>The constructed activity.</returns>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.CreateLocal(Neon.Cadence.CadenceClient,Neon.Cadence.Internal.LocalActivityAction,System.Int64)">
            <summary>
            Constructs an activity instance suitable for executing a normal (non-local) activity.
            </summary>
            <param name="client">The associated client.</param>
            <param name="activityAction">The target activity action.</param>
            <param name="contextId">The activity context ID.</param>
            <returns>The constructed activity.</returns>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.OnProxyRequestAsync(Neon.Cadence.CadenceClient,Neon.Cadence.Internal.ProxyRequest)">
            <summary>
            Called to handle a workflow related request message received from the cadence-proxy.
            </summary>
            <param name="client">The client that received the request.</param>
            <param name="request">The request message.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.OnActivityInvokeRequest(Neon.Cadence.CadenceClient,Neon.Cadence.Internal.ActivityInvokeRequest)">
            <summary>
            Handles received <see cref="T:Neon.Cadence.Internal.ActivityInvokeRequest"/> messages.
            </summary>
            <param name="client">The receiving Cadence client.</param>
            <param name="request">The request message.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.ActivityStoppingRequest(Neon.Cadence.CadenceClient,Neon.Cadence.Internal.ActivityStoppingRequest)">
            <summary>
            Handles received <see cref="M:Neon.Cadence.ActivityBase.ActivityStoppingRequest(Neon.Cadence.CadenceClient,Neon.Cadence.Internal.ActivityStoppingRequest)"/> messages.
            </summary>
            <param name="client">The receiving Cadence client.</param>
            <param name="request">The request message.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.#ctor">
            <summary>
            Default protected constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.Initialize(Neon.Cadence.CadenceClient,System.Type,System.Reflection.MethodInfo,Neon.Cadence.IDataConverter,System.Int64)">
            <summary>
            Called internally to initialize the activity.
            </summary>
            <param name="client">The associated client.</param>
            <param name="activityType">Specifies the target activity type.</param>
            <param name="activityMethod">Specifies the target activity method.</param>
            <param name="dataConverter">Specifies the data converter to be used for parameter and result serilization.</param>
            <param name="contextId">The activity's context ID.</param>
        </member>
        <member name="P:Neon.Cadence.ActivityBase.Activity">
            <summary>
            Returns the activity.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityBase.Client">
            <summary>
            Returns the <see cref="T:Neon.Cadence.CadenceClient"/> managing this activity invocation.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityBase.CancellationTokenSource">
            <summary>
            Returns the <see cref="P:Neon.Cadence.ActivityBase.CancellationTokenSource"/> for the activity invocation.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityBase.CancellationToken">
            <summary>
            Returns the <see cref="P:Neon.Cadence.ActivityBase.CancellationToken"/> for thge activity invocation.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityBase.ContextId">
            <summary>
            Returns the context ID for the activity invocation.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityBase.IsLocal">
            <summary>
            Indicates whether the activity was executed locally.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityBase.ActivityTask">
            <summary>
            Returns additional information about the activity and the workflow that executed it.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityBase.CompleteExternally">
            <summary>
            Indicates that the activity will be completed externally.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.InvokeAsync(Neon.Cadence.CadenceClient,System.Byte[])">
            <summary>
            Executes the target activity method.
            </summary>
            <param name="client">The associated Cadence client.</param>
            <param name="argBytes">The encoded activity arguments.</param>
            <returns>The encoded activity results.</returns>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.OnInvokeAsync(Neon.Cadence.CadenceClient,System.Byte[])">
            <summary>
            Called internally to execute the activity.
            </summary>
            <param name="client">The Cadence client.</param>
            <param name="args">The encoded activity arguments.</param>
            <returns>The activity results.</returns>
        </member>
        <member name="M:Neon.Cadence.ActivityBase.EnsureNotLocal">
            <summary>
            Ensures that the activity has an associated Cadence context and thus
            is not a local actvity.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown for local activities.</exception>
        </member>
        <member name="T:Neon.Cadence.ActivityFutureStub">
            <summary>
            Used to execute an untyped activity in parallel with other activities, child
            workflows or other operations.  Instances are created via 
            <see cref="M:Neon.Cadence.Workflow.NewActivityFutureStub(System.String,Neon.Cadence.ActivityOptions)"/>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.ActivityFutureStub.AsyncFuture">
            <summary>
            Implements an activity future that returns <c>void</c>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityFutureStub.AsyncFuture.#ctor(Neon.Cadence.Workflow,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="activityId">The workflow local activity ID.</param>
        </member>
        <member name="M:Neon.Cadence.ActivityFutureStub.AsyncFuture.GetAsync">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.ActivityFutureStub.AsyncFuture`1">
            <summary>
            Implements an activity future that returns a value.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
        </member>
        <member name="M:Neon.Cadence.ActivityFutureStub.AsyncFuture`1.#ctor(Neon.Cadence.Workflow,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="activityId">The workflow local activity ID.</param>
        </member>
        <member name="M:Neon.Cadence.ActivityFutureStub.AsyncFuture`1.GetAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.ActivityFutureStub.#ctor(Neon.Cadence.Workflow,System.String,Neon.Cadence.ActivityOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parentWorkflow">The associated parent workflow.</param>
            <param name="activityTypeName">
            Specifies the target activity type name.
            </param>
            <param name="options">The activity options or <c>null</c>.</param>
        </member>
        <member name="M:Neon.Cadence.ActivityFutureStub.StartAsync``1(System.Object[])">
            <summary>
            Starts the target activity that returns <typeparamref name="TResult"/>, passing the specified arguments.
            </summary>
            <typeparam name="TResult">The activity result type.</typeparam>
            <param name="args">The arguments to be passed to the activity.</param>
            <returns>The <see cref="T:Neon.Tasks.IAsyncFuture`1"/> with the <see cref="M:Neon.Tasks.IAsyncFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a future stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target activity parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Cadence.ActivityFutureStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.ActivityFutureStub.StartAsync(System.Object[])">
            <summary>
            Starts the target activity that returns <c>void</c>, passing the specified arguments.
            </summary>
            <param name="args">The arguments to be passed to the activity.</param>
            <returns>The <see cref="T:Neon.Tasks.IAsyncFuture`1"/> with the <see cref="M:Neon.Tasks.IAsyncFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a future stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target activity parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Cadence.ActivityFutureStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.ActivityFutureStub`1">
            <summary>
            Used to execute a typed activity in parallel with other activities, child
            workflows or other operations.  Instances are created via 
            <see cref="M:Neon.Cadence.Workflow.NewActivityFutureStub``1(System.String,Neon.Cadence.ActivityOptions)"/>.
            </summary>
            <typeparam name="TActivityInterface">Specifies the activity interface.</typeparam>
        </member>
        <member name="T:Neon.Cadence.ActivityFutureStub`1.AsyncFuture">
            <summary>
            Implements an activity future that returns <c>void</c>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityFutureStub`1.AsyncFuture.#ctor(Neon.Cadence.Workflow,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="activityId">The workflow local activity ID.</param>
        </member>
        <member name="M:Neon.Cadence.ActivityFutureStub`1.AsyncFuture.GetAsync">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.ActivityFutureStub`1.AsyncFuture`1">
            <summary>
            Implements an activity future that returns a value.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
        </member>
        <member name="M:Neon.Cadence.ActivityFutureStub`1.AsyncFuture`1.#ctor(Neon.Cadence.Workflow,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="activityId">The workflow local activity ID.</param>
        </member>
        <member name="M:Neon.Cadence.ActivityFutureStub`1.AsyncFuture`1.GetAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.ActivityFutureStub`1.#ctor(Neon.Cadence.Workflow,System.String,Neon.Cadence.ActivityOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parentWorkflow">The associated parent workflow.</param>
            <param name="methodName">
            Optionally identifies the target activity method by the name specified in
            the <c>[ActivityMethod]</c> attribute tagging the method.  Pass a <c>null</c>
            or empty string to target the default method.
            </param>
            <param name="options">The activity options or <c>null</c>.</param>
        </member>
        <member name="M:Neon.Cadence.ActivityFutureStub`1.StartAsync``1(System.Object[])">
            <summary>
            Starts the target activity that returns <typeparamref name="TActivityInterface"/>, passing the specified arguments.
            </summary>
            <typeparam name="TResult">The activity result type.</typeparam>
            <param name="args">The arguments to be passed to the activity.</param>
            <returns>The <see cref="T:Neon.Tasks.IAsyncFuture`1"/> with the <see cref="M:Neon.Tasks.IAsyncFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a future stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target activity parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Cadence.ActivityFutureStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.ActivityFutureStub`1.StartAsync(System.Object[])">
            <summary>
            Starts the target activity that returns <c>void</c>, passing the specified arguments.
            </summary>
            <param name="args">The arguments to be passed to the activity.</param>
            <returns>The <see cref="T:Neon.Tasks.IAsyncFuture`1"/> with the <see cref="M:Neon.Tasks.IAsyncFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a future stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target activity parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Cadence.ActivityFutureStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.ActivityInterfaceAttribute">
            <summary>
            Used to tag activity interfaces and optionally specify the task list
            identifying the workers hosting this activity.  <see cref="T:Neon.Cadence.CadenceClient"/>
            for more information on how task lists work.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityInterfaceAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityInterfaceAttribute.Domain">
            <summary>
            Optionally specifies the Cadence domain where the activity is registered.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityInterfaceAttribute.TaskList">
            <summary>
            Optionally specifies the Cadence task list identifying the workers
            hosting this activity.
            </summary>
        </member>
        <member name="T:Neon.Cadence.ActivityMethodAttribute">
            <summary>
            Used to customize activity interface method options.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityMethodAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityMethodAttribute.Name">
            <summary>
            Specifies the name to be used to identify a specific activity method.  This is optional
            for activity interfaces that have only one method but is required for interfaces with
            multiple entry points.
            </summary>
            <remarks>
            <para>
            When specified, this name will be combined with the activity type name when registering
            and executing an activity via the method.  This will look like:
            </para>
            <code>
            ACTIVITY_TYPENAME::METHODNAME
            </code>
            <para>
            where <b>ACTIVITY_TYPENAME</b> is either the activity interface's fully qualified 
            name or the name specified by <see cref="P:Neon.Cadence.ActivityAttribute.Name"/> and 
            <b>METHOD_NAME</b> is from <see cref="P:Neon.Cadence.ActivityMethodAttribute.Name"/>.  This
            is the same convention implemented by the Java client.
            </para>
            <para>
            Sometimes it's useful to be able to specify a workflow type name that doesn't
            follow the convention above, for example to interoperate with workflows written
            in another language..  You can do this by setting <see cref="P:Neon.Cadence.ActivityMethodAttribute.Name"/> to the
            required workflow type name and then setting <see cref="P:Neon.Cadence.ActivityMethodAttribute.IsFullName"/><c>=true</c>.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Cadence.ActivityMethodAttribute.IsFullName">
            <summary>
            <para>
            Optionally indicates that <see cref="P:Neon.Cadence.ActivityMethodAttribute.Name"/> holds the fully qualified type name for
            the workflow and that the .NET client will not add a prefix to <see cref="P:Neon.Cadence.ActivityMethodAttribute.Name"/>
            when registering the workflow.
            </para>
            <para>
            This is useful when interoperating with workflows written in another language by
            providing a way to specify a specific workflow type name. 
            </para>
            <note>
            <see cref="P:Neon.Cadence.ActivityMethodAttribute.Name"/> cannot be <c>null</c> or empty when this is <c>true</c>.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityMethodAttribute.HeartbeatTimeoutSeconds">
            <summary>
            <para>
            Optionally specifies the maximum time can wait between recording
            a heartbeat before Cadence will consider the activity to have 
            timed out.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityMethodAttribute.ScheduleToCloseTimeoutSeconds">
            <summary>
            <para>
            Optionally specifies the maximum total time allowed for the activity to
            complete from the time it is scheduled.  This includes the time the 
            activity is waiting to start executing on the worker, the time it takes
            for the activity to execute on the worker, as well as any time scheduling
            and performing retries.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityMethodAttribute.ScheduleToStartTimeoutSeconds">
            <summary>
            <para>
            Optionally specifies the maximum time the activity may remain 
            in the task list before being assigned to a worker.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityMethodAttribute.StartToCloseTimeoutSeconds">
            <summary>
            <para>
            Optionally specifies the maximum execution time for
            an individual workflow task once it has been assigned
            to a worker.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityMethodAttribute.TaskList">
            <summary>
            <para>
            Optionally specifies the target task list.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityMethodAttribute.Domain">
            <summary>
            <para>
            Optionally specifies the target domain.
            </para>
            </summary>
        </member>
        <member name="T:Neon.Cadence.ActivityOptions">
            <summary>
            Specifies the options used for executing an activity.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityOptions.Normalize(Neon.Cadence.CadenceClient,Neon.Cadence.ActivityOptions,System.Type,System.Reflection.MethodInfo)">
            <summary>
            Normalizes the options passed by creating or cloning a new instance as
            required and filling unset properties using default client settings.
            </summary>
            <param name="client">The associated Cadence client.</param>
            <param name="options">The input options or <c>null</c>.</param>
            <param name="activityInterface">Optionally specifies the activity interface definition.</param>
            <param name="method">Optionally specifies the target workflow method.</param>
            <returns>The normalized options.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if a valid task list is not specified.</exception>
        </member>
        <member name="P:Neon.Cadence.ActivityOptions.TaskList">
            <summary>
            Optionally specifies the target Cadence task list.  This defaults to the task list
            specified by <see cref="P:Neon.Cadence.ActivityMethodAttribute.TaskList"/>,
            <see cref="P:Neon.Cadence.ActivityInterfaceAttribute.TaskList"/>, or the parent workflow's
            task list, in that order of precedence.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityOptions.Domain">
            <summary>
            Optionally specifies the target Cadence domain.  This defaults to the domain
            specified by <see cref="P:Neon.Cadence.ActivityMethodAttribute.Domain"/>, 
            <see cref="P:Neon.Cadence.ActivityInterfaceAttribute.Domain"/>, or 
            to the parent workflow's domain, in that order of precedence.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityOptions.ScheduleToCloseTimeout">
            <summary>
            Optionally specifies the end-to-end timeout for the activity.  The 
            default <see cref="F:System.TimeSpan.Zero"/> value uses the sum of 
            <see cref="P:Neon.Cadence.ActivityOptions.ScheduleToStartTimeout"/> and <see cref="P:Neon.Cadence.ActivityOptions.StartToCloseTimeout"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityOptions.ScheduleToStartTimeout">
            <summary>
            Specifies the maximum time the activity be queued, waiting to be scheduled
            on a worker.  This defaults to <see cref="P:Neon.Cadence.CadenceSettings.ActivityScheduleToStartTimeoutSeconds"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityOptions.StartToCloseTimeout">
            <summary>
            Specifies the maximum time the activity may take to run.  This defaults to
            <see cref="P:Neon.Cadence.CadenceSettings.ActivityStartToCloseTimeoutSeconds"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityOptions.HeartbeatTimeout">
            <summary>
            Optionally specifies the maximum time the activity has to send a heartbeat
            back to Cadence.  This defaults to <see cref="F:System.TimeSpan.Zero"/> which indicates
            that no heartbeating is required.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityOptions.WaitForCancellation">
            <summary>
            Optionally specifies that the cancelled activities won't be considered to be
            finished until they actually complete.  This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityOptions.RetryOptions">
            <summary>
            Optionally specifies the activity retry policy.  The default value is <c>null</c> which indicates
            that there will be no retry attempts.
            </summary>
            <remarks>
            <para>
            When <see cref="P:Neon.Cadence.RetryOptions.ExpirationInterval"/> is specified and it is larger than the activity's 
            <see cref="P:Neon.Cadence.ActivityOptions.ScheduleToStartTimeout"/>, then the <see cref="P:Neon.Cadence.RetryOptions.ExpirationInterval"/> will override 
            activity's <see cref="P:Neon.Cadence.ActivityOptions.ScheduleToStartTimeout"/>. This is to avoid retrying on <see cref="P:Neon.Cadence.ActivityOptions.ScheduleToStartTimeout"/>
            error which only happen when worker is not picking up the task within the timeout.
            </para>
            <para>
            Retrying <see cref="P:Neon.Cadence.ActivityOptions.ScheduleToStartTimeout"/> does not make sense as it just
            mark the task as failed and create a new task and put back in the queue waiting worker to pick again. Cadence
            server also make sure the <see cref="P:Neon.Cadence.ActivityOptions.ScheduleToStartTimeout"/> will not be larger than the workflow's timeout.
            Same apply to <see cref="P:Neon.Cadence.ActivityOptions.StartToCloseTimeout"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.ActivityOptions.ToInternal">
            <summary>
            Converts the instance to its internal representation.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityOptions.Clone">
            <summary>
            Returns a shallow clone of the current instance.
            </summary>
            <returns>The cloned <see cref="T:Neon.Cadence.ActivityOptions"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.ActivityStatus">
            <summary>
            Enumerates the state of an activity.
            </summary>
        </member>
        <member name="F:Neon.Cadence.ActivityStatus.Scheduled">
            <summary>
            The activity is waiting to be started.
            </summary>
        </member>
        <member name="F:Neon.Cadence.ActivityStatus.Started">
            <summary>
            The activity is running.
            </summary>
        </member>
        <member name="F:Neon.Cadence.ActivityStatus.CancelRequested">
            <summary>
            The activity has a cancellation request pending.
            </summary>
        </member>
        <member name="T:Neon.Cadence.ActivityStub">
            <summary>
            Used to execute an untyped activity whose .NET type information is not known
            at runtime or an activity written in different languages.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityStub.#ctor(Neon.Cadence.CadenceClient,Neon.Cadence.Workflow,System.String,Neon.Cadence.ActivityOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="client">The associated client.</param>
            <param name="parentWorkflow">Identifies the parent workflow.</param>
            <param name="activityTypeName">Specifies the target activity type name.</param>
            <param name="options">Optionally specifies custom activity options.</param>
            <remarks>
            <para>
            <paramref name="activityTypeName"/> specifies the target activity implementation type name and optionally,
            the specific activity method to be called for activity interfaces that have multiple methods.  For
            activity methods tagged by <c>ActivityMethod]</c>[ with specifying a name, the activity type name will default
            to the fully qualified interface type name or the custom type name specified by <see cref="P:Neon.Cadence.ActivityAttribute.Name"/>.
            </para>
            <para>
            For activity methods with <see cref="P:Neon.Cadence.ActivityMethodAttribute.Name"/> specified, the activity type will
            look like this by default:
            </para>
            <code>
            ACTIVITY-TYPE-NAME::METHOD-NAME
            </code>
            <note>
            You may need to customize activity type name when interoperating with activities written
            in other languages.  See <a href="https://doc.neonkube.com/Neon.Cadence-CrossPlatform.htm">Cadence Cross-Platform</a>
            for more information.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.ActivityStub.ExecuteAsync(System.Object[])">
            <summary>
            Executes an activity that doesn't return a result (or when the caller doesn't
            care about the result).
            </summary>
            <param name="args">The activity arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.ActivityStub.ExecuteAsync``1(System.Object[])">
            <summary>
            Executes an activity by activity type name that returns the <typeparamref name="TResult"/>.
            </summary>
            <typeparam name="TResult">The activity result type. </typeparam>
            <param name="args">The activity arguments.</param>
            <returns>The activity result.</returns>
        </member>
        <member name="T:Neon.Cadence.ActivityTask">
            <summary>
            Holds information about an executing activity.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityTask.TaskToken">
            <summary>
            The opaque base-64 encoded activity task token.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityTask.WorkflowTypeName">
            <summary>
            The parent workflow type name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityTask.WorkflowDomain">
            <summary>
            The parent workflow domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityTask.WorkflowExecution">
            <summary>
            The parent workflow execution details.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityTask.ActivityId">
            <summary>
            The activity ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityTask.ActivityTypeName">
            <summary>
            The activity type name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityTask.TaskList">
            <summary>
            The activity task list.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityTask.HeartbeatTimeout">
            <summary>
            The maximum time between heartbeats.  <see cref="F:System.TimeSpan.Zero"/> 
            indicates that no heartbeating is required.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityTask.ScheduledTimeUtc">
            <summary>
            Time (UTC) when the activity was scheduled.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityTask.StartedTimeUtc">
            <summary>
            Time (UTC) when the activity was started.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityTask.DeadlineTimeUtc">
            <summary>
            Time (UTC) when the activity will timeout.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ActivityTask.Attempt">
            <summary>
            Indicates how many times the activity was been restarted.  This will be zero
            for the first execution, 1 for the second, and so on.
            </summary>
        </member>
        <member name="T:Neon.Cadence.ArchivalStatus">
            <summary>
            Controls archival.
            </summary>
        </member>
        <member name="F:Neon.Cadence.ArchivalStatus.Disabled">
            <summary>
            Disables archival.
            </summary>
        </member>
        <member name="F:Neon.Cadence.ArchivalStatus.Enabled">
            <summary>
            Enables archival.
            </summary>
        </member>
        <member name="T:Neon.Cadence.CadenceClient">
            <summary>
            Implements a client that will be connected to a Cadence cluster and be used
            to create and manage workflows.
            </summary>
            <remarks>
            <para>
            To get started with Cadence, you'll need to deploy a Cadence cluster with
            one or more nodes and the establish a connection to the cluster from your
            workflow/activity implementations and management tools.  This is pretty
            easy to do.
            </para>
            <para>
            First, you'll need to know the URI of at least one of the Cadence cluster
            nodes.  Cadence listens on port <b>79133</b> by default so you cluster URIs
            will typically look like: <b>http://CADENCE-NODE:7933</b>.
            </para>
            <note>
            For production clusters with multiple Cadence nodes, you should specify
            multiple URIs when connecting just in case the one of the nodes may be
            offline for some reason.
            </note>
            <para>
            To establish a connection, you'll construct a <see cref="T:Neon.Cadence.CadenceSettings"/>
            and add your node URIs to the <see cref="P:Neon.Cadence.CadenceSettings.Servers"/> list
            and then call the static <see cref="M:Neon.Cadence.CadenceClient.ConnectAsync(Neon.Cadence.CadenceSettings)"/>
            method to obtain a connected <see cref="T:Neon.Cadence.CadenceClient"/>.  You'll use this
            for registering workflows and activities types as well as the workers that
            indicate that workflows and activities can be executed in the current process.
            </para>
            <note>
            <b>IMPORTANT:</b> The current .NET Cadence client release supports having only
            one client open at a time.  A <see cref="T:System.NotSupportedException"/> will be thrown
            when attempting to connect a second client.  This restriction may be relaxed
            for future releases.
            </note>
            <para>
            You'll implement your workflows and activities by implementing classes that
            derive from <see cref="T:Neon.Cadence.WorkflowBase"/> and <see cref="T:Neon.Cadence.ActivityBase"/> and then
            registering these types with Cadence.  Then you'll start workflow or activity
            workers so that Cadence will begin scheduling operations for execution by your code.
            Workflows and activities are registered using the fully qualified names 
            of the derived <see cref="T:Neon.Cadence.WorkflowBase"/> and <see cref="T:Neon.Cadence.ActivityBase"/> types
            by defaut, but you can customize this if desired.
            </para>
            <para>
            Cadence supports the concept of domains and task lists.  Domains and task lists are
            used to organize workflows and activities.  Workflows and activities essentially 
            reside in a registered domain, which is essentially just a namespace specified by
            a string.  The combination of a domain along with a workflow or activity type name
            must be unique within a Cadence cluster.  Once you have a connected <see cref="T:Neon.Cadence.CadenceClient"/>,
            you can create and manage Cadence domains via methods like <see cref="M:Neon.Cadence.CadenceClient.RegisterDomainAsync(System.String,System.String,System.String,System.Int32,System.Boolean)"/>,
            <see cref="M:Neon.Cadence.CadenceClient.DescribeDomainAsync(System.String)"/>, and <see cref="M:Neon.Cadence.CadenceClient.UpdateDomainAsync(System.String,Neon.Cadence.UpdateDomainRequest)"/>.
            Domains can be used provide isolated areas for different teams and/or different environments
            (e.g. production, staging, and test).  We discuss task lists in detail further below.
            </para>
            <para>
            Cadence workers are started to indicate that the current process can execute workflows
            and activities from a Cadence domain, and optionally a task list (discussed further below).
            You'll call <see cref="M:Neon.Cadence.CadenceClient.StartWorkerAsync(System.String,Neon.Cadence.WorkerOptions,System.String)"/> to indicate
            that Cadence can begin scheduling workflow and activity executions from the current client.
            </para>
            <para>
            Workflows are implemented by defining an interface describing the workflow methods
            and then writing a class the implements your interface and also inherits <see cref="T:Neon.Cadence.WorkflowBase"/>.  
            Your workflow interface  must define at least one entry point method tagged by <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/> and
            may optionally include signal and query methods  tagged by <see cref="T:Neon.Cadence.SignalMethodAttribute"/> 
            and <see cref="T:Neon.Cadence.QueryMethodAttribute"/>.
            </para>
            <para>
            Activities are implemented in the same way by defining an activity interface and then writing a class
            that implements this  interface. and inherits <see cref="T:Neon.Cadence.ActivityBase"/>.  Your activity interface
            must define at least one entry point method.
            </para>
            <para>
            After establishing a connection ot a Cadence cluster, you'll need to call 
            <see cref="M:Neon.Cadence.CadenceClient.RegisterWorkflowAsync``1(System.String,System.String)"/> and/or
            <see cref="M:Neon.Cadence.CadenceClient.RegisterActivityAsync``1(System.String,System.String)"/> to register your
            workflow and activity implementations with Cadence.  These calls combined with the
            workers described above determine which workflows and activities may be scheduled
            on the current client/process.
            </para>
            <para>
            For situations where you have a lot of workflow and activity classes, it can become
            cumbersome to register each implementation class individually (generally because you
            forget to register new classes after they've been implemented).  To assist with this,
            you can also tag your workflow and activity classes with <see cref="T:Neon.Cadence.WorkflowAttribute"/>
            or <see cref="T:Neon.Cadence.ActivityAttribute"/> with <see cref="P:Neon.Cadence.WorkflowAttribute.AutoRegister"/>
            or <see cref="P:Neon.Cadence.ActivityAttribute.AutoRegister"/> set to <c>true</c> and then call
            <see cref="M:Neon.Cadence.CadenceClient.RegisterAssemblyWorkflowsAsync(System.Reflection.Assembly,System.String)"/> and/or
            <see cref="M:Neon.Cadence.CadenceClient.RegisterAssemblyActivitiesAsync(System.Reflection.Assembly,System.String)"/> to scan an
            assembly and automatically register the tagged implementation classes it finds.
            </para>
            <note>
            <para>
            The .NET client uses a simple huristic to try to ensure that the default workflow and activity
            type names applied when the <see cref="P:Neon.Cadence.WorkflowAttribute.Name"/> and <see cref="P:Neon.Cadence.ActivityAttribute.Name"/>
            properties are not set for the interface and implementation classes.  If the interface
            name starts with an "I", the "I" will be stripped out before generating the fully qualified
            type name.  This handles the common C# convention where interface names started with an "I"
            and the implementing class uses the same name as the interface, but without the "I".
            </para>
            <para>
            If this huristic doesn't work, you'll need to explicitly specify the same type name in
            the <see cref="T:Neon.Cadence.WorkflowAttribute"/> or <see cref="T:Neon.Cadence.ActivityAttribute"/> tagging your 
            interface and class definitions.
            </para>
            </note>
            <para>
            Next you'll need to start workflow and/or activity workers.  These indicate to Cadence that 
            the current process implements specific workflow and activity types.  You'll call
            <see cref="M:Neon.Cadence.CadenceClient.StartWorkerAsync(System.String,Neon.Cadence.WorkerOptions,System.String)"/>.  You can customize the
            Cadence domain and task list the worker will listen on as well as whether activities,
            workflows, or both are to be processed.
            </para>
            <para>
            You'll generally create stub classes to start and manage workflows and activities.
            These come in various flavors with the most important being typed and untyped stubs.
            Typed stubs are nice because they implement your workflow or activity interface so
            that the C# compiler can provide compile-time type checking.  Untyped stubs provide
            a way to interact with workflows and activities written on other languages or for
            which you don't have source code.
            </para>
            <para>
            You can create typed external workflow stubs via <see cref="M:Neon.Cadence.CadenceClient.NewWorkflowStub``1(System.String,System.String,System.String)"/>
            and <see cref="M:Neon.Cadence.CadenceClient.NewWorkflowStub``1(Neon.Cadence.WorkflowOptions,System.String)"/>.
            </para>
            <para>
            Workflows can use their <see cref="T:Neon.Cadence.Workflow"/> property to create child workflow as
            well as activity stubs.
            </para>
            <para><b>Task Lists</b></para>
            <para>
            Task lists are used by Cadence to identify the set of workflows and activities that
            are implemented by workers.  For example, if you deploy a program called <b>payments.exe</b>
            that implements payment related workflows and activities like <b>validate</b>,
            <b>debit</b>, <b>credit</b>,... you could register these and then start a worker using
            <b>tasklist=payments</b>.
            </para>
            <para>
            You'll need to provide the correct task list when executing a workflow or normal (non-local)
            activity.  Cadence will schedule the workflow or activity on one of the workers that
            was started with the specified task list.  The most convienent way to specify the task list
            is to tag your workflow and activity interfaces with <c>[WorkflowInterface(TaskList = "payments")]</c>
            and <c>[ActivityInterface(TaskList = "payments")]</c> attributes, specifying the target task list.
            </para>
            <para>
            You may also specify a custom task list in the workflow and activity options used when
            executing a workflow or activity.  A task list specified in one of these options takes
            precedence over the task list specified in an attribute.
            </para>
            <note>
            The .NET client will complain if a task list is not specified in either an interface
            attribute or the options.
            </note>
            <note>
            <para>
            <b>IMPORTANT:</b> You need to take care to ensure that the task lists you use for your
            workers uniquely identify the set of workflows and activities registered for the workers.
            For example, if you start two workers, <b>worker-a</b> and <b>worker-b</b> using the same
            task list, but <b>worker-a</b> registers the <b>foo</b> workflow and <b>worker-b</b>
            registers the <c>bar</c> activity, you're going run into trouble.
            </para>
            <para>
            The problem is that Cadence assumes that both workers implement the same workflows, both
            <b>foo</b> and <b>bar</b> in this case.  Say you start a <b>foo</b> workflow.  Cadence
            will select one of <b>worker-a</b> or <b>worker-b</b> to run the workflow.  If Cadence
            happens to select <b>worker-a</b> everything will work as expected because <b>foo</b>
            is registered there.  If Cadence selects <b>worker-b</b> the initial execution will fail
            because <b>foo</b> is not registered there.  Cadence handles this a decision task failure
            and will attempt to reschedule the workflow on another worker (hopefully <b>worker-a</b>
            this time).
            </para>
            <para>
            Cadence fault tolerance will probably end up being able to handle this sort misconfiguration,
            but at the cost of additional delays as well as unnecessary communication overhead to workers
            that will never be able to execute unregistered workflows and activities.
            </para>
            <para>
            So the moral of this store is carefully choose your task lists to match the set of workflows
            and activities implemented by your application.  One common approach is to name the task list
            after the service or application that implements the workflow anbd activities.
            </para>
            </note>
            <note>
            <para>
            Activity and workflow stubs are generated and compiled on demand by default.  This takes 
            about 500ms for each stub.  This generally works fine but may cause decision task timeouts 
            for workflows that call a lot of different child workflows or activities.
            </para>
            <para>
            The default workflow decision task timeout is 10 seconds, so a workflow
            that creates 22 stubs when its first called will have a decent chance
            of timing out due to the 500ms * 22 = 11 seconds it will take for the 
            .NET client generate and build the backing classes.
            </para>
            <note>
            This is only an issue the first time a stub classes are built, so it'll
            be very likely that the workflow will proceed the second time it's invoked
            on the same worker because the generated stub classes are cached.
            </note>
            <para>
            You can proactively address this by prebuilding stub classes before starting
            any workers by calling <see cref="M:Neon.Cadence.CadenceClient.BuildActivityStub``1"/>, 
            <see cref="M:Neon.Cadence.CadenceClient.BuildWorkflowStub``1"/>, and/or <see cref="M:Neon.Cadence.CadenceClient.BuildAssemblyStubs(System.Reflection.Assembly)"/>.
            After doing this, the specified stubs will already be generated and compiled
            when the worker starts and begins invoking workflows and activities.
            </para>
            </note>
            </remarks>
        </member>
        <member name="E:Neon.Cadence.CadenceClient.ActivityExecuteEvent">
            <summary>
            Raised when a normal (non-local) is executed.  This is used internally
            for unit tests that verify that activity options are configured correctly. 
            </summary>
        </member>
        <member name="E:Neon.Cadence.CadenceClient.LocalActivityExecuteEvent">
            <summary>
            Raised when a local is executed.  This is used internally for unit tests 
            that verify that activity options are configured correctly. 
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.RaiseActivityExecuteEvent(Neon.Cadence.ActivityOptions)">
            <summary>
            Raises the <see cref="E:Neon.Cadence.CadenceClient.ActivityExecuteEvent"/>.
            </summary>
            <param name="options">The activity options.</param>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.RaiseLocalActivityExecuteEvent(Neon.Cadence.LocalActivityOptions)">
            <summary>
            Raises the <see cref="E:Neon.Cadence.CadenceClient.LocalActivityExecuteEvent"/>.
            </summary>
            <param name="options">The activity options.</param>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.RegisterActivityAsync``1(System.String,System.String)">
            <summary>
            Registers an activity implementation with Cadence.
            </summary>
            <typeparam name="TActivity">The <see cref="T:Neon.Cadence.ActivityBase"/> derived class implementing the activity.</typeparam>
            <param name="activityTypeName">
            Optionally specifies a custom activity type name that will be used 
            for identifying the activity implementation in Cadence.  This defaults
            to the fully qualified <typeparamref name="TActivity"/> type name.
            </param>
            <param name="domain">Optionally overrides the default client domain.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if a different activity class has already been registered for <paramref name="activityTypeName"/>.</exception>
            <exception cref="T:Neon.Cadence.ActivityWorkerStartedException">
            Thrown if an activity worker has already been started for the client.  You must
            register activity implementations before starting workers.
            </exception>
            <remarks>
            <note>
            Be sure to register all services you will be injecting into activities via
            <see cref="P:Neon.Common.NeonHelper.ServiceContainer"/> before you call this as well as 
            registering of your activity implementations before starting workers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.RegisterAssemblyActivitiesAsync(System.Reflection.Assembly,System.String)">
            <summary>
            Scans the assembly passed looking for activity implementations derived from
            <see cref="T:Neon.Cadence.ActivityBase"/> and tagged by <see cref="T:Neon.Cadence.ActivityAttribute"/> and
            registers them with Cadence.
            </summary>
            <param name="assembly">The target assembly.</param>
            <param name="domain">Optionally overrides the default client domain.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.TypeLoadException">
            Thrown for types tagged by <see cref="T:Neon.Cadence.ActivityAttribute"/> that are not 
            derived from <see cref="T:Neon.Cadence.ActivityBase"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">Thrown if one of the tagged classes conflict with an existing registration.</exception>
            <exception cref="T:Neon.Cadence.ActivityWorkerStartedException">
            Thrown if an activity worker has already been started for the client.  You must
            register activity implementations before starting workers.
            </exception>
            <remarks>
            <note>
            Be sure to register all services you will be injecting into activities via
            <see cref="P:Neon.Common.NeonHelper.ServiceContainer"/> before you call this as well as 
            registering of your activity implementations before starting workers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.ActivityHeartbeatByTokenAsync(System.String,System.Object,System.String)">
            <summary>
            Used to send record activity heartbeat externally by task token.
            </summary>
            <param name="taskToken">The opaque base-64 encoded activity task token.</param>
            <param name="details">Optional heartbeart details.</param>
            <param name="domain">Optionally overrides the default <see cref="T:Neon.Cadence.CadenceClient"/> domain.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.ActivityHeartbeatByIdAsync(Neon.Cadence.WorkflowExecution,System.String,System.Object,System.String)">
            <summary>
            Used to send record activity heartbeat externally by <see cref="T:Neon.Cadence.WorkflowExecution"/> and activity ID.
            </summary>
            <param name="execution">The workflow execution.</param>
            <param name="activityId">The activity ID.</param>
            <param name="details">Optional heartbeart details.</param>
            <param name="domain">Optionally overrides the default <see cref="T:Neon.Cadence.CadenceClient"/> domain.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.ActivityCompleteByTokenAsync(System.String,System.Object,System.String)">
            <summary>
            Used to externally complete an activity identified by task token.
            </summary>
            <param name="taskToken">The opaque base-64 encoded activity task token.</param>
            <param name="domain">Optionally overrides the default <see cref="T:Neon.Cadence.CadenceClient"/> domain.</param>
            <param name="result">Passed as the activity result for activity success.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the activity no longer exists.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.ActivityCompleteByIdAsync(Neon.Cadence.WorkflowExecution,System.String,System.Object,System.String)">
            <summary>
            Used to externally complete an activity identified by <see cref="T:Neon.Cadence.WorkflowExecution"/> and activity ID.
            </summary>
            <param name="execution">The workflow execution.</param>
            <param name="activityId">The activity ID.</param>
            <param name="result">Passed as the activity result for activity success.</param>
            <param name="domain">Optionally overrides the default <see cref="T:Neon.Cadence.CadenceClient"/> domain.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the activity no longer exists.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.ActivityErrorByTokenAsync(System.String,System.Exception,System.String)">
            <summary>
            Used to externally fail an activity by task token.
            </summary>
            <param name="taskToken">The opaque base-64 encoded activity task token.</param>
            <param name="error">Specifies the activity error.</param>
            <param name="domain">Optionally overrides the default <see cref="T:Neon.Cadence.CadenceClient"/> domain.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the activity no longer exists.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.ActivityErrorByIdAsync(Neon.Cadence.WorkflowExecution,System.String,System.Exception,System.String)">
            <summary>
            Used to externally fail an activity by <see cref="T:Neon.Cadence.WorkflowExecution"/> and activity ID.
            </summary>
            <param name="execution">The workflowm execution.</param>
            <param name="activityId">The activity ID.</param>
            <param name="error">Specifies the activity error.</param>
            <param name="domain">Optionally overrides the default <see cref="T:Neon.Cadence.CadenceClient"/> domain.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the activity no longer exists.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.PingAsync">
            <summary>
            Pings the <b>cadence-proxy</b> and waits for the reply.  This is used 
            mainly for low-level performance and load testing but can also be used
            to explicitly verify that the <b>cadence-proxy</b> is still alive.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.RegisterAssemblyAsync(System.Reflection.Assembly,System.String)">
            <summary>
            Scans the assembly passed looking for workflow and activity implementations 
            derived from and registers them with Cadence.  This is equivalent to calling
            <see cref="M:Neon.Cadence.CadenceClient.RegisterAssemblyWorkflowsAsync(System.Reflection.Assembly,System.String)"/> and
            <see cref="M:Neon.Cadence.CadenceClient.RegisterAssemblyActivitiesAsync(System.Reflection.Assembly,System.String)"/>,
            </summary>
            <param name="assembly">The target assembly.</param>
            <param name="domain">Optionally overrides the default client domain.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.TypeLoadException">
            Thrown for types tagged by <see cref="T:Neon.Cadence.WorkflowAttribute"/> that are not 
            derived from <see cref="T:Neon.Cadence.WorkflowBase"/> or for types tagged by <see cref="T:Neon.Cadence.ActivityAttribute"/>
            that are now derived from <see cref="T:Neon.Cadence.ActivityBase"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">Thrown if one of the tagged classes conflict with an existing registration.</exception>
            <exception cref="T:Neon.Cadence.ActivityWorkerStartedException">
            Thrown if an activity worker has already been started for the client.  You must
            register activity implementations before starting workers.
            </exception>
            <exception cref="T:Neon.Cadence.WorkflowWorkerStartedException">
            Thrown if a workflow worker has already been started for the client.  You must
            register workflow implementations before starting workers.
            </exception>
            <remarks>
            <note>
            Be sure to register all services you will be injecting into activities via
            <see cref="P:Neon.Common.NeonHelper.ServiceContainer"/> before you call this as well as 
            registering of your activity and workflow implementations before starting 
            workers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.StartWorkerAsync(System.String,Neon.Cadence.WorkerOptions,System.String)">
            <summary>
            Signals Cadence that the application is capable of executing workflows and/or activities for a specific
            domain and task list.
            </summary>
            <param name="taskList">Specifies the task list implemented by the worker.  This must not be empty.</param>
            <param name="options">Optionally specifies additional worker options.</param>
            <param name="domain">Optionally overrides the default <see cref="T:Neon.Cadence.CadenceClient"/> domain.</param>
            <returns>A <see cref="T:Neon.Cadence.Worker"/> identifying the worker instance.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="taskList"/> is <c>null</c> or empty.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when an attempt is made to recreate a worker with the
            same properties on a given client.  See the note in the remarks.
            </exception>
            <remarks>
            <note>
            <see cref="T:Neon.Cadence.CadenceClient"/> for more information on task lists.
            </note>
            <para>
            Your workflow application will need to call this method so that Cadence will know
            that it can schedule activities to run within the current process.  You'll need
            to specify the target Cadence domain and task list.
            </para>
            <para>
            You may also specify an optional <see cref="T:Neon.Cadence.WorkerOptions"/> parameter as well
            as customize the name used to register the activity, which defaults to the
            fully qualified name of the activity type.
            </para>
            <para>
            This method returns a <see cref="T:Neon.Cadence.Worker"/> which implements <see cref="T:System.IDisposable"/>.
            It's a best practice to call <see cref="M:Neon.Cadence.CadenceClient.Dispose"/> just before the a worker process
            terminates, but this is optional.  Advanced worker implementation that need to change
            their configuration over time can also call <see cref="M:Neon.Cadence.CadenceClient.Dispose"/> to stop workers
            for specific domains and task lists.
            </para>
            <note>
            The Cadence GOLANG client does not appear to support starting a worker with a given
            set of parameters, stopping that workflow, and then restarting another worker
            with the same parameters on the same client.  This method detects this situation
            and throws an <see cref="T:System.InvalidOperationException"/> when a restart is attempted.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.DescribeTaskListAsync(System.String,Neon.Cadence.TaskListType,System.String)">
            <summary>
            Returns information about pollers (AKA workers) that have communicated 
            with the Cadence cluster in the last few minutes.
            </summary>
            <param name="taskList">Identifies the tasklist.</param>
            <param name="taskListType">
            Indicates whether to return information for decision (AKA workflow pollers)
            or activity pollers.
            </param>
            <param name="domain">Optionally specifies the Cadence domain.</param>
            <returns>The <see cref="T:Neon.Cadence.TaskListDescription"/> for the pollers.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.StopWorkerAsync(Neon.Cadence.Worker)">
            <summary>
            Signals Cadence that it should stop invoking activities and workflows 
            for the specified <see cref="T:Neon.Cadence.Worker"/> (returned by a previous call to
            <see cref="M:Neon.Cadence.CadenceClient.StartWorkerAsync(System.String,Neon.Cadence.WorkerOptions,System.String)"/>).
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            This method does nothing if the worker is already stopped.
            </remarks>
        </member>
        <member name="F:Neon.Cadence.CadenceClient.debugProxyPort">
            <summary>
            The <b>cadence-proxy</b> listening port to use when <see cref="P:Neon.Cadence.CadenceSettings.DebugPrelaunched"/>
            mode is enabled.
            </summary>
        </member>
        <member name="F:Neon.Cadence.CadenceClient.debugClientPort">
            <summary>
            The <b>cadence-client</b> listening port to use when <see cref="P:Neon.Cadence.CadenceSettings.DebugPrelaunched"/>
            mode is enabled.
            </summary>
        </member>
        <member name="F:Neon.Cadence.CadenceClient.QueryStack">
            <summary>
            The signal name used to retrieve the current stack trace.
            </summary>
        </member>
        <member name="F:Neon.Cadence.CadenceClient.QuerySyncSignal">
            <summary>
            The internal query name used to poll the state of a synchronous signals.
            </summary>
        </member>
        <member name="F:Neon.Cadence.CadenceClient.SignalSync">
            <summary>
            The signal name used for synchronous signals.  Signals sent here will be
            handled internally by <see cref="T:Neon.Cadence.WorkflowBase"/> and forwarded on to the
            user's signal handler method.
            </summary>
        </member>
        <member name="T:Neon.Cadence.CadenceClient.Operation">
            <summary>
            Used for tracking pending <b>cadence-proxy</b> operations.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.Operation.#ctor(System.Int64,Neon.Cadence.Internal.ProxyRequest,System.TimeSpan)">
            <summary>
            Constructor.
            </summary>
            <param name="requestId">The unique request ID.</param>
            <param name="request">The request message.</param>
            <param name="timeout">
            Optionally specifies the timeout.  This defaults to the end of time.
            </param>
        </member>
        <member name="P:Neon.Cadence.CadenceClient.Operation.RequestId">
            <summary>
            The operation (aka the request) ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceClient.Operation.Request">
            <summary>
            Returns the request message.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceClient.Operation.StartTimeUtc">
            <summary>
            The time (UTC) the operation started.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceClient.Operation.Timeout">
            <summary>
            The operation timeout. 
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceClient.Operation.CompletionSource">
            <summary>
            Returns the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> that we'll use
            to signal completion when <see cref="M:Neon.Cadence.CadenceClient.Operation.SetReply(Neon.Cadence.Internal.ProxyReply)"/> is called
            with the reply message for this operation, <see cref="M:Neon.Cadence.CadenceClient.Operation.SetCanceled"/> when
            the operation has been canceled, or <see cref="M:Neon.Cadence.CadenceClient.Operation.SetException(System.Exception)"/>
            is called signalling an error.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.Operation.SetReply(Neon.Cadence.Internal.ProxyReply)">
            <summary>
            Signals the awaiting <see cref="T:System.Threading.Tasks.Task"/> that a reply message 
            has been received.
            </summary>
            <param name="reply">The reply message.</param>
            <remarks>
            <note>
            Only the first call to <see cref="M:Neon.Cadence.CadenceClient.Operation.SetReply(Neon.Cadence.Internal.ProxyReply)"/>
            <see cref="M:Neon.Cadence.CadenceClient.Operation.SetException(System.Exception)"/>, or <see cref="M:Neon.Cadence.CadenceClient.Operation.SetCanceled"/>
            will actually wake the awaiting task.  Any subsequent calls will do nothing.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.Operation.SetCanceled">
            <summary>
            Signals the awaiting <see cref="T:System.Threading.Tasks.Task"/> that the operation has
            been canceled.
            </summary>
            <remarks>
            <note>
            Only the first call to <see cref="M:Neon.Cadence.CadenceClient.Operation.SetReply(Neon.Cadence.Internal.ProxyReply)"/>
            <see cref="M:Neon.Cadence.CadenceClient.Operation.SetException(System.Exception)"/>, or <see cref="M:Neon.Cadence.CadenceClient.Operation.SetCanceled"/>
            will actually wake the awaiting task.  Any subsequent calls will do nothing.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.Operation.SetException(System.Exception)">
            <summary>
            Signals the awaiting <see cref="T:System.Threading.Tasks.Task"/> that it should fail
            with an exception.
            </summary>
            <param name="e">The exception.</param>
            <remarks>
            <note>
            Only the first call to <see cref="M:Neon.Cadence.CadenceClient.Operation.SetReply(Neon.Cadence.Internal.ProxyReply)"/>
            <see cref="M:Neon.Cadence.CadenceClient.Operation.SetException(System.Exception)"/>, or <see cref="M:Neon.Cadence.CadenceClient.Operation.SetCanceled"/>
            will actually wake the awaiting task.  Any subsequent calls will do nothing.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.CadenceClient.HttpReply">
            <summary>
            Used to specify the HTTP reply to be returned for a received HTTP request.
            </summary>
        </member>
        <member name="F:Neon.Cadence.CadenceClient.HttpReply.StatusCode">
            <summary>
            The response HTTP status code.
            </summary>
        </member>
        <member name="F:Neon.Cadence.CadenceClient.HttpReply.Message">
            <summary>
            The response error message or <c>null</c>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.CadenceClient.HttpServer">
            <summary>
            Implements a simple integrated HTTP server that works for both .NET Core
            as well as .NET Framework, using Kestrel for .NET Core and WebListener
            for .NET Framework.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceClient.HttpServer.ListenUri">
            <summary>
            Returns the URI where the server is listening.
            </summary>
        </member>
        <member name="T:Neon.Cadence.CadenceClient.HttpServer.Startup">
            <summary>
            Configures the <b>cadence-client</b> connection's web server used to 
            receive messages from the <b>cadence-proxy</b> when serving via
            Kestrel on .NET Core.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.HttpServer.#ctor(System.Net.IPAddress,Neon.Cadence.CadenceSettings)">
            <summary>
            Constructor.
            </summary>
            <param name="address">The IP address where the service should listen.</param>
            <param name="settings">The Cadence settings.</param>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.HttpServer.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.Reset">
            <summary>
            Resets <see cref="T:Neon.Cadence.CadenceClient"/> to its initial state, by closing
            and existing connections and clearing any operation state.  This is
            called by the <b>CadenceFixture</b>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.ExtractCadenceProxy(System.String)">
            <summary>
            <para>
            Writes the <b>cadence-proxy</b> binaries to the specified folder.  This is
            provided so that you can pre-provision the executable and then use the 
            <see cref="P:Neon.Cadence.CadenceSettings.BinaryPath"/> setting to reference it.
            These files will be written:
            </para>
            <list type="table">
            <item>
                <term><b>cadence-proxy.win.exe</b></term>
                <description>
                The Windows AMD64 executable
                </description>
            </item>
            <item>
                <term><b>cadence-proxy.linux</b></term>
                <description>
                The Linux AMD64 executable
                </description>
            </item>
            <item>
                <term><b>cadence-proxy.osx</b></term>
                <description>
                The OS/X AMD64 executable
                </description>
            </item>
            </list>
            <para>
            This is useful for situations where the executable must be pre-provisioned for
            security.  One example is deploying Cadence workers to a Docker container with
            a read-only file system.
            </para>
            </summary>
            <param name="folderPath">Path to the output folder.</param>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.StartProxy(System.Net.IPEndPoint,Neon.Cadence.CadenceSettings,System.Int64)">
            <summary>
            <para>
            Writes the correct <b>cadence-proxy</b> binary for the current environment
            to the file system (if that hasn't been done already) and then launches 
            a proxy instance configured to listen at the specified endpoint.
            </para>
            <note>
            If <see cref="P:Neon.Cadence.CadenceSettings.BinaryPath"/> is not <c>null</c> or empty then
            we'll just execute that binary rather than trying to extract one.  We'll also
            assume that we already have execute permissions.
            </note>
            </summary>
            <param name="endpoint">The network endpoint where the proxy will listen.</param>
            <param name="settings">The cadence connection settings.</param>
            <param name="clientId">The associated client ID.</param>
            <returns>The proxy <see cref="T:System.Diagnostics.Process"/>.</returns>
            <remarks>
            By default, this class will write the binary to the same directory where
            this assembly resides.  This should work for most circumstances.  On the
            odd change that the current application doesn't have write access to this
            directory, you may specify an alternative via <paramref name="settings"/>.
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.GetClient(System.Int64)">
            <summary>
            Returns the client associated with a given ID.
            </summary>
            <param name="clientId">The client ID.</param>
            <returns>The <see cref="T:Neon.Cadence.CadenceClient"/> or <c>null</c> if the client doesn't exist.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.ConnectAsync(Neon.Cadence.CadenceSettings)">
            <summary>
            Establishes a connection to a Cadence cluster.
            </summary>
            <param name="settings">The <see cref="T:Neon.Cadence.CadenceSettings"/>.</param>
            <returns>The connected <see cref="T:Neon.Cadence.CadenceClient"/>.</returns>
            <remarks>
            <note>
            The <see cref="T:Neon.Cadence.CadenceSettings"/> passed must specify a <see cref="P:Neon.Cadence.CadenceSettings.DefaultDomain"/>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.OnKestralRequestAsync(Microsoft.AspNetCore.Http.HttpContext)">
            <summary>
            Called when an HTTP request is received by the integrated Kestrel web server 
            (presumably sent by the associated <b>cadence-proxy</b> process).
            </summary>
            <param name="context">The request context.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.OnRootRequestAsync(Neon.Cadence.Internal.ProxyMessage)">
            <summary>
            Handles requests to the root <b>"/"</b> endpoint path.
            </summary>
            <param name="proxyMessage">The received message.</param>
            <returns>The HTTP reply information.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.BuildActivityStub``1">
            <summary>
            Prebuilds and caches the internal activity stub class backing the
            <typeparamref name="TActivity"/> interface.  Subsequent calls for the
            same activity interface can be made but actually do nothing.
            </summary>
            <typeparam name="TActivity">The target activity interface.</typeparam>
            <remarks>
            <para>
            Activity and workflow stubs are generated and compiled on demand by default.  
            This takes  about 500ms for each stub.  This generally works fine but may cause 
            decision task timeouts for workflows that call a lot of different child
            workflows or activities.
            </para>
            <para>
            The default workflow decision task timeout is 10 seconds, so a workflow
            that creates 22 stubs when its first called will have a decent chance
            of timing out due to the 500ms * 22 = 11 seconds it will take for the 
            .NET client generate and build the backing classes.
            </para>
            <note>
            This is only an issue the first time a stub classes are built, so it'll
            be very likely that the workflow will proceed the second time it's invoked
            on the same worker because the generated stub classes are cached.
            </note>
            <para>
            You can proactively address this by prebuilding stub classes before starting
            any workers by calling <see cref="M:Neon.Cadence.CadenceClient.BuildActivityStub``1"/>, 
            <see cref="M:Neon.Cadence.CadenceClient.BuildWorkflowStub``1"/>, and/or <see cref="M:Neon.Cadence.CadenceClient.BuildAssemblyStubs(System.Reflection.Assembly)"/>.
            After doing this, the specified stubs will already be generated and compiled
            when the worker starts and begins invoking workflows and activities.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.BuildWorkflowStub``1">
            <summary>
            Prebuilds and caches the internal workflow stub class backing the
            <typeparamref name="TWorkflow"/> interface.  Subsequent calls for the
            same workflow interface can be made but actually do nothing.
            </summary>
            <typeparam name="TWorkflow">The target activity interface.</typeparam>
            <remarks>
            <para>
            Activity and workflow stubs are generated and compiled on demand by default.  
            This takes  about 500ms for each stub.  This generally works fine but may cause 
            decision task timeouts for workflows that call a lot of different child
            workflows or activities.
            </para>
            <para>
            The default workflow decision task timeout is 10 seconds, so a workflow
            that creates 22 stubs when its first called will have a decent chance
            of timing out due to the 500ms * 22 = 11 seconds it will take for the 
            .NET client generate and build the backing classes.
            </para>
            <note>
            This is only an issue the first time a stub classes are built, so it'll
            be very likely that the workflow will proceed the second time it's invoked
            on the same worker because the generated stub classes are cached.
            </note>
            <para>
            You can proactively address this by prebuilding stub classes before starting
            any workers by calling <see cref="M:Neon.Cadence.CadenceClient.BuildActivityStub``1"/>, 
            <see cref="M:Neon.Cadence.CadenceClient.BuildWorkflowStub``1"/>, and/or <see cref="M:Neon.Cadence.CadenceClient.BuildAssemblyStubs(System.Reflection.Assembly)"/>.
            After doing this, the specified stubs will already be generated and compiled
            when the worker starts and begins invoking workflows and activities.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.BuildAssemblyStubs(System.Reflection.Assembly)">
            <summary>
            Scans the assembly passed for any workflow or activity interfaces and
            pebuilds and caches the generated internal backing classes.  Subsequent 
            calls for the same assembly can be made but actually do nothing.
            </summary>
            <param name="assembly">The target assembly.</param>
            <remarks>
            <para>
            Activity and workflow stubs are generated and compiled on demand by default.  
            This takes  about 500ms for each stub.  This generally works fine but may cause 
            decision task timeouts for workflows that call a lot of different child
            workflows or activities.
            </para>
            <para>
            The default workflow decision task timeout is 10 seconds, so a workflow
            that creates 22 stubs when its first called will have a decent chance
            of timing out due to the 500ms * 22 = 11 seconds it will take for the 
            .NET client generate and build the backing classes.
            </para>
            <note>
            This is only an issue the first time a stub classes are built, so it'll
            be very likely that the workflow will proceed the second time it's invoked
            on the same worker because the generated stub classes are cached.
            </note>
            <para>
            You can proactively address this by prebuilding stub classes before starting
            any workers by calling <see cref="M:Neon.Cadence.CadenceClient.BuildActivityStub``1"/>, 
            <see cref="M:Neon.Cadence.CadenceClient.BuildWorkflowStub``1"/>, and/or <see cref="M:Neon.Cadence.CadenceClient.BuildAssemblyStubs(System.Reflection.Assembly)"/>.
            After doing this, the specified stubs will already be generated and compiled
            when the worker starts and begins invoking workflows and activities.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.#ctor">
            <summary>
            Used for unit testing only.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.#ctor(Neon.Cadence.CadenceSettings)">
            <summary>
            Constructor.
            </summary>
            <param name="settings">The <see cref="T:Neon.Cadence.CadenceSettings"/>.</param>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="P:Neon.Cadence.CadenceClient.Address">
            <summary>
            Returns the IP address to be used for binding the network interface for both
            the local web server as well as that for <b>cadence-proxy</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceClient.ClientId">
            <summary>
            Returns the locally unique ID for the client instance.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceClient.Settings">
            <summary>
            Returns the settings used to create the client.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceClient.ListenUri">
            <summary>
            Returns the URI the client is listening on for requests from the <b>cadence-proxy</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceClient.ProxyUri">
            <summary>
            Returns the URI the associated <b>cadence-proxy</b> instance is listening on.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceClient.DataConverter">
            <summary>
            <para>
            Specifies the <see cref="T:Neon.Cadence.IDataConverter"/> used for workflows and activities managed by the client.
            This defaults to <see cref="T:Neon.Cadence.JsonDataConverter"/>.
            </para>
            <note>
            When you need a custom data converter, you must set this immediately after connecting
            the client.  You must not change the converter after you've started workers.
            </note>
            </summary>
        </member>
        <member name="E:Neon.Cadence.CadenceClient.ConnectionClosed">
            <summary>
            Raised when the connection is closed.  You can determine whether the connection
            was closed normally or due to an error by examining the <see cref="T:Neon.Cadence.CadenceClientClosedArgs"/>
            arguments passed to the handler.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.DebugLog(System.String)">
            <summary>
            <para>
            <b>INTERNAL USE ONLY:</b> Appends a line of text to the debug log which is
            used internally to debug generated code like stubs.  This hardcodes its
            output to <b>C:\Temp\cadence-debug.log</b> so this currently only works
            on Windows.
            </para>
            <note>
            This method doesn't actually log anything unless <see cref="P:Neon.Cadence.CadenceSettings.Debug"/>
            is set to <c>true</c>.
            </note>
            </summary>
            <param name="text">The line of text to be written.</param>
        </member>
        <member name="P:Neon.Cadence.CadenceClient.SyncSignalRetry">
            <summary>
            <para>
            Controls how synchronous signals operations are polled until the signal operation is
            completed.  This defaults to something reasonable.
            </para>
            <note>
            The transient detector function specified by the policy passed is ignore and is
            replaced by a function that considers all exceptions to be transient.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.EnsureNotDisposed(System.Boolean)">
            <summary>
            Ensures that that client instance is not disposed.
            </summary>
            <param name="noClosingCheck">Optionally skip check that the connection is in the process of closing.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the client is disposed or is no longer connected to <b>cadence-proxy</b>.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.RaiseConnectionClosed(System.Exception)">
            <summary>
            Raises the <see cref="E:Neon.Cadence.CadenceClient.ConnectionClosed"/> event if it hasn't been
            raised already.
            </summary>
            <param name="exception">Optional exception to be included in the event.</param>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.GetActivityType(System.String)">
            <summary>
            Returns the .NET type implementing the named Cadence activity.
            </summary>
            <param name="activityTypeName">The Cadence activity type name.</param>
            <returns>The workflow .NET type or <c>null</c> if the type was not found.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.ResolveDomain(System.String)">
            <summary>
            Returns the Cadence domain to be referenced for an operation.  If <paramref name="domain"/>
            is not <c>null</c> or empty then that will be returned otherwise the  <see cref="P:Neon.Cadence.CadenceSettings.DefaultDomain"/>
            will be returned.  Note that one of <paramref name="domain"/> or the default domain must
            be non-empty.
            </summary>
            <param name="domain">The specific domain to use or null/empty.</param>
            <returns>The domain to be referenced.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="domain"/> and the default domain are both null or empty.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.CallProxyAsync(Neon.Cadence.Internal.ProxyRequest,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Asynchronously calls the <b>cadence-proxy</b> by sending a request message
            and then waits for a reply.
            </summary>
            <param name="request">The request message.</param>
            <param name="timeout">
            Optionally specifies the maximum time to wait for the operation to complete.
            This defaults to unlimited.
            </param>
            <param name="cancellationToken">Optional cancellation token.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.ProxyReplyAsync(Neon.Cadence.Internal.ProxyRequest,Neon.Cadence.Internal.ProxyReply)">
            <summary>
            <para>
            Asynchronously replies to a request from the <b>cadence-proxy</b>.
            </para>
            <note>
            The reply message's <see cref="P:Neon.Cadence.Internal.ProxyReply.RequestId"/> will be automatically
            set to the <paramref name="request"/> message's request ID by this method.
            </note>
            </summary>
            <param name="request">The received request message.</param>
            <param name="reply">The reply message.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.HeartbeatThread">
            <summary>
            Implements the connection's background thread which is responsible
            for checking <b>cadence-proxy</b> health via heartbeat requests.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.TimeoutThread">
            <summary>
            Implements the connection's background thread which is responsible
            for handling <b>cadence-proxy</b> request timeouts.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.RegisterDomainAsync(Neon.Cadence.Internal.InternalRegisterDomainRequest)">
            <summary>
            Registers a Cadence domain using the <see cref="T:Neon.Cadence.Internal.InternalRegisterDomainRequest"/> information passed.
            </summary>
            <param name="request">The domain properties.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Cadence.DomainAlreadyExistsException">Thrown if the domain already exists.</exception>
            <exception cref="T:Neon.Cadence.BadRequestException">Thrown when the request is invalid.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence cluster problems.</exception>
            <exception cref="T:Neon.Cadence.ServiceBusyException">Thrown when Cadence is too busy.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.RegisterDomainAsync(System.String,System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Registers a Cadence domain using the specified parameters.
            </summary>
            <param name="name">The domain name.</param>
            <param name="description">Optionally specifies a description.</param>
            <param name="ownerEmail">Optionally specifies the owner's email address.</param>
            <param name="retentionDays">
            Optionally specifies the number of days to retain the history for workflows 
            completed in this domain.  This defaults to <b>7 days</b> and may be as long
            as <b>30 days</b>.
            </param>
            <param name="ignoreDuplicates">
            Optionally ignore duplicate domain registrations.  This defaults
            to <c>false</c>.
            </param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Cadence.DomainAlreadyExistsException">Thrown if the domain already exists.</exception>
            <exception cref="T:Neon.Cadence.BadRequestException">Thrown when the request is invalid.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence cluster problems.</exception>
            <exception cref="T:Neon.Cadence.ServiceBusyException">Thrown when Cadence is too busy.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.DescribeDomainAsync(System.String)">
            <summary>
            Describes the named Cadence domain.
            </summary>
            <param name="name">The domain name.</param>
            <returns>The <see cref="T:Neon.Cadence.DomainDescription"/>.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the named domain does not exist.</exception>
            <exception cref="T:Neon.Cadence.BadRequestException">Thrown when the request is invalid.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence cluster problems.</exception>
            <exception cref="T:Neon.Cadence.ServiceBusyException">Thrown when Cadence is too busy.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.DescribeDomainByIdAsync(System.String)">
            <summary>
            Describes a Cadence domain by UUID.
            </summary>
            <param name="uuid">The domain ID.</param>
            <returns>The <see cref="T:Neon.Cadence.DomainDescription"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.UpdateDomainAsync(System.String,Neon.Cadence.UpdateDomainRequest)">
            <summary>
            Updates the named Cadence domain.
            </summary>
            <param name="name">Identifies the target domain.</param>
            <param name="request">The updated domain information.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.ListDomainsAsync(System.Int32,System.Byte[])">
            <summary>
            Lists the Cadence domains.
            </summary>
            <param name="pageSize">
            The maximum number of domains to be returned.  This must be
            greater than or equal to one.
            </param>
            <param name="nextPageToken">
            Optionally specifies an opaque token that can be used to retrieve subsequent
            pages of domains.
            </param>
            <returns>A <see cref="T:Neon.Cadence.DomainListPage"/> with the domains.</returns>
            <remarks>
            <para>
            This method can be used to retrieve one or more pages of domain
            results.  You'll pass <paramref name="pageSize"/> as the maximum number
            of domains to be returned per page.  The <see cref="T:Neon.Cadence.DomainListPage"/>
            returned will list the domains and if there are more domains waiting
            to be returned, will return token that can be used in a subsequent
            call to retrieve the next page of results.
            </para>
            <note>
            <see cref="P:Neon.Cadence.DomainListPage.NextPageToken"/> will be set to <c>null</c>
            when there are no more result pages remaining.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.RegisterWorkflowAsync``1(System.String,System.String)">
            <summary>
            Registers a workflow implementation with Cadence.
            </summary>
            <typeparam name="TWorkflow">The <see cref="T:Neon.Cadence.WorkflowBase"/> derived class implementing the workflow.</typeparam>
            <param name="workflowTypeName">
            Optionally specifies a custom workflow type name that will be used 
            for identifying the workflow implementation in Cadence.  This defaults
            to the fully qualified <typeparamref name="TWorkflow"/> type name.
            </param>
            <param name="domain">Optionally overrides the default client domain.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if another workflow class has already been registered for <paramref name="workflowTypeName"/>.</exception>
            <exception cref="T:Neon.Cadence.WorkflowWorkerStartedException">
            Thrown if a workflow worker has already been started for the client.  You must
            register workflow implementations before starting workers.
            </exception>
            <remarks>
            <note>
            Be sure to register all of your workflow implementations before starting workers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.RegisterAssemblyWorkflowsAsync(System.Reflection.Assembly,System.String)">
            <summary>
            Scans the assembly passed looking for workflow implementations derived from
            <see cref="T:Neon.Cadence.WorkflowBase"/> and tagged by <see cref="T:Neon.Cadence.WorkflowAttribute"/> with
            <see cref="P:Neon.Cadence.WorkflowAttribute.AutoRegister"/> set to <c>true</c> and registers 
            them with Cadence.
            </summary>
            <param name="assembly">The target assembly.</param>
            <param name="domain">Optionally overrides the default client domain.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.TypeLoadException">
            Thrown for types tagged by <see cref="T:Neon.Cadence.WorkflowAttribute"/> that are not 
            derived from <see cref="T:Neon.Cadence.WorkflowBase"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">Thrown if one of the tagged classes conflict with an existing registration.</exception>
            <exception cref="T:Neon.Cadence.WorkflowWorkerStartedException">
            Thrown if a workflow worker has already been started for the client.  You must
            register workflow implementations before starting workers.
            </exception>
            <remarks>
            <note>
            Be sure to register all of your workflow implementations before starting workers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.SetCacheMaximumSizeAsync(System.Int32)">
            <summary>
            <para>
            Sets the maximum number of sticky workflows for which of history will be 
            retained for workflow workers created by this client as a performance 
            optimization.  When this is exceeded, Cadence will may need to retrieve 
            the entire workflow history from the Cadence cluster when a workflow is 
            scheduled on the client's workers.
            </para>
            <para>
            This defaults to <b>10K</b> sticky workflows.
            </para>
            </summary>
            <param name="cacheMaximumSize">The maximum number of workflows to be cached.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.GetWorkflowCacheSizeAsync">
            <summary>
            Returns the current maximum number of sticky workflows for which history
            will be retained as a performance optimization.
            </summary>
            <returns>The maximum number of cached workflows.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.NewUntypedWorkflowStub(System.String,Neon.Cadence.WorkflowOptions)">
            <summary>
            Creates an untyped stub that can be used to start a single workflow execution.
            </summary>
            <param name="workflowTypeName">Specifies the workflow type name.</param>
            <param name="options">Specifies the workflow options (including the <see cref="P:Neon.Cadence.WorkflowOptions.TaskList"/>).</param>
            <returns>The <see cref="T:Neon.Cadence.WorkflowStub"/>.</returns>
            <remarks>
            <para>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/>.
            </para>
            <note>
            <para>
            .NET and Java workflows can implement multiple workflow methods using attributes
            and annotations to assign unique names to each.  Each workflow method is actually
            registered with Cadence as a distinct workflow type.  Workflow methods with a blank
            or <c>null</c> name will simply be registered using the workflow type name.
            </para>
            <para>
            Workflow methods with a name will be registered using a combination of the workflow
            type name and the method name, using <b>"::"</b> as the separator, like:
            </para>
            <code>
            WORKFLOW-TYPENAME::METHOD-NAME
            </code>
            <para>
            GOLANG doesn't support the concept of workflow methods.  GOLANG workflows 
            are just given a simple name which you'll pass here as <paramref name="workflowTypeName"/>
            to make cross platform calls.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.NewUntypedWorkflowStub(System.String,System.String,System.String)">
            <summary>
            Creates an untyped stub for a known workflow execution.
            </summary>
            <param name="workflowId">The workflow ID.</param>
            <param name="runId">Optionally specifies the workflow run ID.</param>
            <param name="domain">
            Optionally specifies the domain where the target workflow is running.
            This will be required when default domain for the client isn't specified
            or when the the target execution is running in a different domain.
            </param>
            <returns>The <see cref="T:Neon.Cadence.WorkflowStub"/>.</returns>
            <remarks>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/>.
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.NewUntypedWorkflowStub(Neon.Cadence.WorkflowExecution,System.String)">
            <summary>
            Creates an untyped stub for a known workflow execution.
            </summary>
            <param name="execution">The workflow execution.</param>
            <param name="domain">
            Optionally specifies the domain where the target workflow is running.
            This will be required when default domain for the client isn't specified
            or when the the target execution is running in a different domain.
            </param>
            <returns>The <see cref="T:Neon.Cadence.WorkflowStub"/>.</returns>
            <remarks>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/>.
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.NewWorkflowFutureStub``1(System.String,Neon.Cadence.WorkflowOptions)">
            <summary>
            Creates a stub suitable for starting an external workflow and then waiting
            for the result as separate operations.
            </summary>
            <typeparam name="TWorkflowInterface">The target workflow interface.</typeparam>
            <param name="methodName">
            Optionally identifies the target workflow method.  This is the name specified in
            <c>[WorkflowMethod]</c> attribute for the workflow method or <c>null</c>/empty for
            the default workflow method.
            </param>
            <param name="options">Optionally specifies custom <see cref="T:Neon.Cadence.WorkflowOptions"/>.</param>
            <returns>A <see cref="T:Neon.Cadence.ChildWorkflowStub`1"/> instance.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.NewWorkflowStub``1(System.String,System.String,System.String)">
            <summary>
            Creates a typed workflow stub connected to a known workflow execution
            using IDs.  This can be used to signal and query the workflow via the 
            type-safe interface methods.
            </summary>
            <typeparam name="TWorkflowInterface">Identifies the workflow interface.</typeparam>
            <param name="workflowId">Specifies the workflow ID.</param>
            <param name="runId">Optionally specifies the workflow's run ID.</param>
            <param name="domain">
            Optionally specifies the domain where the target workflow is running.
            This will be required when default domain for the client isn't specified
            or when the the target execution is running in a different domain.
            </param>
            <returns>The dynamically generated stub that implements the workflow methods defined by <typeparamref name="TWorkflowInterface"/>.</returns>
            <remarks>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/>.
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.NewWorkflowStub``1(Neon.Cadence.WorkflowExecution,System.String)">
            <summary>
            Creates a typed workflow stub connected to a known workflow execution
            using a <see cref="T:Neon.Cadence.WorkflowExecution"/>.  This can be used to signal and
            query the workflow via the type-safe interface methods.
            </summary>
            <typeparam name="TWorkflowInterface">Identifies the workflow interface.</typeparam>
            <param name="execution">Specifies the <see cref="T:Neon.Cadence.WorkflowExecution"/>.</param>
            <param name="domain">
            Optionally specifies the domain where the target workflow is running.
            This will be required when default domain for the client isn't specified
            or when the the target execution is running in a different domain.
            </param>
            <returns>The dynamically generated stub that implements the workflow methods defined by <typeparamref name="TWorkflowInterface"/>.</returns>
            <remarks>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/>.
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.NewWorkflowStub(System.String,Neon.Cadence.WorkflowOptions)">
            <summary>
            Creates an untyped workflow stub to be used for launching a workflow.
            </summary>
            <param name="workflowTypeName">Specifies the workflow type name.</param>
            <param name="options">Optionally specifies the workflow options.</param>
            <returns>The new <see cref="T:Neon.Cadence.WorkflowStub"/>.</returns>
            <remarks>
            <para>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/>.
            </para>
            <note>
            <para>
            .NET and Java workflows can implement multiple workflow methods using attributes
            and annotations to assign unique names to each.  Each workflow method is actually
            registered with Cadence as a distinct workflow type.  Workflow methods with a blank
            or <c>null</c> name will simply be registered using the workflow type name.
            </para>
            <para>
            Workflow methods with a name will be registered using a combination of the workflow
            type name and the method name, using <b>"::"</b> as the separator, like:
            </para>
            <code>
            WORKFLOW-TYPENAME::METHOD-NAME
            </code>
            <para>
            GOLANG doesn't support the concept of workflow methods.  GOLANG workflows 
            are just given a simple name which you'll pass here as <paramref name="workflowTypeName"/>
            to make cross platform calls.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.NewWorkflowStub``1(Neon.Cadence.WorkflowOptions,System.String)">
            <summary>
            Creates a typed workflow stub that can be used to start as well as 
            query and signal the workflow via the type-safe interface methods.
            </summary>
            <typeparam name="TWorkflowInterface">Identifies the workflow interface.</typeparam>
            <param name="options">Optionally specifies the workflow options.</param>
            <param name="workflowTypeName">
            Optionally specifies the workflow type name by overriding the fully 
            qualified <typeparamref name="TWorkflowInterface"/> type name or the name
            specified by a <see cref="T:Neon.Cadence.WorkflowAttribute"/>.
            </param>
            <returns>The dynamically generated stub that implements the workflow methods defined by <typeparamref name="TWorkflowInterface"/>.</returns>
            <remarks>
            <para>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/>.
            </para>
            <note>
            <para>
            .NET and Java workflows can implement multiple workflow methods using attributes
            and annotations to assign unique names to each.  Each workflow method is actually
            registered with Cadence as a distinct workflow type.  Workflow methods with a blank
            or <c>null</c> name will simply be registered using the workflow type name.
            </para>
            <para>
            Workflow methods with a name will be registered using a combination of the workflow
            type name and the method name, using <b>"::"</b> as the separator, like:
            </para>
            <code>
            WORKFLOW-TYPENAME::METHOD-NAME
            </code>
            <para>
            GOLANG doesn't support the concept of workflow methods.  GOLANG workflows 
            are just given a simple name which you'll pass here as <paramref name="workflowTypeName"/>
            to make cross platform calls.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.DescribeWorkflowExecutionAsync(System.String,System.String,System.String)">
            <summary>
            Describes a workflow execution by explicit IDs.
            </summary>
            <param name="workflowId">The workflow ID.</param>
            <param name="runid">Optionally specifies the run ID.</param>
            <param name="domain">Optionally specifies the domain.</param>
            <returns>The <see cref="T:Neon.Cadence.WorkflowDescription"/></returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the workflow does not exist.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.WaitForWorkflowStartAsync(Neon.Cadence.WorkflowExecution,System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Waits for a resonable period of time for Cadence to start a workflow.
            </summary>
            <param name="execution">Identifies the target workflow.</param>
            <param name="domain">Optional domain.</param>
            <param name="maxWait">
            Optionally overrides <see cref="P:Neon.Cadence.CadenceSettings.MaxWorkflowWaitUntilRunningSeconds"/> to
            specify a custom maximum wait time.  The default setting is <b>30 seconds</b>.
            </param>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the target workflow does not exist.</exception>
            <exception cref="T:Neon.Cadence.SyncSignalException">Thrown if the workflow is closed or the signal could not be executed for another reason.</exception>
            <exception cref="T:Neon.Cadence.CadenceTimeoutException">Thrown when the workflow did not start running within a reasonable period of time.</exception>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            This method can be handy when writing non-emulated unit tests.
            </remarks>
        </member>
        <member name="E:Neon.Cadence.CadenceClient.WorkflowExecuteEvent">
            <summary>
            Raised when an external workflow is executed.  This is used internally
            for unit tests that verify that workflow options are configured correctly. 
            </summary>
        </member>
        <member name="E:Neon.Cadence.CadenceClient.ChildWorkflowExecuteEvent">
            <summary>
            Raised when a child workflow is executed.  This is used internally
            for unit tests that verify that workflow options are configured correctly. 
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.RaiseWorkflowExecuteEvent(Neon.Cadence.WorkflowOptions)">
            <summary>
            Raises the <see cref="E:Neon.Cadence.CadenceClient.WorkflowExecuteEvent"/>.
            </summary>
            <param name="options">The workflow options.</param>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.RaiseChildWorkflowExecuteEvent(Neon.Cadence.ChildWorkflowOptions)">
            <summary>
            Raises the <see cref="E:Neon.Cadence.CadenceClient.ChildWorkflowExecuteEvent"/>.
            </summary>
            <param name="options">The workflow options.</param>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.StartWorkflowAsync(System.String,System.Byte[],Neon.Cadence.WorkflowOptions)">
            <summary>
            Starts an external workflow using a specific workflow type name, returning a <see cref="T:Neon.Cadence.WorkflowExecution"/>
            that can be used to track the workflow and also wait for its result via <see cref="M:Neon.Cadence.CadenceClient.GetWorkflowResultAsync(Neon.Cadence.WorkflowExecution,System.String)"/>.
            </summary>
            <param name="workflowTypeName">
            The type name used when registering the workers that will handle this workflow.
            This name will often be the fully qualified name of the workflow type but 
            this may have been customized when the workflow worker was registered.
            </param>
            <param name="args">Specifies the workflow arguments encoded into a byte array.</param>
            <param name="options">Specifies the workflow options.</param>
            <returns>A <see cref="T:Neon.Cadence.WorkflowExecution"/> identifying the new running workflow instance.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if there is no workflow registered for <paramref name="workflowTypeName"/>.</exception>
            <exception cref="T:Neon.Cadence.BadRequestException">Thrown if the request is not valid.</exception>
            <exception cref="T:Neon.Cadence.WorkflowRunningException">Thrown if a workflow with this ID is already running.</exception>
            <remarks>
            This method kicks off a new workflow instance and returns after Cadence has
            queued the operation but the method <b>does not</b> wait for the workflow to
            complete.
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.GetWorkflowResultAsync(Neon.Cadence.WorkflowExecution,System.String)">
            <summary>
            Returns the result from a workflow execution, blocking until the workflow
            completes if it is still running.
            </summary>
            <param name="execution">Identifies the workflow execution.</param>
            <param name="domain">Optionally specifies the domain.  This defaults to the client domain.</param>
            <returns>The workflow result encoded as bytes or <c>null</c>.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the workflow no longer exists.</exception>
            <exception cref="T:Neon.Cadence.BadRequestException">Thrown if the request is invalid.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence problems.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.StartChildWorkflowAsync(Neon.Cadence.Workflow,System.String,System.Byte[],Neon.Cadence.ChildWorkflowOptions)">
            <summary>
            Starts a child workflow.
            </summary>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowTypeName">
            The type name used when registering the workers that will handle this workflow.
            This name will often be the fully qualified name of the workflow type but 
            this may have been customized when the workflow worker was registered.
            </param>
            <param name="args">Specifies the workflow arguments encoded into a byte array.</param>
            <param name="options">Specifies the workflow options.</param>
            <returns>A <see cref="T:Neon.Cadence.Internal.ChildExecution"/> identifying the new running workflow instance.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if there is no workflow registered for <paramref name="workflowTypeName"/>.</exception>
            <exception cref="T:Neon.Cadence.BadRequestException">Thrown if the request is not valid.</exception>
            <exception cref="T:Neon.Cadence.WorkflowRunningException">Thrown if a workflow with this ID is already running.</exception>
            <remarks>
            This method kicks off a new child workflow instance and returns after Cadence has
            queued the operation but the method <b>does not</b> wait for the workflow to
            complete.
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.GetChildWorkflowResultAsync(Neon.Cadence.Workflow,Neon.Cadence.Internal.ChildExecution)">
            <summary>
            Returns the result from a child workflow execution, blocking until the workflow
            completes if it is still running.
            </summary>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="childExecution">Identifies the child workflow execution.</param>
            <returns>The workflow result encoded as bytes or <c>null</c>.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the workflow no longer exists.</exception>
            <exception cref="T:Neon.Cadence.BadRequestException">Thrown if the request is invalid.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence problems.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.DescribeWorkflowExecutionAsync(Neon.Cadence.WorkflowExecution,System.String)">
            <summary>
            Returns the current state of a running workflow.
            </summary>
            <param name="execution">Identifies the workflow execution.</param>
            <param name="domain">Optionally specifies the domain.  This defaults to the client domain.</param>
            <returns>A <see cref="T:Neon.Cadence.WorkflowDescription"/>.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the workflow no longer exists.</exception>
            <exception cref="T:Neon.Cadence.BadRequestException">Thrown if the request is invalid.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence problems.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.CancelWorkflowAsync(Neon.Cadence.WorkflowExecution,System.String)">
            <summary>
            Cancels a workflow if it has not already finished.
            </summary>
            <param name="execution">Identifies the running workflow.</param>
            <param name="domain">Optionally identifies the domain.  This defaults to the client domain.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the workflow no longer exists.</exception>
            <exception cref="T:Neon.Cadence.BadRequestException">Thrown if the request is invalid.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence problems.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.TerminateWorkflowAsync(Neon.Cadence.WorkflowExecution,System.String,System.Byte[],System.String)">
            <summary>
            Terminates a workflow if it has not already finished.
            </summary>
            <param name="execution">Identifies the running workflow.</param>
            <param name="reason">Optionally specifies an error reason string.</param>
            <param name="details">Optionally specifies additional details as a byte array.</param>
            <param name="domain">Optionally specifies the domain.  This defaults to the client domain.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the workflow no longer exists.</exception>
            <exception cref="T:Neon.Cadence.BadRequestException">Thrown if the request is invalid.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence problems.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.SignalWorkflowAsync(Neon.Cadence.WorkflowExecution,System.String,System.Byte[],System.String)">
            <summary>
            Transmits a signal to a running external workflow.  This low-level method accepts a byte array
            with the already encoded parameters.
            </summary>
            <param name="execution">The <see cref="T:Neon.Cadence.WorkflowExecution"/>.</param>
            <param name="signalName">Identifies the signal.</param>
            <param name="signalArgs">Optionally specifies the signal arguments as a byte array.</param>
            <param name="domain">Optionally specifies the domain.  This defaults to the client domain.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the workflow no longer exists.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence problems.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.SignalWorkflowWithStartAsync(System.String,System.String,System.Byte[],System.Byte[],Neon.Cadence.WorkflowOptions)">
            <summary>
            Transmits a signal to an external workflow, starting the workflow if it's not currently running.
            This low-level method accepts a byte array with the already encoded parameters.
            </summary>
            <param name="workflowTypeName">The target workflow type name.</param>
            <param name="signalName">Identifies the signal.</param>
            <param name="signalArgs">Optionally specifies the signal arguments as a byte array.</param>
            <param name="startArgs">Optionally specifies the workflow arguments.</param>
            <param name="options">Optionally specifies the options to be used for starting the workflow when required.</param>
            <returns>The <see cref="T:Neon.Cadence.WorkflowExecution"/>.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the domain does not exist.</exception>
            <exception cref="T:Neon.Cadence.BadRequestException">Thrown if the request is invalid.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence problems.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.QueryWorkflowAsync(Neon.Cadence.WorkflowExecution,System.String,System.Byte[],System.String)">
            <summary>
            Queries an external workflow.  This low-level method accepts a byte array
            with the already encoded parameters and returns an encoded result.
            </summary>
            <param name="execution">The <see cref="T:Neon.Cadence.WorkflowExecution"/>.</param>
            <param name="queryType">Identifies the query.</param>
            <param name="queryArgs">Optionally specifies the query arguments encoded as a byte array.</param>
            <param name="domain">Optionally specifies the domain.  This defaults to the client domain.</param>
            <returns>The query result encoded as a byte array.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the workflow no longer exists.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence problems.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.SignalChildWorkflowAsync(Neon.Cadence.Workflow,Neon.Cadence.Internal.ChildExecution,System.String,System.Byte[])">
            <summary>
            <para>
            Signals a child workflow.  This low-level method accepts a byte array
            with the already encoded parameters.
            </para>
            <note>
            This method blocks until the child workflow is scheduled and
            actually started on a worker.
            </note>
            </summary>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="childExecution">The child workflow execution.</param>
            <param name="signalName">Specifies the signal name.</param>
            <param name="signalArgs">Specifies the signal arguments as an encoded byte array.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the named domain does not exist.</exception>
            <exception cref="T:Neon.Cadence.BadRequestException">Thrown when the request is invalid.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence cluster problems.</exception>
            <exception cref="T:Neon.Cadence.ServiceBusyException">Thrown when Cadence is too busy.</exception>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.SyncSignalWorkflowAsync(Neon.Cadence.WorkflowExecution,System.String,System.String,System.Byte[],System.String)">
            <summary>
            Transmits a signal to a running external workflow and then polls the completion by querying the workflow
            to wait for the signal to be received and processed by the workflow.  This overload does 
            not return a result.  This low-level method accepts a byte array with the already encoded 
            parameters.
            </summary>
            <param name="execution">The <see cref="T:Neon.Cadence.WorkflowExecution"/>.</param>
            <param name="signalName">The target signal name.</param>
            <param name="signalId">The globally unique signal transaction ID.</param>
            <param name="signalArgs">Specifies the <see cref="T:Neon.Cadence.Internal.SyncSignalCall"/> as a single item array and encoded as a byte array.</param>
            <param name="domain">Optionally specifies the domain.</param>
            <returns>The encoded signal results or <c>null</c> for signals that don't return a result.</returns>
            <exception cref="T:Neon.Cadence.SyncSignalException">Thrown if the target synchronous signal doesn't exist or the workflow is already closed.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence problems.</exception>
            <exception cref="T:Neon.Cadence.CadenceTimeoutException">Thrown if the operation timed out while waiting for a reply.</exception>
            <remarks>
            <para>
            <paramref name="signalArgs"/> must include an internal <see cref="T:Neon.Cadence.Internal.SyncSignalCall"/> encoded as 
            the only argument.  This first includes the information required by the worker to route to the 
            user's signal, the globally unique transaction ID that the worker will use to track the signal
            execution state and the client will use to poll for that state.  This also includes the encoded
            user arguments being passed to the signal.
            </para>
            <note>
            The value passed as <paramref name="signalId"/> must match that in <see cref="T:Neon.Cadence.Internal.SyncSignalStatus"/>
            encoded as the encoded in <paramref name="signalArgs"/>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.CadenceClient.SyncSignalChildWorkflowAsync(Neon.Cadence.Workflow,Neon.Cadence.Internal.ChildExecution,System.String,System.String,System.Byte[])">
            <summary>
            Transmits a signal to a child workflow and then polls for the completion by querying the workflow
            to wait for the signal to be received and processed by the workflow.  This overload does 
            not return a result.  This low-level method accepts a byte array with the already encoded 
            parameters.
            </summary>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="childExecution">The child workflow execution.</param>
            <param name="signalName">The target signal name.</param>
            <param name="signalId">The globally unique signal transaction ID.</param>
            <param name="signalArgs">Specifies the <see cref="T:Neon.Cadence.Internal.SyncSignalCall"/> as a single item array and encoded as a byte array.</param>
            <returns>The encoded signal results or <c>null</c> for signals that don't return a result.</returns>
            <exception cref="T:Neon.Cadence.SyncSignalException">Thrown if the target synchronous signal doesn't exist or the workflow is already closed.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence problems.</exception>
            <exception cref="T:Neon.Cadence.CadenceTimeoutException">Thrown if the operation timed out while waiting for a reply.</exception>
            <remarks>
            <para>
            <paramref name="signalArgs"/> must include an internal <see cref="T:Neon.Cadence.Internal.SyncSignalCall"/> encoded as 
            the only argument.  This first includes the information required by the worker to route to the 
            user's signal, the globally unique transaction ID that the worker will use to track the signal
            execution state and the client will use to poll for that state.  This also includes the encoded
            user arguments being passed to the signal.
            </para>
            <note>
            The value passed as <paramref name="signalId"/> must match that in <see cref="T:Neon.Cadence.Internal.SyncSignalStatus"/>
            encoded as the encoded in <paramref name="signalArgs"/>.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.CadenceClosedDelegate">
            <summary>
            Delegate called by a <see cref="T:Neon.Cadence.CadenceClient"/> when the connection is closed
            explicitly or where there's a problem communicating with the <b>cadence-proxy</b>.
            </summary>
            <param name="sender">The event sender.</param>
            <param name="args">The event arguments.</param>
        </member>
        <member name="T:Neon.Cadence.CadenceClientClosedArgs">
            <summary>
            The event arguments sent when a <see cref="T:Neon.Cadence.CadenceClient"/> is closed
            with a property indicating whether or not the connection was closed due
            to an error.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceClientClosedArgs.Exception">
            <summary>
            This will be set if the connection was closed due to an error
            or <c>null</c> when the connection was closed normally.
            </summary>
        </member>
        <member name="T:Neon.Cadence.CadenceExtensions">
            <summary>
            Implements handy extension methods.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceExtensions.SendRequestAsync``1(System.Net.Http.HttpClient,``0)">
            <summary>
            Extends <see cref="T:System.Net.Http.HttpClient"/> by adding a method that can serialize and
            transmit a <b>cadence-proxy</b> proxy request message.
            </summary>
            <typeparam name="TRequest">The request message type.</typeparam>
            <param name="client">The HTTP client.</param>
            <param name="request">The message to be sent.</param>
            <returns>The <see cref="T:System.Net.Http.HttpResponseMessage"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.CadenceExtensions.SendReplyAsync``2(System.Net.Http.HttpClient,``0,``1)">
            <summary>
            <para>
            Extends <see cref="T:System.Net.Http.HttpClient"/> by adding a method that can serialize and
            transmit a <b>cadence-proxy</b> reply to a proxy request message.
            </para>
            <note>
            This method ensures that the reply message's <see cref="P:Neon.Cadence.Internal.ProxyReply.RequestId"/>
            matches the request's <see cref="P:Neon.Cadence.Internal.ProxyRequest.RequestId"/> before sending the
            reply.
            </note>
            </summary>
            <typeparam name="TRequest">The request message type.</typeparam>
            <typeparam name="TReply">The reply message type.</typeparam>
            <param name="client">The HTTP client.</param>
            <param name="request">The request being responsed to.</param>
            <param name="reply">The reply message.</param>
            <returns>The <see cref="T:System.Net.Http.HttpResponseMessage"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.Internal.CadenceHelper">
            <summary>
            Cadence helper methods and constants.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.CadenceHelper.WorkflowTypeMethodSeparator">
            <summary>
            The optional separator string used to separate the base workflow type
            name from the optional workflow method name.  This string may not be
            embedded in a normal workflow type name.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.CadenceHelper.ActivityTypeMethodSeparator">
            <summary>
            The optional separator string used to separate the base activity type
            name from the optional activity method name.  This string may not be
            embedded in a normal activity type name.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.CadenceHelper.NanosecondsPerSecond">
            <summary>
            Number of nanoseconds per second (spoiler alert: it's 1 billion).
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.CadenceHelper.MaxTimespan">
            <summary>
            Returns the maximum timespan supported by Cadence.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.CadenceHelper.MinTimespan">
            <summary>
            Returns the minimum timespan supported by Cadence.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.IsTask(System.Type)">
            <summary>
            Determines whether the type passed is a <see cref="T:System.Threading.Tasks.Task"/>.
            </summary>
            <param name="type">The type being tested.</param>
            <returns><c>true</c> if the type is a <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.IsTaskT(System.Type)">
            <summary>
            Determines whether the type passed is a <see cref="T:System.Threading.Tasks.Task`1"/>.
            </summary>
            <param name="type">The type being tested.</param>
            <returns><c>true</c> if the type is a <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.ValidateWorkflowTypeName(System.String)">
            <summary>
            Ensures that a workflow type name is valid.
            </summary>
            <param name="name">The workflow type name being checked.</param>
            <exception cref="T:Neon.Cadence.WorkflowTypeException">Thrown if the name passed is not valid.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.TypeNameToSource(System.String)">
            <summary>
            Converts a .NET type name into a form suitable for using in generated C# source code.
            This handles the replacement of any embedded <b>(+)</b> characters that indicate
            a nested type into <b>(.)</b> characters compatible with C#. 
            </summary>
            <param name="typeName">The type name.</param>
            <returns>The normalized type name.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.TypeNameToSource(System.Type)">
            <summary>
            Returns the fully qualified name of the type passed, converting it into a form 
            suitable for using in generated C# source code. This handles the replacement of 
            any embedded <b>(+)</b> characters that indicate a nested type into <b>(.)</b> 
            characters compatible with C#. 
            </summary>
            <param name="type">The type.</param>
            <returns>The normalized fully qualified type name.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.GetWorkflowTypeName(System.Type,Neon.Cadence.WorkflowAttribute)">
            <summary>
            Returns the Cadence workflow type name to be used for a workflow interface or
            implementation class.
            </summary>
            <param name="workflowType">The workflow interface or implementation type.</param>
            <param name="workflowAttribute">Specifies the <see cref="T:Neon.Cadence.WorkflowAttribute"/>.</param>
            <returns>The type name.</returns>
            <remarks>
            <para>
            If <paramref name="workflowAttribute"/> is passed and <see cref="P:Neon.Cadence.WorkflowAttribute.Name"/>
            is not <c>null</c> or empty, then the name specified in the attribute is returned.
            </para>
            <para>
            Otherwise, we'll return the fully qualified name of the workflow interface
            with the leading "I" removed.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.GetWorkflowTypeName``1(System.String)">
            <summary>
            Returns the workflow type name for a workflow interface and target method.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="methodName">
            Optionally specifies the target method name (as specified in the <c>[WorkflowMethod]</c>
            attribiute tagging the workflow method within the interface.
            </param>
            <returns>The workflow type name for the workflow interface and target method.</returns>
            <exception cref="T:System.ArgumentException">Thrown if target method does not exist.</exception>
            <remarks>
            <paramref name="methodName"/> is optional.  When this is passed as <c>null</c>
            or empty, the default workflow method will be targeted (if any).
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.GetActivityTypeName(System.Type,Neon.Cadence.ActivityAttribute)">
            <summary>
            Returns the Cadence activity type name to be used for an activity interface or
            implementation class.
            </summary>
            <param name="activityType">The activity interface or implementation type.</param>
            <param name="activityAttribute">Specifies the <see cref="T:Neon.Cadence.ActivityAttribute"/>.</param>
            <returns>The type name.</returns>
            <remarks>
            <para>
            If <paramref name="activityAttribute"/> is passed and <see cref="P:Neon.Cadence.ActivityAttribute.Name"/>
            is not <c>null</c> or empty, then the name specified in the attribute is returned.
            </para>
            <para>
            Otherwise, we'll return the fully qualified name of the activity interface
            with the leading "I" removed.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.GetActivityTypeName``1(System.String)">
            <summary>
            Returns the Cadence activity type name for an activity interface and target method.
            </summary>
            <typeparam name="TActivityInterface">The workflow interface.</typeparam>
            <param name="methodName">
            Optionally specifies the target method name (as specified in the <c>[WorkflowMethod]</c>
            attribiute tagging the workflow method within the interface.
            </param>
            <returns>The workflow type name for the workflow interface and target method.</returns>
            <exception cref="T:System.ArgumentException">Thrown if target method does not exist.</exception>
            <remarks>
            <paramref name="methodName"/> is optional.  When this is passed as <c>null</c>
            or empty, the default workflow method will be targeted (if any).
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.ValidateWorkflowInterface(System.Type)">
            <summary>
            Ensures that the type passed is a valid workflow interface.
            </summary>
            <param name="workflowInterface">The type being tested.</param>
            <exception cref="T:Neon.Cadence.ActivityTypeException">Thrown when the interface is not valid.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.ValidateWorkflowImplementation(System.Type)">
            <summary>
            Ensures that the type passed is a valid workflow implementation.
            </summary>
            <param name="workflowType">The type being tested.</param>
            <exception cref="T:Neon.Cadence.WorkflowTypeException">Thrown when the interface is not valid.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.GetWorkflowInterface(System.Type)">
            <summary>
            Returns the workflow interface for a workflow implementation class.
            </summary>
            <param name="workflowType">The workflow implementation class.</param>
            <returns>The workflow interface type.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.ValidateActivityTypeName(System.String)">
            <summary>
            Ensures that an activity type name is valid.
            </summary>
            <param name="name">The activity type name being checked.</param>
            <exception cref="T:Neon.Cadence.ActivityTypeException">Thrown if the name passed is not valid.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.ValidateActivityInterface(System.Type)">
            <summary>
            Ensures that the type passed is a valid activity interface.
            </summary>
            <param name="activityInterface">The type being tested.</param>
            <exception cref="T:Neon.Cadence.ActivityTypeException">Thrown when the interface is not valid.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.ValidateActivityImplementation(System.Type)">
            <summary>
            Ensures that the type passed is a valid activity implementation.
            </summary>
            <param name="activityType">The type being tested.</param>
            <exception cref="T:Neon.Cadence.ActivityTypeException">Thrown when the interface is not valid.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.GetActivityInterface(System.Type)">
            <summary>
            Returns the activity interface for an activity implementation class.
            </summary>
            <param name="activityType">The activity implementation class.</param>
            <returns>The activity interface type.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.GetWorkflowMethod(System.Type,System.String)">
            <summary>
            Searches a workflow interface for a method with a <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/> 
            with a matching name.
            </summary>
            <param name="workflowInterface">The workflow interface.</param>
            <param name="methodName">The method name to be matched.</param>
            <returns>The method information or <c>null</c> when there's no matching method.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.GetActivityMethod(System.Type,System.String)">
            <summary>
            Searches an activity interface for a method with a <see cref="T:Neon.Cadence.ActivityMethodAttribute"/> 
            with a matching name.
            </summary>
            <param name="activityInterface">The activity interface.</param>
            <param name="methodName">The method name to be matched.</param>
            <returns>The method information or <c>null</c> when there's no matching method.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.Normalize(System.TimeSpan)">
            <summary>
            Ensures that the timespan passed doesn't exceed the minimum or maximum
            supported by Cadence/GOLANG.
            </summary>
            <param name="timespan">The input.</param>
            <returns>The adjusted output.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.ToCadence(System.TimeSpan)">
            <summary>
            Converts a .NET <see cref="T:System.TimeSpan"/> into a Cadence/GOLANG duration
            (aka a <c>long</c> specifying the interval in nanoseconds.
            </summary>
            <param name="timespan">The input .NET timespan.</param>
            <returns>The duration in nanoseconds.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.ParseCadenceTimestamp(System.String)">
            <summary>
            Parses a Cadence timestamp string and converts it to a UTC
            <see cref="T:System.DateTime"/>.
            </summary>
            <param name="timestamp">The timestamp string.</param>
            <returns>The parsed <see cref="T:System.DateTime"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.UnixNanoToDateTimeUtc(System.Int64)">
            <summary>
            Converts UNIX nano time (UTC) to a <see cref="T:System.DateTime"/>.
            </summary>
            <param name="nanoseconds">Nano seconds from midnight 1-1-1970 (UTC)</param>
            <returns>The corresponding <see cref="T:System.DateTime"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.GetTypeName(System.Type)">
            <summary>
            Returns the name we'll use for a type when generating type references.
            </summary>
            <param name="type">The type.</param>
            <returns>The type name.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.TypeToCSharp(System.Type)">
            <summary>
            Resolves the type passed into a nice string taking generic types 
            and arrays into account.  This is used when generating workflow
            and activity stubs.
            </summary>
            <param name="type">The referenced type.</param>
            <returns>The type reference as a string or <c>null</c> if the type is not valid.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.LoadAssembly(System.IO.Stream)">
            <summary>
            Loads the assembly from a stream into current <see cref="T:System.Runtime.Loader.AssemblyLoadContext"/> or
            <see cref="T:System.AppDomain"/>, depending on whether we're running on .NET Core or
            .NET Frtamework.
            </summary>
            <param name="stream">The stream with the assembly bytes.</param>
            <returns>The loaded <see cref="T:System.Reflection.Assembly"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.LoadAssemblyNetCore(System.IO.Stream)">
            <summary>
            <b>.NET CORE ONLY:</b> Loads the assembly from a stream into the current <see cref="T:System.Runtime.Loader.AssemblyLoadContext"/>.
            </summary>
            <param name="stream">The stream with the assembly bytes.</param>
            <returns>The loaded <see cref="T:System.Reflection.Assembly"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.LoadAssemblyNetFramework(System.IO.Stream)">
            <summary>
            <b>.NET FRAMEWORK ONLY:</b> Loads the assembly from a stream into the current <see cref="T:System.AppDomain"/>.
            </summary>
            <param name="stream">The stream with the assembly bytes.</param>
            <returns>The loaded <see cref="T:System.Reflection.Assembly"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.ToCadenceLogLevel(Neon.Diagnostics.LogLevel)">
            <summary>
            Converts a Neon <see cref="T:Neon.Diagnostics.LogLevel"/> value into a <b>cadence-proxy</b> compatible
            log level string.
            </summary>
            <param name="logLevel">The input log level.</param>
            <returns>The <b>cadence-proxy</b> compatable level string.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.GetActivityTarget(System.Type,System.String)">
            <summary>
            Returns the activity type and method information for an activity interface and 
            an optional target method name.
            </summary>
            <param name="activityInterface">The target activity interface.</param>
            <param name="methodName">
            Optionally specifies the target method name (as specified in the <c>[ActivityMethod]</c>
            attribiute tagging the activity method within the interface.
            </param>
            <returns>The activity type name for the activity interface as well as the method information and attribute.</returns>
            <exception cref="T:System.ArgumentException">Thrown if target method does not exist.</exception>
            <remarks>
            <paramref name="methodName"/> is optional.  When this is passed as <c>null</c>
            or empty, the default activity method will be targeted (if any).
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.GetWorkflowTarget(System.Type,System.String)">
            <summary>
            Returns the workflow type and method information for a workflow interface and 
            an optional target method name.
            </summary>
            <param name="workflowInterface">The target workflow interface.</param>
            <param name="methodName">
            Optionally specifies the target method name (as specified in the <c>[WorkflowMethod]</c>
            attribiute tagging the workflow method within the interface.
            </param>
            <returns>The workflow type name for the workflow interface as well as the method information and attribute.</returns>
            <exception cref="T:System.ArgumentException">Thrown if target method does not exist.</exception>
            <remarks>
            <paramref name="methodName"/> is optional.  When this is passed as <c>null</c>
            or empty, the default workflow method will be targeted (if any).
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.ConvertArg(System.Type,System.Object)">
            <summary>
            <para>
            Used to convert an argument value being passed to a workflow or activity from
            its current type to the target parameter type.  For example, if an <c>int</c>
            argument is being passed to a <c>double</c> parameter, this method will convert
            the <c>int</c> to a <c>double</c> and return the <c>double</c>.
            </para>
            <para>
            This mimics the behavior of the C# complier which which will also perform these
            implicit conversions so the workflow developer won't have to do this explicitly
            (which would be really annoying).
            </para>
            </summary>
            <param name="parameterType">The parameter type we'll be casting <paramref name="arg"/> to.</param>
            <param name="arg">The argument value being passed.</param>
            <returns>The converted argument.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.DebugLog(System.String)">
            <summary>
            <b>INTERNAL USE ONLY:</b> Appends a line of text to the debug log which is
            used internally to debug generated code like stubs.  This hardcodes its
            output to <b>C:\Temp\cadence-debug.log</b> so this currently only works
            on Windows.
            </summary>
            <param name="text">The line of text to be written.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.ArgsToBytes(Neon.Cadence.IDataConverter,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            <b>INTERNAL USE ONLY:</b> Serializes an array of argument objects to bytes using
            Cadence argument serialization conventions and the specified <see cref="T:Neon.Cadence.IDataConverter"/>.
            </summary>
            <param name="converter">The data converter.</param>
            <param name="args">The arguments.</param>
            <returns>The serialized bytes or <c>null</c> when there are no arguments.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceHelper.BytesToArgs(Neon.Cadence.IDataConverter,System.Byte[],System.Type[])">
            <summary>
            <b>INTERNAL USE ONLY:</b> Deserializes encoded bytes (or <c>null</c>) into an array of 
            arguments using Cadence argument conventions and the specified <see cref="T:Neon.Cadence.IDataConverter"/>.
            </summary>
            <param name="converter">The data converter.</param>
            <param name="bytes">The serialized bytes or <c>null</c> when there are no arguments.</param>
            <param name="argTypes">The expected argument types.</param>
            <returns>The deserialized arguments as an array.</returns>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityCompleteReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.ActivityCompleteRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityCompleteReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityCompleteReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityCompleteReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityCompleteRequest">
            <summary>
            <b>client --> proxy:</b> Sent to complete an activity externally.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityCompleteRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityCompleteRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityCompleteRequest.TaskToken">
            <summary>
            The opaque activity task token.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityCompleteRequest.Domain">
            <summary>
            The target domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityCompleteRequest.WorkflowId">
            <summary>
            The target workflow ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityCompleteRequest.RunId">
            <summary>
            The target run ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityCompleteRequest.ActivityId">
            <summary>
            The target activity ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityCompleteRequest.Result">
            <summary>
            The activity result.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityCompleteRequest.Error">
            <summary>
            The activity error.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityCompleteRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityCompleteRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityExecuteLocalReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.ActivityExecuteLocalRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityExecuteLocalReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityExecuteLocalReply.Result">
            <summary>
            Returns the activity results encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityExecuteLocalReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityExecuteLocalReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityExecuteLocalRequest">
            <summary>
            <b>client --> proxy:</b> Starts a local workflow activity.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityExecuteLocalRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityExecuteLocalRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityExecuteLocalRequest.ActivityId">
            <summary>
            Used to identify the activity.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityExecuteLocalRequest.ActivityTypeId">
            <summary>
            Identifies the .NET type that implements the local activity. 
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityExecuteLocalRequest.Args">
            <summary>
            Optionally specifies the arguments to be passed to the activity encoded
            as a byte array.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityExecuteLocalRequest.Options">
            <summary>
            The local activity start options.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityExecuteLocalRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityExecuteLocalRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityExecuteReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.ActivityExecuteRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityExecuteReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityExecuteReply.Result">
            <summary>
            Returns the activity results encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityExecuteReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityExecuteReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityExecuteRequest">
            <summary>
            <b>client --> proxy:</b> Starts a (non-local) workflow activity.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityExecuteRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityExecuteRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityExecuteRequest.Activity">
            <summary>
            Specifies the activity to execute
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityExecuteRequest.Args">
            <summary>
            Optionally specifies the arguments to be passed to the activity encoded
            as a byte array.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityExecuteRequest.Options">
            <summary>
            The activity start options.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityExecuteRequest.Domain">
            <summary>
            Optionally overrides the parent workflow's domain.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityExecuteRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityExecuteRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityGetHeartbeatDetailsReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.ActivityGetHeartbeatDetailsRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetHeartbeatDetailsReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityGetHeartbeatDetailsReply.Details">
            <summary>
            Returns the activity heartbeat details encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetHeartbeatDetailsReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetHeartbeatDetailsReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityGetHeartbeatDetailsRequest">
            <summary>
            <b>client --> proxy:</b> Requests the details for the last heartbeat 
            recorded for a failed previous run of the activity.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetHeartbeatDetailsRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityGetHeartbeatDetailsRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetHeartbeatDetailsRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetHeartbeatDetailsRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityGetInfoReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.ActivityGetInfoRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetInfoReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityGetInfoReply.Info">
            <summary>
            Returns the activity information.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetInfoReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetInfoReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityGetInfoRequest">
            <summary>
            <b>client --> proxy:</b> Requests the details for the last heartbeat 
            recorded for a failed previous run of the activity.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetInfoRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityGetInfoRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetInfoRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetInfoRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityGetLocalResultReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.ActivityGetLocalResultRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetLocalResultReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityGetLocalResultReply.Result">
            <summary>
            Returns the activity result encoded as bytes.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetLocalResultReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetLocalResultReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityGetLocalResultRequest">
            <summary>
            <b>client --> proxy:</b> Requests the results from a <see cref="T:Neon.Cadence.Internal.ActivityStartLocalRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetLocalResultRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityGetLocalResultRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityGetLocalResultRequest.ActivityId">
            <summary>
            Identifies the target activity.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetLocalResultRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetLocalResultRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityGetResultReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.ActivityGetResultRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetResultReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityGetResultReply.Result">
            <summary>
            Returns the activity result encoded as bytes.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetResultReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetResultReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityGetResultRequest">
            <summary>
            <b>client --> proxy:</b> Requests the results from a <see cref="T:Neon.Cadence.Internal.ActivityStartRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetResultRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityGetResultRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityGetResultRequest.ActivityId">
            <summary>
            Identifies the target activity.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetResultRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityGetResultRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityHasHeartbeatDetailsReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.ActivityHasHeartbeatDetailsRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityHasHeartbeatDetailsReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityHasHeartbeatDetailsReply.HasDetails">
            <summary>
            Indicates whether heartbeat details are available.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityHasHeartbeatDetailsReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityHasHeartbeatDetailsReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityHasHeartbeatDetailsRequest">
            <summary>
            <b>client --> proxy:</b> Determines whether a previous failed run on an
            activity recorded heartbeat details.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityHasHeartbeatDetailsRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityHasHeartbeatDetailsRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityHasHeartbeatDetailsRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityHasHeartbeatDetailsRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityInvokeLocalReply">
            <summary>
            <b>client --> proxy:</b> Answers a <see cref="T:Neon.Cadence.Internal.ActivityInvokeLocalRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityInvokeLocalReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityInvokeLocalReply.Result">
            <summary>
            Returns the activity results encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityInvokeLocalReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityInvokeLocalReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityInvokeLocalRequest">
            <summary>
            <b>proxy --> client:</b> Sent to a worker, instructing it to begin executing
            a local workflow activity.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityInvokeLocalRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityInvokeLocalRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityInvokeLocalRequest.ActivityContextId">
            <summary>
            Identifies the activity context.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityInvokeLocalRequest.ActivityTypeId">
            <summary>
            Identifies the .NET type that implements the local activity. 
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityInvokeLocalRequest.Args">
            <summary>
            Optionally specifies the activity arguments encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityInvokeLocalRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityInvokeLocalRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityInvokeReply">
            <summary>
            <b>client --> proxy:</b> Answers a <see cref="T:Neon.Cadence.Internal.ActivityInvokeRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityInvokeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityInvokeReply.Result">
            <summary>
            Returns the activity results encoded as a byte array.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityInvokeReply.Pending">
            <summary>
            Indicates that the activity will be completed externally.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityInvokeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityInvokeReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Sent to a worker, instructing it to begin executing
            a workflow activity.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityInvokeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityInvokeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityInvokeRequest.Activity">
            <summary>
            Identifies the registered activity type.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityInvokeRequest.Args">
            <summary>
            Optionally specifies the activity arguments encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityInvokeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityInvokeRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityRecordHeartbeatReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRecordHeartbeatReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityRecordHeartbeatReply.Details">
            <summary>
            Returns the activity heartbeat details encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRecordHeartbeatReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRecordHeartbeatReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest">
            <summary>
            <b>client --> proxy:</b> Records an activity heartbeat.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.TaskToken">
            <summary>
            <para>
            Overrides the <see cref="P:Neon.Cadence.Internal.ActivityRequest.ContextId"/> message property when
            non-null, indicating that the activity heartbeat is being sent externally.
            </para>
            <note>
            Only one of <see cref="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.TaskToken"/> or <see cref="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.Domain"/> may be non-null
            within a given message.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.Domain">
            <summary>
            <para>
            Overrides the <see cref="P:Neon.Cadence.Internal.ActivityRequest.ContextId"/> message property when
            non-null, indicating that the activity heartbeat is being sent externally.
            </para>
            </summary>
            <note>
            Only one of <see cref="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.TaskToken"/> or <see cref="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.Domain"/> may be non-null
            within a given message.  The <see cref="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.WorkflowId"/> and <see cref="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.RunId"/>
            will be valid only when <see cref="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.Domain"/> is non-null.
            </note>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.WorkflowId">
            <summary>
            <para>
            The target workflow ID.
            </para>
            <note>
            This is required when <see cref="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.Domain"/> is non-null.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.RunId">
            <summary>
            <para>
            The target run ID.
            </para>
            <note>
            This is optional when <see cref="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.Domain"/> is non-null.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.ActivityId">
            <summary>
            The target activity ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.Details">
            <summary>
            The activity heartbeat details encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRecordHeartbeatRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityRegisterReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowRegisterRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRegisterReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRegisterReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRegisterReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityRegisterRequest">
            <summary>
            <b>client --> proxy:</b> Registers a workflow handler by name.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRegisterRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityRegisterRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityRegisterRequest.Name">
            <summary>
            Identifies the workflow implementation.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityRegisterRequest.Domain">
            <summary>
            Identifies the target domain.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRegisterRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRegisterRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityReply">
            <summary>
            Base class for all activity replies.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityReply.ActivityContextId">
            <summary>
            Uniquely identifies the activity context associated with this reply.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityRequest">
            <summary>
            Base class for all activity requests.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityRequest.ContextId">
            <summary>
            Uniquely identifies the activity context associated with this request.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityStartLocalReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.ActivityStartLocalRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStartLocalReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStartLocalReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStartLocalReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityStartLocalRequest">
            <summary>
            <b>client --> proxy:</b> Starts a local activity but doesn't wait for it to complete.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStartLocalRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityStartLocalRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityStartLocalRequest.ActivityId">
            <summary>
            Used to identify the activity.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityStartLocalRequest.ActivityTypeId">
            <summary>
            Identifies the .NET type that implements the local activity. 
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityStartLocalRequest.Args">
            <summary>
            Optionally specifies the arguments to be passed to the activity encoded
            as a byte array.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityStartLocalRequest.Options">
            <summary>
            The local activity options.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStartLocalRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStartLocalRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityStartReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.ActivityStartRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStartReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStartReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStartReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityStartRequest">
            <summary>
            <b>client --> proxy:</b> Starts an activity but doesn't wait for it to complete.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStartRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityStartRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityStartRequest.Activity">
            <summary>
            Specifies the activity to execute.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityStartRequest.Args">
            <summary>
            Optionally specifies the arguments to be passed to the activity encoded
            as a byte array.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityStartRequest.Options">
            <summary>
            The activity options.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityStartRequest.Domain">
            <summary>
            Optionally overrides the parent workflow's domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityStartRequest.ActivityId">
            <summary>
            Used to identify the activity.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStartRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStartRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityStoppingReply">
            <summary>
            <b>client --> proxy:</b> Answers a <see cref="T:Neon.Cadence.Internal.ActivityStoppingRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStoppingReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStoppingReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStoppingReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ActivityStoppingRequest">
            <summary>
            <b>proxy --> client:</b> Indicates that a worker is being stopped.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStoppingRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityStoppingRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.ActivityStoppingRequest.ActivityId">
            <summary>
            Specifies the activity being stopped.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStoppingRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ActivityStoppingRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ProxyMessage">
            <summary>
            The base class for all messages transferred between the .NET Cadence client
            and the <b>cadence-proxy</b>.
            </summary>
            <remarks>
            <para>
            This class is designed to be a very simple and flexible way of communicating
            operations and status between the Cadence client and proxy.  The specific 
            message type is identified via the <see cref="P:Neon.Cadence.Internal.ProxyMessage.Type"/> property (one of the 
            <see cref="T:Neon.Cadence.Internal.InternalMessageTypes"/> values.  The <see cref="P:Neon.Cadence.Internal.ProxyMessage.Properties"/> dictionary will be
            used to pass named values.  Binary attachments may be passed using the 
            <see cref="P:Neon.Cadence.Internal.ProxyMessage.Attachments"/> property, a list of binary arrays.
            </para>
            <para>
            This is serialized to bytes using a simple structure consisting of 32-bit
            integers, UTF-8 encoded strings, and raw bytes with all integers encoded 
            using little-endian byte ordering.  Strings are encoded as a 32-bit 
            byte length, followed by that many UTF-8 encoded string bytes.  A ZERO
            byte length indicates an empty string and a length of -1 indicates a
            NULL string.  Encoded strings will look like:
            </para>
            <code>
            +------------------+
            |      LENGTH      |   32-bit (little endian)
            +------------------+
            |                  |
            |      UTF-8       |
            |      BYTES       |
            |                  |
            +------------------+
            </code>
            <para>
            A full encoded message will look like:
            </para>
            <code>
            +------------------+
            |   MESSAGE-TYPE   |   32-bit
            +------------------+
            |   PROPERTY-COUNT |   32-bit
            +------------------+
            |                  |
            |  +------------+  |
            |  |   NAME     |  |
            |  +------------+  |
            |  |   VALUE    |  |
            |  +------------+  |
            |       ...        |
            |                  |
            +------------------+
            |   ATTACH-COUNT   |   32-bit
            +------------------+
            |                  |
            |  +------------+  |
            |  |   LENGTH   |  |   32-bit
            |  +------------+  |
            |  |            |  |
            |  |            |  |
            |  |   BYTES    |  |
            |  |            |  |
            |  |            |  |
            |  +------------+  |
            |       ...        |
            |                  |
            +------------------+
            </code>
            <para>
            The message starts out with the 32-bit message type followed by the
            number of properties to follow.  Each argument consists of an encoded
            string for the argument name followed by an encoded string for the value.
            </para>
            <para>
            After the properties will be a 32-bit integer specifying the
            number of binary attachment with each encoded as its length in bytes
            followed by that actual attachment bytes.  An attachment with length
            set to -1 will be considered to be NULL.
            </para>
            <para>
            Proxy messages will be passed between the Cadence client and proxy
            via <b>PUT</b> requests using the <b>application/x-neon-cadence-proxy</b>
            content-type.  Note that request responses in both directions never
            include any content.
            </para>
            <para>
            Note that more complex message property may be passed as JSON strings
            that can be serialized and deserialized via the <see cref="M:Neon.Cadence.Internal.ProxyMessage.GetJsonProperty``1(Neon.Cadence.Internal.PropertyNameUtf8)"/>
            and <see cref="M:Neon.Cadence.Internal.ProxyMessage.SetJsonProperty``1(Neon.Cadence.Internal.PropertyNameUtf8,``0)"/> helper methods.
            </para>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.Internal.ProxyMessage.PropertyNameBytes">
            <summary>
            The return value of <see cref="M:Neon.Cadence.Internal.ProxyMessage.ReadPropertyNameBytes(System.IO.BinaryReader)"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.ProxyMessage.ContentType">
            <summary>
            The content type to used for HTTP requests encapsulating a <see cref="T:Neon.Cadence.Internal.ProxyMessage"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.Deserialize``1(System.IO.Stream,System.Boolean)">
            <summary>
            Deserializes the message from a stream.
            </summary>
            <typeparam name="TMessage">The expected message type.</typeparam>
            <param name="input">The input stream.</param>
            <param name="ignoreTypeCode">Optionally ignore unspecified message types (used for unit testing).</param>
            <returns>The decoded message.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.ReadString(System.IO.BinaryReader)">
            <summary>
            Deserialzes a string.
            </summary>
            <param name="reader">The input reader.</param>
            <returns>The string.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.ReadPropertyNameBytes(System.IO.BinaryReader)">
            <summary>
            Deserialzes a string as UTF-8 bytes allocated from a local pool.
            The value returned should be added back to the pool when you're
            donw with it.
            </summary>
            <param name="reader">The input reader.</param>
            <returns>The UTF-8 encoded string bytes.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.WriteString(System.IO.BinaryWriter,System.String)">
            <summary>
            Serialize a string.
            </summary>
            <param name="writer">The output writer.</param>
            <param name="value">The string being serialized.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.WriteString(System.IO.BinaryWriter,Neon.Cadence.Internal.PropertyNameUtf8)">
            <summary>
            Serialize a string from a <see cref="T:Neon.Cadence.Internal.PropertyNameUtf8"/>.
            </summary>
            <param name="writer">The output writer.</param>
            <param name="value">The string being serialized.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ProxyMessage.Type">
            <summary>
            Indicates the message type, one of the <see cref="T:Neon.Cadence.Internal.InternalMessageTypes"/> values.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ProxyMessage.Properties">
            <summary>
            Returns a case insensitive dictionary that maps argument names to value strings.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ProxyMessage.Attachments">
            <summary>
            Returns the list of binary attachments.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.SerializeAsStream(System.Boolean)">
            <summary>
            Serializes the message to a pooled <see cref="T:System.IO.MemoryStream"/>.  Be sure to
            add the stream returned back to the <see cref="T:Neon.Cadence.Internal.MemoryStreamPool"/> when you've 
            finished with it.
            </summary>
            <param name="ignoreTypeCode">Optionally ignore unspecified message types (used for unit testing).</param>
            <returns>A <see cref="T:System.IO.MemoryStream"/> holding the serialized message.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.SerializeAsBytes(System.Boolean)">
            <summary>
            <para>
            Serializes the message to bytes.
            </para>
            <note>
            This method is intended for testing purposes.  Use <see cref="M:Neon.Cadence.Internal.ProxyMessage.SerializeAsStream(System.Boolean)"/>
            for production since that method will perform better by not needing to allocate a
            byte array with the message contents for every call.
            </note>
            </summary>
            <param name="ignoreTypeCode">Optionally ignore unspecified message types (used for unit testing).</param>
            <returns>The serialized byte array.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.Clone">
            <summary>
            Implemented by derived classes to make a copy of themselves for echo testing
            purposes.  Note that this is not implemented for the base <see cref="T:Neon.Cadence.Internal.ProxyMessage"/>
            class.
            </summary>
            <returns>The cloned message.</returns>
            <exception cref="T:System.NotImplementedException">Thrown by this base class.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <summary>
            Implemented by derived classes to copy message properties to another
            message instance during a <see cref="M:Neon.Cadence.Internal.ProxyMessage.Clone"/> operation.
            </summary>
            <param name="target">The target message.</param>
            <remarks>
            <note>
            The method implementation can safely assume that the <paramref name="target"/>
            message can be cast into the implementation's message type.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.GetStringProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.String)">
            <summary>
            Helper method for retrieving a string property.
            </summary>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The string value.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.GetIntProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.Int32)">
            <summary>
            Helper method for retrieving a 32-bit integer property.
            </summary>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The integer value.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.GetLongProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.Int64)">
            <summary>
            Helper method for retrieving a 64-bit integer property.
            </summary>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The long value.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.GetBoolProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.Boolean)">
            <summary>
            Helper method for retrieving a boolean property.
            </summary>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The long value.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.GetEnumProperty``1(Neon.Cadence.Internal.PropertyNameUtf8,``0)">
            <summary>
            Helper method for retrieving an enumeration property.
            </summary>
            <typeparam name="TEnum">The enumeration type.</typeparam>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The long value.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.GetDoubleProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.Double)">
            <summary>
            Helper method for retrieving a double property.
            </summary>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The double value.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.GetDateTimeProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.DateTime)">
            <summary>
            Helper method for retrieving a date/time property.
            </summary>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The double value.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.GetTimeSpanProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.TimeSpan)">
            <summary>
            Helper method for retrieving a timespan property.
            </summary>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The double value.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.GetJsonProperty``1(Neon.Cadence.Internal.PropertyNameUtf8)">
            <summary>
            Helper method for retrieving a complex property serialized as a JSON string.
            </summary>
            <typeparam name="T">The property type.</typeparam>
            <param name="key">The property key.</param>
            <returns>The parsed value if the property exists or <c>null</c>.</returns>
            <remarks>
            <note>
            <para>
            <b>IMPORTANT:</b> Be very careful when referencing properties that use this
            method because the behavior will probably be unexepected.  You should:
            </para>
            <list type="bullet">
                <item>
                When you need to access multiple subfields of the property value,
                dereference the property once, save the value to a variable and
                then use the variable to access the subproperty.  Not doing this
                will result in the JSON being parsed again for each property
                reference.
                </item>
                <item>
                Dereferencing the property and changing a subproperty value won't
                actually persist the change back to the underlying property.  You'll
                need to dereference the property to a variable, change the subproperty,
                and then use <see cref="M:Neon.Cadence.Internal.ProxyMessage.SetJsonProperty``1(Neon.Cadence.Internal.PropertyNameUtf8,``0)"/> to persist the
                change. 
                </item>
            </list>
            <para>
            These restrictions are a bit odd but we're not actually expecting to 
            be doing any of these things within the <b>cadence-client</b> code.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.GetBytesProperty(Neon.Cadence.Internal.PropertyNameUtf8)">
            <summary>
            Helper method for retrieving a byte array property.
            </summary>
            <param name="key">The property key.</param>]
            <returns>The byte array or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.SetStringProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.String)">
            <summary>
            Helper method for setting a string property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.SetIntProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.Int32)">
            <summary>
            Helper method for setting a 32-bit integer property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.SetLongProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.Int64)">
            <summary>
            Helper method for setting a 64-bit integer property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.SetBoolProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.Boolean)">
            <summary>
            Helper method for setting a boolean property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.SetEnumProperty``1(Neon.Cadence.Internal.PropertyNameUtf8,``0)">
            <summary>
            Helper method for setting an enumeration property.
            </summary>
            <typeparam name="TEnum">The enumeration type.</typeparam>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.SetDoubleProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.Double)">
            <summary>
            Helper method for setting a double property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.SetDateTimeProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.DateTime)">
            <summary>
            Helper method for setting a date/time property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.SetTimeSpanProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.TimeSpan)">
            <summary>
            Helper method for setting a timespan property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.SetJsonProperty``1(Neon.Cadence.Internal.PropertyNameUtf8,``0)">
            <summary>
            Helper method for setting a complex property as JSON.
            </summary>
            <typeparam name="T">The property type.</typeparam>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyMessage.SetBytesProperty(Neon.Cadence.Internal.PropertyNameUtf8,System.Byte[])">
            <summary>
            Helper method for setting a byte array property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="P:Neon.Cadence.Internal.ProxyMessage.ClientId">
            <summary>
            Identifies the Cadence service client the request references.  This will
            be zero for the few messages that don't reference a client.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.ProxyReply">
            <summary>
            Base class for all proxy requests.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ProxyReply.RequestId">
            <summary>
            Uniquely identifies the request this reply answers.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ProxyReply.Error">
            <summary>
            Optionally indicates that the request failed.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyReply.ThrowOnError">
            <summary>
            Throws the related exception if the reply is reporting an error.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.ProxyRequest">
            <summary>
            Base class for all proxy requests.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ProxyRequest.RequestId">
            <summary>
            Uniquely identifies this request.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ProxyRequest.IsCancellable">
            <summary>
            Optionally indicates that the operation may be cancelled by the 
            workflow application.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ProxyRequest.ReplyType">
            <summary>
            Derived request types must return the type of the expected
            <see cref="T:Neon.Cadence.Internal.ProxyReply"/> message.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ProxyRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.CadenceError">
            <summary>
            <b>INTERNAL USE ONLY:</b> Describes a Cadence error.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceError.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceError.StringToErrorType(System.String)">
            <summary>
            Converts an error type string into an <see cref="T:Neon.Cadence.Internal.CadenceErrorType"/>.
            </summary>
            <param name="typeString">The error string to be converted.</param>
            <returns>The converted error type.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceError.ErrorTypeToString(Neon.Cadence.Internal.CadenceErrorType)">
            <summary>
            Converts an <see cref="T:Neon.Cadence.Internal.CadenceErrorType"/> into a error string.
            </summary>
            <param name="type">the error type.</param>
            <returns>The error string.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceError.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceError.#ctor(System.String,Neon.Cadence.Internal.CadenceErrorType)">
            <summary>
            Constructs an error from parameters.
            </summary>
            <param name="error">The GOLANG error string.</param>
            <param name="type">Optionally specifies the error type.  This defaults to <see cref="F:Neon.Cadence.Internal.CadenceErrorType.Custom"/>.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceError.#ctor(System.Exception)">
            <summary>
            Constructs an error from a .NET exception.
            </summary>
            <param name="e">The exception.</param>
        </member>
        <member name="P:Neon.Cadence.Internal.CadenceError.String">
            <summary>
            Specifies the GOLANG error string.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.CadenceError.Type">
            <summary>
            Optionally specifies the GOLANG error type.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceError.GetErrorType">
            <summary>
            Returns the error type.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceError.SetErrorType(Neon.Cadence.Internal.CadenceErrorType)">
            <summary>
            Sets the error type.
            </summary>
            <param name="type">The new type.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceError.ToException">
            <summary>
            Converts the instance into an <see cref="T:Neon.Cadence.CadenceException"/>.
            </summary>
            <returns>One of the exceptions derived from <see cref="T:Neon.Cadence.CadenceException"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.CadenceError.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.CadenceErrorType">
            <summary>
            <b>INTERNAL USE ONLY:</b> Enumerates the Cadence error types.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.CadenceErrorType.Cancelled">
            <summary>
            An operation was cancelled.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.CadenceErrorType.Custom">
            <summary>
            Custom error.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.CadenceErrorType.Generic">
            <summary>
            Generic error.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.CadenceErrorType.Panic">
            <summary>
            Panic error.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.CadenceErrorType.Terminated">
            <summary>
            Terminated error.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.CadenceErrorType.Timeout">
            <summary>
            Timeout error.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.ChildExecution">
            <summary>
            <b>INTERNAL USE ONLY:</b> Holds information about a child workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ChildExecution.#ctor(Neon.Cadence.WorkflowExecution,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="execution">The child workflow's execution information.</param>
            <param name="childId">
            The child workflow's local ID.  This is used to identify the 
            child when communicating with <b>cadence-proxy</b>.
            </param>
        </member>
        <member name="P:Neon.Cadence.Internal.ChildExecution.Execution">
            <summary>
            The child workflow's execution information.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ChildExecution.ChildId">
            <summary>
            The child workflow's local ID.  This is used to identify the 
            child when communicating with <b>cadence-proxy</b>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.CancelReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="T:Neon.Cadence.Internal.CancelRequest"/>
            indicating that the operation was canceled, has already completed or doesn't
            exist.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.CancelReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.CancelReply.WasCancelled">
            <summary>
            Set to <c>true</c> if the operation was actually cancelled or <c>false</c>
            if the operation had already completed, doesn't exist, or if cancellation
            is not appropriate for the operation and no action was performed.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.CancelReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.CancelReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.CancelRequest">
            <summary>
            <b>client --> proxy:</b> Sent periodically to confirm that the proxy is
            still healthy.  The proxy should send a <see cref="T:Neon.Cadence.Internal.CancelReply"/>
            optionally indicating that there's a problem by specifying an error.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.CancelRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.CancelRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.CancelRequest.TargetRequestId">
            <summary>
            The ID of the request being cancelled.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.CancelRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.CancelRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ConnectReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.ConnectRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ConnectReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ConnectReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ConnectReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.ConnectRequest">
            <summary>
            <b>client --> proxy:</b> Requests the proxy establish a connection with a Cadence cluster.
            This maps to a <c>NewClient()</c> in the proxy.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ConnectRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ConnectRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.ConnectRequest.Endpoints">
            <summary>
            <para>
            The Cadence server network endpoints separated by commas.
            These may include a DNS hostname or IP address with a
            network port, formatted like:
            </para>
            <code>
            my-server.nhive.io:5555,1.2.3.4:5555
            </code>
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ConnectRequest.Identity">
            <summary>
            Optionally identifies the client application.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ConnectRequest.ClientTimeout">
            <summary>
            The default client timeout.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ConnectRequest.Domain">
            <summary>
            The default Cadence domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ConnectRequest.CreateDomain">
            <summary>
            Indicates whether the Cadence domain should be created if it
            doesn't already exist.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ConnectRequest.Retries">
            <summary>
            Specifies the number of time the client will attempt to connect
            to the Cadence cluster.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.ConnectRequest.RetryDelay">
            <summary>
            Specifies the time to delay before retrying to connect to the cluster.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ConnectRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.ConnectRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DescribeTaskListReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.DescribeTaskListRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DescribeTaskListReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DescribeTaskListReply.Result">
            <summary>
            The task list details.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DescribeTaskListReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DescribeTaskListReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DescribeTaskListRequest">
            <summary>
            <b>client --> proxy:</b> Requests a list of the Cadence domains.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DescribeTaskListRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DescribeTaskListRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.DescribeTaskListRequest.Name">
            <summary>
            Identifies the task list.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DescribeTaskListRequest.Domain">
            <summary>
            Identifies the target domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DescribeTaskListRequest.TaskListType">
            <summary>
            Identifies the type of task list being requested: decision (AKA workflow) or activity.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DescribeTaskListRequest.TaskListKind">
            <summary>
            Identifies the kind of task list being requested: sticky or normal.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DescribeTaskListRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DescribeTaskListRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DisconnectReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.DisconnectRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DisconnectReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DisconnectReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DisconnectReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DisconnectRequest">
            <summary>
            <b>client --> proxy:</b> Requests that the proxy disconnect from a Cadence cluster.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DisconnectRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DisconnectRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DisconnectRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DisconnectRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DomainDeprecateReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.DomainDeprecateRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainDeprecateReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainDeprecateReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainDeprecateReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DomainDeprecateRequest">
            <summary>
            <b>client --> proxy:</b> Requests that the proxy register a Cadence domain.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainDeprecateRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainDeprecateRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainDeprecateRequest.Name">
            <summary>
            Name of the domain to be depreciated.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainDeprecateRequest.SecurityToken">
            <summary>
            Optional security token.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainDeprecateRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainDeprecateRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DomainDescribeReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.DomainDescribeRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainDescribeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainDescribeReply.DomainInfoName">
            <summary>
            The domain name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainDescribeReply.DomainInfoDescription">
            <summary>
            Human readable description for the domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainDescribeReply.DomainInfoStatus">
            <summary>
            The domain status.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainDescribeReply.DomainInfoOwnerEmail">
            <summary>
            Owner email address.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainDescribeReply.ConfigurationRetentionDays">
            <summary>
            The workflow history retention period in days.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainDescribeReply.ConfigurationEmitMetrics">
            <summary>
            Enables metric generation.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainDescribeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainDescribeReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DomainDescribeRequest">
            <summary>
            <b>client --> proxy:</b> Requests the details for a named domain.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainDescribeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainDescribeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainDescribeRequest.Name">
            <summary>
            <para>
            The target Cadence domain name. (or <c>null</c>).
            </para>
            <note>
            One of <see cref="P:Neon.Cadence.Internal.DomainDescribeRequest.Name"/> or <see cref="P:Neon.Cadence.Internal.DomainDescribeRequest.Uuid"/> must be non-null and non-empty.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainDescribeRequest.Uuid">
            <summary>
            <para>
            The target Cadence domain UUID (or <c>null</c>).
            </para>
            <note>
            One of <see cref="P:Neon.Cadence.Internal.DomainDescribeRequest.Name"/> or <see cref="P:Neon.Cadence.Internal.DomainDescribeRequest.Uuid"/> must be non-null and non-empty.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainDescribeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainDescribeRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DomainListReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.DomainListRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainListReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainListReply.Domains">
            <summary>
            Lists information about the Cadence domains.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainListReply.NextPageToken">
            <summary>
            Returns an opaque token that can be used in a subsequent <see cref="T:Neon.Cadence.Internal.DomainListRequest"/>
            to obtain the next page of results.  This will be <c>null</c> when there are no
            remaining results.  This should be considered to be an opaque value.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainListReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainListReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DomainListRequest">
            <summary>
            <b>client --> proxy:</b> Requests a list of the Cadence domains.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainListRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainListRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainListRequest.PageSize">
            <summary>
            Specifies the maximum number of items to be returned in the reponse.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainListRequest.NextPageToken">
            <summary>
            Optionally specifies the next page of results.  This will be <c>null</c>
            for the first page of results and can be set to the the value returned
            as <see cref="P:Neon.Cadence.Internal.DomainListReply.NextPageToken"/> to retrieve the next page
            of results.  This should be considered to be an opaque value.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainListRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainListRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DomainRegisterReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.DomainRegisterRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainRegisterReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainRegisterReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainRegisterReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DomainRegisterRequest">
            <summary>
            <b>client --> proxy:</b> Requests that the proxy register a Cadence domain.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainRegisterRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainRegisterRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainRegisterRequest.Name">
            <summary>
            Name for the new domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainRegisterRequest.Description">
            <summary>
            Human readable description for the domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainRegisterRequest.OwnerEmail">
            <summary>
            Owner email address.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainRegisterRequest.EmitMetrics">
            <summary>
            Enable metrics.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainRegisterRequest.RetentionDays">
            <summary>
            The complete workflow history retention period in days.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainRegisterRequest.SecurityToken">
            <summary>
            Optional security token.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainRegisterRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainRegisterRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DomainUpdateReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.DomainDescribeRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainUpdateReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainUpdateReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainUpdateReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DomainUpdateRequest">
            <summary>
            <b>client --> proxy:</b> Requests the details for a named domain.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainUpdateRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainUpdateRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainUpdateRequest.Name">
            <summary>
            The target Cadence domain name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainUpdateRequest.UpdatedInfoDescription">
            <summary>
            Specifies the new description.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainUpdateRequest.UpdatedInfoOwnerEmail">
            <summary>
            Specifies the new owner's email address.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainUpdateRequest.ConfigurationEmitMetrics">
            <summary>
            Specifies the metrics emission setting.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainUpdateRequest.ConfigurationRetentionDays">
            <summary>
            Specifies the workfloy history retention period in days.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.DomainUpdateRequest.SecurityToken">
            <summary>
            Optional security token.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainUpdateRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.DomainUpdateRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.HeartbeatReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.HeartbeatRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.HeartbeatReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.HeartbeatReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.HeartbeatReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.HeartbeatRequest">
            <summary>
            <b>client --> proxy:</b> Sent periodically to confirm that the proxy is
            still healthy.  The proxy should send a <see cref="T:Neon.Cadence.Internal.HeartbeatReply"/>,
            possibly indicating that there's a problem by specifying an error.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.HeartbeatRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.HeartbeatRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.HeartbeatRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.HeartbeatRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.InitializeReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.InitializeRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InitializeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InitializeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.InitializeReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.InitializeRequest">
            <summary>
            <b>client --> proxy:</b> Informs the proxy of the network endpoint
            where the client is listening for proxy messages.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InitializeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InitializeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.InitializeRequest.LibraryAddress">
            <summary>
            The IP address where the Cadence client is listening for proxy messages
            send by the <b>cadence-proxy</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InitializeRequest.LibraryPort">
            <summary>
            The port where the Cadence client is listening for messages
            sent by the <b>cadence-proxy</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InitializeRequest.LogLevel">
            <summary>
            Specifies the log level <b>cadence-proxy</b> should use when deciding
            which log events to forward to the <b>cadence-client</b>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InitializeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.InitializeRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.LogReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="T:Neon.Cadence.Internal.CancelRequest"/>
            indicating that the operation was canceled, has already completed or doesn't
            exist.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.LogReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.LogReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.LogReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.LogRequest">
            <summary>
            <b>proxy --> client:</b> Sent by <b>cadence-proxy</b> to log Cadence and cadence-proxy
            events to the host's event stream.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.LogRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.LogRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.LogRequest.TimeUtc">
            <summary>
            Identifies when the event being logged occurred (UTC).
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.LogRequest.LogLevel">
            <summary>
            Identifies the log level.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.LogRequest.FromCadence">
            <summary>
            Specifies the source of the event veing logged.  Set this to <c>true</c>
            for events coming from the GOLANG Cadence client or <c>false</c> for
            events coming from the <b>cadence-proxy</b> wrapper.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.LogRequest.LogMessage">
            <summary>
            The message being logged.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.LogRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.LogRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.NewWorkerReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.NewWorkerRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.NewWorkerReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.NewWorkerReply.WorkerId">
            <summary>
            The ID of the new worker.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.NewWorkerReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.NewWorkerReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.NewWorkerRequest">
            <summary>
            <b>client --> proxy:</b> Registers with Cadence that the current
            connection is capable of executing task and/or activities.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.NewWorkerRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.NewWorkerRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.NewWorkerRequest.Name">
            <summary>
            Specifies the name to be used to register the workflow or activity worker.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.NewWorkerRequest.Domain">
            <summary>
            The domain hosting the Cadence workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.NewWorkerRequest.TaskList">
            <summary>
            Identifies the task list for the source workflows and activities.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.NewWorkerRequest.Options">
            <summary>
            The worker options.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.NewWorkerRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.NewWorkerRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.PingReply">
            <summary>
            Sent in response to a <see cref="T:Neon.Cadence.Internal.PingRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.PingReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.PingReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.PingReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.PingRequest">
            <summary>
            Sent by either the client or proxy for measuring transaction throughput.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.PingRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.PingRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.PingRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.PingRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.StopWorkerReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.StopWorkerRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.StopWorkerReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.StopWorkerReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.StopWorkerReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.StopWorkerRequest">
            <summary>
            <b>client --> proxy:</b> Stops a Cadence worker.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.StopWorkerRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.StopWorkerRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.StopWorkerRequest.WorkerId">
            <summary>
            Identifies the worker being stopped.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.StopWorkerRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.StopWorkerRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.TerminateReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.TerminateRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.TerminateReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.TerminateReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.TerminateReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.TerminateRequest">
            <summary>
            <b>client --> proxy:</b> Signals the proxy that it should terminate gracefully.  The
            proxy should send a <see cref="T:Neon.Cadence.Internal.TerminateReply"/> back to the client and
            then exit, terminating the process.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.TerminateRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.TerminateRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.TerminateRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.TerminateRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.DynamicActivityStub">
            <summary>
            Manages a dynamically generated type safe activity stub class for an activity interface.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DynamicActivityStub.#ctor(System.Type,System.Reflection.Assembly,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="activityInterface">Specifies the activity interface.</param>
            <param name="assembly">The assembly holding the generated stub class.</param>
            <param name="className">The fully qualified stub class name.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.DynamicActivityStub.Create(Neon.Cadence.CadenceClient,Neon.Cadence.Workflow,System.String,Neon.Cadence.ActivityOptions,System.Type)">
            <summary>
            Creates a normal (non-local) activity stub instance suitable for executing a non-local activity.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="workflow">The parent workflow.</param>x
            <param name="activityTypeName">Specifies the activity type name.</param>
            <param name="options">Specifies the <see cref="T:Neon.Cadence.ActivityOptions"/> or <c>null</c>.</param>
            <param name="activityInterface">Specifies the activity interface definition.</param>
            <returns>The activity stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.DynamicActivityStub.CreateLocal(Neon.Cadence.CadenceClient,Neon.Cadence.Workflow,System.Type,Neon.Cadence.LocalActivityOptions)">
            <summary>
            Creates a local activity stub instance suitable for executing a local activity.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="workflow">The parent workflow.</param>
            <param name="activityType">The activity implementation type.</param>
            <param name="options">Specifies the <see cref="T:Neon.Cadence.LocalActivityOptions"/> or <c>null</c>.</param>
            <returns>The activity stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.Internal.DynamicWorkflowStub">
            <summary>
            Manages a dynamically generated type safe workflow stub class for a workflow interface.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.DynamicWorkflowStub.#ctor(System.Type,System.Reflection.Assembly,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="workflowInterface">Specifies the workflow interface.</param>
            <param name="assembly">The assembly holding the generated stub class.</param>
            <param name="className">The fully qualified stub class name.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.DynamicWorkflowStub.Create(Neon.Cadence.CadenceClient,Neon.Cadence.IDataConverter,System.String,Neon.Cadence.WorkflowOptions,System.Type)">
            <summary>
            Creates a workflow stub instance suitable for starting a new external workflow.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="dataConverter">The data converter.</param>
            <param name="workflowTypeName">Specifies the workflow type name.</param>
            <param name="options">Specifies the <see cref="T:Neon.Cadence.WorkflowOptions"/> or <c>null</c>.</param>
            <param name="workflowInterface">Specifies the workflow interface definition.</param>
            <returns>The workflow stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.DynamicWorkflowStub.Create(Neon.Cadence.CadenceClient,Neon.Cadence.IDataConverter,System.String,System.String,System.String)">
            <summary>
            Creates a workflow stub instance suitable for connecting to an existing external workflow.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="dataConverter">The data converter.</param>
            <param name="workflowId">Specifies the workflow ID.</param>
            <param name="domain">Optionally specifies the workflow run ID.</param>
            <param name="runId">Optionally specifies the domain.</param>
            <returns>The workflow stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.DynamicWorkflowStub.Create(Neon.Cadence.CadenceClient,Neon.Cadence.IDataConverter,Neon.Cadence.Workflow,System.String,Neon.Cadence.ChildWorkflowOptions,System.Type)">
            <summary>
            Creates a workflow stub instance suitable for starting a new child workflow.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="dataConverter">The data converter.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowTypeName">Specifies the workflow type name.</param>
            <param name="options">Specifies the child workflow options or <c>null</c>.</param>
            <param name="workflowInterface">Specifies the workflow interface definition.</param>
            <returns>The workflow stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.DynamicWorkflowStub.Create(Neon.Cadence.CadenceClient,Neon.Cadence.IDataConverter,Neon.Cadence.Workflow,System.String,Neon.Cadence.Internal.ChildExecution)">
            <summary>
            Creates a workflow stub instance mapping to an already started child workflow.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="dataConverter">The data converter.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowTypeName">Specifies the workflow type name.</param>
            <param name="childExecution">The child execution information.</param>
            <returns>The workflow stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.DynamicWorkflowStub.Create(Neon.Cadence.CadenceClient,Neon.Cadence.IDataConverter,Neon.Cadence.Workflow,Neon.Cadence.WorkflowExecution)">
            <summary>
            Creates a stub for an existing child workflow specified by a <see cref="T:Neon.Cadence.WorkflowExecution"/>.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="dataConverter">The data converter.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="execution">The <see cref="T:Neon.Cadence.WorkflowExecution"/>.</param>
            <returns>The workflow stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.DynamicWorkflowStub.Create(Neon.Cadence.CadenceClient,Neon.Cadence.IDataConverter,Neon.Cadence.Workflow,System.String,System.String)">
            <summary>
            Creates a stub for an existing child workflow specified by its workflow ID and optional domain.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="dataConverter">The data converter.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowId">The workflow ID.</param>
            <param name="domain">Optionally overrides the default client domain.</param>
            <returns>The workflow stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.DynamicWorkflowStub.Create(Neon.Cadence.CadenceClient,Neon.Cadence.IDataConverter,System.String,Neon.Cadence.ContinueAsNewOptions)">
            <summary>
            Creates a workflow stub instance suitable for continuing a workflow as new.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="dataConverter">The data converter.</param>
            <param name="workflowTypeName">Specifies the workflow type name.</param>
            <param name="options">Optionally specifies the continuation options.</param>
            <returns>The workflow stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.DynamicWorkflowStub.ToUntypedAsync">
            <summary>
            <para>
            Creates a new untyped <see cref="T:Neon.Cadence.WorkflowStub"/> from the dynamic stub.
            </para>
            <note>
            The workflow must have already been started via the stub.
            </note>
            </summary>
            <returns>The new <see cref="T:Neon.Cadence.WorkflowStub"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the stub passed is not external (e.g. it's a child stub).</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if the stubbed workflow has not been started yet.</exception>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalActivityInfo">
            <summary>
            Holds information about an executing activity.  This maps directly to the
            GOLANG client's <b>ActivityInfo</b> structure.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityInfo.TaskToken">
            <summary>
            The opaque activity base-64 encoded task token.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityInfo.WorkflowType">
            <summary>
            The parent workflow type.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityInfo.WorkflowDomain">
            <summary>
            The parent workflow domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityInfo.WorkflowExecution">
            <summary>
            The parent workflow execution details.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityInfo.ActivityId">
            <summary>
            The activity ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityInfo.ActivityType">
            <summary>
            The activity type.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityInfo.TaskList">
            <summary>
            The activity task list.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityInfo.HeartbeatTimeout">
            <summary>
            The maximum time between heartbeats.  0 means no heartbeat needed.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityInfo.ScheduledTimestamp">
            <summary>
            Time (UTC) when the activity was scheduled.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityInfo.StartedTimestamp">
            <summary>
            Time (UTC) when the activity was started.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityInfo.Deadline">
            <summary>
            Time (UTC) when the activity will timeout.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityInfo.Attempt">
            <summary>
            Indicates how many times the activity was been restarted.  This will be zero
            for the first execution, 1 for the second, and so on.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalActivityInfo.ToPublic">
            <summary>
            Converts the instance into a public <see cref="T:Neon.Cadence.ActivityTask"/>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalActivityOptions">
            <summary>
            Specifies the options used for executing an activity.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityOptions.TaskList">
            <summary>
            TaskList that the activity needs to be scheduled on.
            optional: The default task list with the same name as the workflow task list.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityOptions.ScheduleToCloseTimeout">
            <summary>
            ScheduleToCloseTimeout - The end to end timeout for the activity needed.
            The zero value of this uses default value.
            Optional: The default value is the sum of ScheduleToStartTimeout and StartToCloseTimeout
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityOptions.ScheduleToStartTimeout">
            <summary>
            ScheduleToStartTimeout - The queue timeout before the activity starts executed.
            Mandatory: No default.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityOptions.StartToCloseTimeout">
            <summary>
            StartToCloseTimeout - The timeout from the start of execution to end of it.
            Mandatory: No default.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityOptions.HeartbeatTimeout">
            <summary>
            HeartbeatTimeout - The periodic timeout while the activity is in execution. This is
            the max interval the server needs to hear at-least one ping from the activity.
            Optional: Default zero, means no heart beating is needed.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityOptions.WaitForCancellation">
            <summary>
            WaitForCancellation - Whether to wait for cancelled activity to be completed(
            activity can be failed, completed, cancel accepted)
            Optional: default false
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityOptions.ActivityID">
            <summary>
            ActivityID - Business level activity ID, this is not needed for most of the cases if you have
            to specify this then talk to cadence team. This is something will be done in future.
            Optional: default empty string
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityOptions.RetryPolicy">
            <summary>
            RetryPolicy specify how to retry activity if error happens. When RetryPolicy.ExpirationInterval is specified
            and it is larger than the activity's ScheduleToStartTimeout, then the ExpirationInterval will override activity's
            ScheduleToStartTimeout. This is to avoid retrying on ScheduleToStartTimeout error which only happen when worker
            is not picking up the task within the timeout. Retrying ScheduleToStartTimeout does not make sense as it just
            mark the task as failed and create a new task and put back in the queue waiting worker to pick again. Cadence
            server also make sure the ScheduleToStartTimeout will not be larger than the workflow's timeout.
            Same apply to ScheduleToCloseTimeout. See more details about RetryPolicy on the doc for RetryPolicy.
            Optional: default is no retry
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalActivityType">
            <summary>
            <b>INTERNAL USE ONLY:</b> Identifies an activity type.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalActivityType.Name">
            <summary>
            Identifies the workflow implementation.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalBadBinaryInfo">
            <summary>
            $todo(jefflill): Don't know what this is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalBadBinaryInfo.Reason">
            <summary>
            $todo(jefflill): Don't know what this is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalBadBinaryInfo.Operator">
            <summary>
            $todo(jefflill): Don't know what this is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalBadBinaryInfo.CreatedTimeNano">
            <summary>
            $todo(jefflill): Don't know what this is.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalChildWorkflowOptions">
            <summary>
            <para>
            <b>INTERNAL USE ONLY:</b> Specifies child workflow execution options.  This maps 
            closely to this Cadence GOLANG structure:
            </para>
            <para>
            https://godoc.org/go.uber.org/cadence/internal#ChildWorkflowOptions
            </para>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalChildWorkflowOptions.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalChildWorkflowOptions.Domain">
            <summary>
            Domain of the child workflow.
            Optional: the current workflow (parent)'s domain will be used if this is not provided.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalChildWorkflowOptions.WorkflowID">
            <summary>
            WorkflowID of the child workflow to be scheduled.
            Optional: an auto generated workflowID will be used if this is not provided.        /// </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalChildWorkflowOptions.TaskList">
            <summary>
            TaskList that the child workflow needs to be scheduled on.
            Optional: the parent workflow task list will be used if this is not provided.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalChildWorkflowOptions.ExecutionStartToCloseTimeout">
            <summary>
            ExecutionStartToCloseTimeout - The end to end timeout for the child workflow execution.
            Mandatory: no default
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalChildWorkflowOptions.TaskStartToCloseTimeout">
            <summary>
            TaskStartToCloseTimeout - The decision task timeout for the child workflow.
            Optional: default is 10s if this is not provided (or if 0 is provided).
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalChildWorkflowOptions.ChildClosePolicy">
            <summary>
            ChildClosePolicy defines the behavior of child workflow when parent workflow is terminated.
            Optional: default to use ParentClosePolicy.RequestCancel. We currently only support this policy.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalChildWorkflowOptions.WaitForCancellation">
            <summary>
            WaitForCancellation - Whether to wait for cancelled child workflow to be ended (child workflow can be ended
            as: completed/failed/timedout/terminated/canceled)
            Optional: default false
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalChildWorkflowOptions.WorkflowIdReusePolicy">
            <summary>
            WorkflowIDReusePolicy - Whether server allow reuse of workflow ID, can be useful
            for dedup logic if set to WorkflowIdReusePolicyRejectDuplicate
            Optional: defaulted to WorkflowIdReusePolicyAllowDuplicate.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalChildWorkflowOptions.RetryPolicy">
            <summary>
            RetryPolicy - Optional retry policy for workflow. If a retry policy is specified, in case of workflow failure
            server will start new workflow execution if needed based on the retry policy.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalChildWorkflowOptions.CronSchedule">
            <summary>
            <para>
            CronSchedule - Optional cron schedule for workflow. If a cron schedule is specified, the workflow will run
            as a CRON workflow based on the schedule. The scheduling will be based on UTC time. Schedule for next execution only happen
            after the current execution is completed/failed/timeout. If a RetryPolicy is also supplied, and the workflow failed
            or timeout, the workflow will be retried based on the retry policy. While the workflow is retrying, it won't
            schedule its next execution. If next schedule is due while workflow is running (or retrying), then it will skip that
            schedule. Cron workflow will not stop until it is terminated or cancelled (by returning cadence.CanceledError).
            The cron spec is as following:
            </para>
            <code>
            ┌───────────── minute (0 - 59)
            │ ┌───────────── hour (0 - 23)
            │ │ ┌───────────── day of the month (1 - 31)
            │ │ │ ┌───────────── month (1 - 12)
            │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)
            │ │ │ │ │
            │ │ │ │ │
            * * * * *
            </code>
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalDescribeDomainResponse">
            <summary>
            <b>INTERNAL USE ONLY:</b> Describes a Cadence domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDescribeDomainResponse.DomainInfo">
            <summary>
            The domain information.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDescribeDomainResponse.DomainConfiguration">
            <summary>
            The domain configuration.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalDescribeDomainResponse.IsGlobalDomain">
            <summary>
            Indicates whether the domain is global.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalDescribeDomainResponse.ToPublic">
            <summary>
            Converts the internal instance into a public <see cref="T:Neon.Cadence.DomainDescription"/>.
            </summary>
            <returns>The converted <see cref="T:Neon.Cadence.DomainDescription"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalDescribeTaskListResponse">
            <summary>
            <b>INTERNAL USE ONLY:</b> Cadence task list details.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDescribeTaskListResponse.Pollers">
            <summary>
            Lists the pollers (AKA workers) that have communicated with the Cadence cluster over
            the past few minutes.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalDescribeTaskListResponse.ToPublic">
            <summary>
            Converts the instance into a public <see cref="T:Neon.Cadence.TaskListDescription"/>.
            </summary>
            <returns>The converted <see cref="T:Neon.Cadence.TaskListDescription"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalDescribeWorkflowExecutionResponse">
            <summary>
            <b>INTERNAL USE ONLY:</b> Cadence workflow execution details response.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDescribeWorkflowExecutionResponse.ExecutionConfiguration">
            <summary>
            Execution configuration.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDescribeWorkflowExecutionResponse.WorkflowExecutionInfo">
            <summary>
            Execution info.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDescribeWorkflowExecutionResponse.PendingActivities">
            <summary>
            Pending activities.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDescribeWorkflowExecutionResponse.PendingChildren">
            <summary>
            Pending child workflows.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalDescribeWorkflowExecutionResponse.ToPublic">
            <summary>
            Converts the instance into a public <see cref="T:Neon.Cadence.WorkflowDescription"/>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalDomainConfiguration">
            <summary>
            <b>INTERNAL USE ONLY:</b> Describes a Cadence domain configuration.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDomainConfiguration.WorkflowExecutionRetentionPeriodInDays">
            <summary>
            Determines how long  workflow executions are retained.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDomainConfiguration.EmitMetric">
            <summary>
            Enables metrics.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDomainConfiguration.BadBinaries">
            <summary>
            $todo(jefflill): Don't know what this is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDomainConfiguration.HistoryArchivalStatus">
            <summary>
            $todo(jefflill): Don't know what this is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDomainConfiguration.HistoryArchivalUri">
            <summary>
            $todo(jefflill): Don't know what this is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDomainConfiguration.VisibilityArchivalStatus">
            <summary>
            $todo(jefflill): Don't know what this is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDomainConfiguration.VisibilityArchivalUri">
            <summary>
            $todo(jefflill): Don't know what this is.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalDomainConfiguration.ToPublic">
            <summary>
            Converts the internal instance into a public <see cref="T:Neon.Cadence.DomainConfiguration"/>.
            </summary>
            <returns>The converted instance.</returns>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalDomainInfo">
            <summary>
            <b>INTERNAL USE ONLY:</b> Describes a Cadence domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDomainInfo.Name">
            <summary>
            The domain name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDomainInfo.DomainStatus">
            <summary>
            The domain status.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDomainInfo.Description">
            <summary>
            The domain description.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDomainInfo.OwnerEmail">
            <summary>
            The email address for the domain owner.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalDomainInfo.Data">
            <summary>
            A dictionary of named byte data that can be attached to domain
            and that can be used for any purpose.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalDomainInfo.Uuid">
            <summary>
            The domain's globally unique ID.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalDomainInfo.ToPublic">
            <summary>
            Converts the internal instance into a public <see cref="T:Neon.Cadence.DomainInfo"/>.
            </summary>
            <returns>The converted <see cref="T:Neon.Cadence.DomainInfo"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalLocalActivityOptions">
            <summary>
            <b>INTERNAL USE ONLY:</b> Specifies local activity execution options.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalLocalActivityOptions.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalLocalActivityOptions.ScheduleToCloseTimeout">
            <summary>
            Specifies the maximum time the activity can run.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalLocalActivityOptions.RetryPolicy">
            <summary>
            The activity retry policy.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalMemo">
            <summary>
            <b>INTERNAL USE ONLY:</b> Holds optional metadata describing workflow as a map
            relating string names to byte arrays.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalMemo.Fields">
            <summary>
            Metadata keyed by string names.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalMessageTypes">
            <summary>
            <b>INTERNAL USE ONLY:</b> Enumerates the possible message types.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.Unspecified">
            <summary>
            Indicates a message with an unspecified type.  This normally indicates an error.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.InitializeRequest">
            <summary>
            <b>client --> proxy:</b> Informs the proxy of the network endpoint where the
            client is listening for proxy messages.  The proxy should respond with an
            <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.InitializeReply"/> when it's ready to begin receiving inbound
            proxy messages.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.InitializeReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.InitializeRequest"/> message
            to indicate that the proxy ready to begin receiving inbound proxy messages.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ConnectRequest">
            <summary>
            client --> proxy: Requests that the proxy establish a connection to a Cadence
            cluster.  This maps to a <c>NewClient()</c> in the proxy.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ConnectReply">
            <summary>
            proxy --> client: Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ConnectRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.TerminateRequest">
            <summary>
            <b>client --> proxy:</b> Signals the proxy that it should terminate gracefully.  The
            proxy should send a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.TerminateReply"/> back to the client and
            then exit, terminating the process.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.TerminateReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.TerminateRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.DomainRegisterRequest">
            <summary>
            <b>client --> proxy:</b> Requests that the proxy register a Cadence domain.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.DomainRegisterReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.DomainRegisterRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.DomainDescribeRequest">
            <summary>
            <b>client --> proxy:</b> Requests that the proxy return the details for a Cadence domain.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.DomainDescribeReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.DomainDescribeRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.DomainUpdateRequest">
            <summary>
            <b>client --> proxy:</b> Requests that the proxy update a Cadence domain.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.DomainUpdateReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.DomainUpdateRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.HeartbeatRequest">
            <summary>
            <b>client --> proxy:</b> Sent periodically (every second) by the client to the
            proxy to verify that it is still healthy.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.HeartbeatReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.HeartbeatRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.CancelRequest">
            <summary>
            <b>client --> proxy:</b> Sent to request that a pending operation be cancelled.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.CancelReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.CancelRequest"/> message,
            indicating that the operation was canceled or that it already completed or no longer
            exists.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.NewWorkerRequest">
            <summary>
            <b>client --> proxy:</b> Indicates that the application is capable of handling workflows
            and activities within a specific Cadence domain and task lisk.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.NewWorkerReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.NewWorkerRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.StopWorkerRequest">
            <summary>
            <b>client --> proxy:</b> Stops a Cadence worker.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.StopWorkerReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.StopWorkerRequest"/> message,
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.PingRequest">
            <summary>
            Sent from either the client or proxy mainly for measuring the raw throughput of 
            client/proxy transactions.  The receiver simply responds immediately with a
            <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.PingReply"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.PingReply">
            <summary>
            Sent by either side in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.PingRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.DomainDeprecateRequest">
            <summary>
            <b>client --> proxy:</b> Requests that the proxy deprecate a Cadence domain.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.DomainDeprecateReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.DomainDeprecateRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.DisconnectRequest">
            <summary>
             <b>client --> proxy:</b> Sent to have the proxy disconnect from a Cadence cluster.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.DisconnectReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.DisconnectRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.LogRequest">
            <summary>
            <b>proxy --> client:</b> Sent by <b>cadence-proxy</b> to log Cadence and cadence-proxy
            events to the host's event stream.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.LogReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.LogRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.DomainListRequest">
            <summary>
            <b>client --> proxy:</b> Sent to list the Cadence domains.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.DomainListReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.DomainListRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.DescribeTaskListRequest">
            <summary>
            <b>client --> proxy:</b> Sent to obtain details for a task list.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.DescribeTaskListReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.DescribeTaskListRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowRegisterRequest">
            <summary>
            <b>client --> proxy:</b> Registers a workflow handler.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowRegisterReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowRegisterRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowExecuteRequest">
            <summary>
            <b>client --> proxy:</b> Starts a workflow.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowExecuteReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowExecuteRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalRequest">
            <summary>
            <b>client --> proxy:</b> Signals a running workflow.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalWithStartRequest">
             <summary>
            <b>client --> proxy:</b> Signals a workflow, starting it first if necessary.
             </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalWithStartReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalWithStartRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowCancelRequest">
            <summary>
            <b>client --> proxy:</b> Cancels a workflow.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowCancelReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowCancelRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowTerminateRequest">
            <summary>
            <b>client --> proxy:</b> Terminates a workflow.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowTerminateReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowTerminateRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetHistoryRequest">
            <summary>
            <b>client --> proxy:</b> Requests a workflow's history.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetHistoryReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetHistoryRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowListClosedRequest">
            <summary>
            <b>client --> proxy:</b> Requests the list of closed workflows.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowListClosedReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowListClosedRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowListOpenExecutionsRequest">
            <summary>
            <b>client --> proxy:</b> Requests the list of open workflows.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowListOpenExecutionsReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowListOpenExecutionsRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueryRequest">
            <summary>
            <b>client --> proxy:</b> Queries a workflow.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueryReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueryRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowDescribeExecutionRequest">
            <summary>
            <b>client --> proxy:</b> Returns information about a worflow execution.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowDescribeExecutionReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowDescribeExecutionRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.Unused0">
            <summary>
            <b>UNUSED</b>
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.Unused1">
            <summary>
            <b>UNUSED</b>
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Commands the client client and associated .NET application
            to process a workflow instance.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowInvokeReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowInvokeRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowExecuteChildRequest">
            <summary>
            <b>client --> proxy:</b> Initiates execution of a child workflow.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowExecuteChildReply">
            <summary>
            <b>proxy --> cl;ient:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowExecuteChildRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalSubscribeRequest">
            <summary>
            <b>client --> proxy:</b> Indicates that .NET application wishes to consume signals from
            a named channel.  Any signals received by the proxy will be forwarded to the
            client via <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalInvokeRequest"/> messages.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalSubscribeReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalSubscribeRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Sent when a signal is received by the proxy on a subscribed channel.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalInvokeReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalInvokeRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowMutableRequest">
            <summary>
            <b>client --> proxy:</b> Implements the standard Cadence <i>side effect</i> behavior
            by including the mutable result being set.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowMutableReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowMutableRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetVersionRequest">
            <summary>
            <b>client --> proxy:</b> Manages workflow versioning.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetVersionReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetVersionRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSetCacheSizeRequest">
            <summary>
            <b>client --> proxy:</b> Sets the maximum number of bytes the client will use
            to cache the history of a sticky workflow on a workflow worker as a performance
            optimization.  When this is exceeded for a workflow, its full history will
            need to be retrieved from the Cadence cluster the next time the workflow
            instance is assigned to a worker. 
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSetCacheSizeReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSetCacheSizeRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetResultRequest">
            <summary>
            <b>client --> proxy:</b> Requests the workflow result encoded as a byte array, waiting
            for the workflow to complete if it is still running.  Note that this request will fail
            if the workflow did not run to completion.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetResultReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetResultRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowHasLastResultRequest">
            <summary>
             <b>client --> proxy:</b> Determines whether the last execution of the workflow has
             a completion result.  This can be used by CRON workflows to determine whether the
             last execution returned a result.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowHasLastResultReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowHasLastResultRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetLastResultRequest">
            <summary>
             <b>client --> proxy:</b> Returns the result from the last execution of the workflow.
             This can be used by CRON workflows to retrieve state from the last workflow execution.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetLastResultReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetLastResultRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowDisconnectContextRequest">
            <summary>
             <b>client --> proxy:</b> Commands the proxy to replace the current workflow context
             with a new disconnected context.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowDisconnectContextReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowDisconnectContextRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetTimeRequest">
            <summary>
            <b>client --> proxy:</b> Request the current workflow time (UTC).
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetTimeReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowGetTimeRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSleepRequest">
            <summary>
            <b>client --> proxy:</b> Sent to have the workflow sleep for a period of time.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSleepReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSleepRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowWaitForChildRequest">
            <summary>
            <b>client --> proxy:</b> Waits for a workflow that has already been started
            by a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowExecuteChildRequest"/> to finish.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowWaitForChildReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowWaitForChildRequest"/> message
            after the child is finish.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalChildRequest">
            <summary>
            <b>client --> proxy:</b> Sends a signal to a child workflow.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalChildReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSignalChildRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowCancelChildRequest">
            <summary>
            <b>client --> proxy:</b> Cancels a child workflow.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowCancelChildReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowCancelChildRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowFutureReadyRequest">
            <summary>
            <b>client --> proxy:</b> Sent for workflow operations that are implemented in GOLANG as futures 
            and may be executed in parallel.  <b>cadence-proxy</b> will send this message after it has 
            submitted the operation to Cadence but before the future actually completes.  The .NET client 
            uses this as an indication that another Cadence operation may be started.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowFutureReadyReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowFutureReadyRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSetQueryHandlerRequest">
            <summary>
            <b>client --> proxy:</b> Registers a query handler by name.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSetQueryHandlerReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowSetQueryHandlerRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueryInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Invokes a query on a workflow.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueryInvokeReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueryInvokeRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueueNewRequest">
            <summary>
            <b>proxy --> client:</b> Creates a new workflow queue.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueueNewReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueueNewRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueueWriteRequest">
            <summary>
            <b>proxy --> client:</b> Writes data to a queue.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueueWriteReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueueWriteRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueueReadRequest">
            <summary>
            <b>proxy --> client:</b> Reads data from a queue.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueueReadReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueueReadRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.Unused2">
            <summary>
            <b>UNUSED</b>
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.Unused3">
            <summary>
            <b>UNUSED</b>
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueueCloseRequest">
            <summary>
            <b>proxy --> client:</b> Closes a queue.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueueCloseReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.WorkflowQueueCloseRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityExecuteRequest">
            <summary>
            <b>client --> proxy:</b> Executes an activity within the context of a workflow.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityExecuteReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityExecuteRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Invokes an activity on an activity worker. 
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityInvokeReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityInvokeRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityGetHeartbeatDetailsRequest">
            <summary>
            <b>client --> proxy:</b> Requests the heartbeat details from the last failed activity execution.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityGetHeartbeatDetailsReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityGetHeartbeatDetailsRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityLogRequest">
            <summary>
            <b>client --> proxy:</b> Logs a message for an activity.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityLogReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityLogRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityRecordHeartbeatRequest">
            <summary>
            <b>client --> proxy:</b> Records a heartbeat message for an activity.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityRecordHeartbeatReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityRecordHeartbeatRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityHasHeartbeatDetailsRequest">
            <summary>
            <b>client --> proxy:</b> Determines whether an activity execution has any heartbeat details.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityHasHeartbeatDetailsReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityHasHeartbeatDetailsRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityStoppingRequest">
            <summary>
            <b>proxy --> client:</b> Signals the client that an activity is being stopped. 
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityStoppingReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityStoppingRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityExecuteLocalRequest">
            <summary>
            <b>client --> proxy:</b> Executes a local activity within the context of a workflow.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityExecuteLocalReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityExecuteLocalRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityInvokeLocalRequest">
            <summary>
            <b>proxy --> client:</b> Invokes a local activity on an activity worker. 
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityInvokeLocalReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityInvokeLocalRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityRegisterRequest">
            <summary>
            <b>client --> proxy:</b> Registers an activity handler.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityRegisterReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to an <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityRegisterRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityGetInfoRequest">
            <summary>
            <b>client --> proxy:</b> Requests information about an activity.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityGetInfoReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to an <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityGetInfoRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityCompleteRequest">
            <summary>
            <b>client --> proxy:</b> Requests that an activity be completed externally.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityCompleteReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to an <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityCompleteRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityStartRequest">
            <summary>
            <b>client --> proxy:</b> Starts an activity but doesn't wait for it to complete.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityStartReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to an <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityStartRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityGetResultRequest">
            <summary>
            <b>client --> proxy:</b> Waits for an activity started via <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityStartRequest"/>
            to complete and returns the result.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityGetResultReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to an <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityGetResultRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityStartLocalRequest">
            <summary>
            <b>client --> proxy:</b> Starts a local activity but doesn't wait for it to complete.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityStartLocalReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to an <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityStartLocalRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityGetLocalResultRequest">
            <summary>
            <b>client --> proxy:</b> Waits for an activity started via <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityStartLocalRequest"/>
            to complete and returns the result.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityGetLocalResultReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to an <see cref="F:Neon.Cadence.Internal.InternalMessageTypes.ActivityGetLocalResultRequest"/> message.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalParentClosePolicy">
            <summary>
            <b>INTERNAL USE ONLY:</b> Enumerates the possible child workflow behaviors 
            when the parent workflow is closed.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalParentClosePolicy.TERMINATE">
            <summary>
            All open child workflows will be terminated when parent workflow is terminated.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalParentClosePolicy.REQUEST_CANCEL">
            <summary>
            Cancel requests will be sent to all open child workflows to all open child 
            workflows when parent workflow is closed.  This is the default policy.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalParentClosePolicy.ABANDON">
            <summary>
            Child workflow execution will continue unaffected when parent workflow is
            closed.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalPendingActivityInfo">
            <summary>
            <b>INTERNAL USE ONLY:</b> Describes an executing activity.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingActivityInfo.ActivityID">
            <summary>
            The activity ID.
            </summary>        [JsonProperty(PropertyName = "activityID", DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingActivityInfo.ActivityType">
            <summary>
            The activity type.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingActivityInfo.State">
            <summary>
            The activity state.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingActivityInfo.HeartbeatDetails">
            <summary>
            Details from the last activity heartbeart.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingActivityInfo.LastHeartbeatTimestamp">
            <summary>
            Time when the last activity heartbeat was received.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingActivityInfo.LastStartedTimestamp">
            <summary>
            Time when the activity was most recently started.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingActivityInfo.Attempt">
            <summary>
            The number of times the activity has been started/restarted.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingActivityInfo.MaximumAttempts">
            <summary>
            The maximum times the activity may be started.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingActivityInfo.ScheduledTimestamp">
            <summary>
            Time when the activity is scheduled to run.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingActivityInfo.ExpirationTimestamp">
            <summary>
            Time when the activity must complete.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalPendingActivityInfo.ToPublic">
            <summary>
            Converts the instance into the corresponding public <see cref="T:Neon.Cadence.PendingActivityInfo"/>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalPendingActivityState">
            <summary>
            Enumerates the states for a pending activity.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalPendingActivityState.SCHEDULED">
            <summary>
            The activity has been scheduled but is not running.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalPendingActivityState.STARTED">
            <summary>
            The activity is running.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalPendingActivityState.CANCEL_REQUESTED">
            <summary>
            The activity is running but has a cancel request pending.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalPendingChildExecutionInfo">
            <summary>
            <b>INTERNAL USE ONLY:</b> Describes a pending child workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingChildExecutionInfo.WorkflowId">
            <summary>
            The workflow ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingChildExecutionInfo.RunId">
            <summary>
            The workflow run ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingChildExecutionInfo.WorkflowTypeName">
            <summary>
            The workflow type name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingChildExecutionInfo.InitiatedId">
            <summary>
            $todo(jefflill): Don't know what this is.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalPendingChildExecutionInfo.ToPublic">
            <summary>
            Converts the instance into the corresponding public <see cref="T:Neon.Cadence.PendingChildExecutionInfo"/>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalPendingWorkflowInfo">
            <summary>
            <b>INTERNAL USE ONLY:</b> Describes an executing workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingWorkflowInfo.ActivityID">
            <summary>
            The activity ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingWorkflowInfo.ActivityType">
            <summary>
            The activity type.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingWorkflowInfo.State">
            <summary>
            The activity state.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingWorkflowInfo.HeartbeatDetails">
            <summary>
            Details from the last activity heartbeart.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingWorkflowInfo.LastHeartbeatTimestamp">
            <summary>
            Time when the last activity heartbeat was received.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingWorkflowInfo.LastStartedTimestamp">
            <summary>
            Time when the activity was most recently started.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingWorkflowInfo.Attempt">
            <summary>
            The number of times the activity has been started/restarted.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingWorkflowInfo.MaximumAttempts">
            <summary>
            The maximum times the activity may be started.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingWorkflowInfo.ScheduledTimestamp">
            <summary>
            Time when the activity is scheduled to run.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPendingWorkflowInfo.ExpirationTimestamp">
            <summary>
            Time when the activity must complete.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalPendingWorkflowInfo.ToPublic">
            <summary>
            Converts the instance into the corresponding public <see cref="T:Neon.Cadence.PendingActivityInfo"/>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalPollerInfo">
            <summary>
            Describes a workflow or activity poller.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPollerInfo.LastAccessTime">
            <summary>
            The last time the poller accessed Cadence (Unix Nano UTC).
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPollerInfo.Identity">
            <summary>
            Identifies the poller.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalPollerInfo.RatePerSecond">
            <summary>
            Operations per second from the poller.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalPollerInfo.ToPublic">
            <summary>
            Converts the instance to a <see cref="T:Neon.Cadence.PollerInfo"/>.
            </summary>
            <returns>The converted <see cref="T:Neon.Cadence.PollerInfo"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalProxyMessageAttribute">
            <summary>
            <b>INTERNAL USE ONLY:</b> Used to tag proxy message class implementations 
            and also associate the message class with the message type code.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalProxyMessageAttribute.#ctor(Neon.Cadence.Internal.InternalMessageTypes)">
            <summary>
            Constructor.
            </summary>
            <param name="type">Specifies the message type to be used when serializing the tagged message.</param>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalProxyMessageAttribute.Type">
            <summary>
            Returns the associated message type code.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalRegisterDomainRequest">
            <summary>
            Domain registration details.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalRegisterDomainRequest.Name">
            <summary>
            The domain name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalRegisterDomainRequest.Description">
            <summary>
            The domain description.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalRegisterDomainRequest.OwnerEmail">
            <summary>
            The domain owner's email address.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalRegisterDomainRequest.RetentionDays">
            <summary>
            The number of days to retain the history for workflowws
            completed in this domain.  This defaults to <b>7 days</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalRegisterDomainRequest.EmitMetrics">
            <summary>
            Enables metric generation.  This defaults to <c>false.</c>
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalRegisterDomainRequest.SecurityToken">
            <summary>
            Optional security token.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalReplayStatus">
            <summary>
            Indicates a workflow's current replay status.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalReplayStatus.Unspecified">
            <summary>
            Indicates that the corresponding operation cannot determine the replay
            status (e.g. because the it didn't relate to an executing workflow).
            This is the default value.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalReplayStatus.NotReplaying">
            <summary>
            The related workflow is not replaying.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalReplayStatus.Replaying">
            <summary>
            The related workflow is replaying.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalResetPointInfo">
            <summary>
            <b>INTERNAL USE ONLY:</b> Not sure what is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalResetPointInfo.BinaryChecksum">
            <summary>
            Not sure what is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalResetPointInfo.RunId">
            <summary>
            Not sure what is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalResetPointInfo.FirstDecisionCompletedId">
            <summary>
            Not sure what is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalResetPointInfo.CreatedTimeNano">
            <summary>
            Not sure what is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalResetPointInfo.ExpiringTimeNano">
            <summary>
            Not sure what is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalResetPointInfo.Resettable">
            <summary>
            Not sure what is.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalResetPoints">
            <summary>
            <b>INTERNAL USE ONLY:</b> Decribes the reset points.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalResetPoints.Points">
            <summary>
            Lists the reset points.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalRetryPolicy">
            <summary>
            <para>
            <b>INTERNAL USE ONLY:</b> Used to serialize standard Neon <see cref="T:Neon.Retry.IRetryPolicy"/> 
            instances into a form compatible with the Cadence GOLANG client.  This class maps
            to the Cadence GOLANG client structure:
            </para>
            <para>
            https://godoc.org/go.uber.org/cadence/internal#RetryPolicy
            </para>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalRetryPolicy.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalRetryPolicy.#ctor(Neon.Retry.LinearRetryPolicy)">
            <summary>
            Constructs an instance from a <see cref="T:Neon.Retry.LinearRetryPolicy"/>.
            </summary>
            <param name="policy">The policy.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalRetryPolicy.#ctor(Neon.Retry.ExponentialRetryPolicy)">
            <summary>
            Constructs an instance from a <see cref="T:Neon.Retry.ExponentialRetryPolicy"/>,
            </summary>
            <param name="policy">The policy.</param>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalRetryPolicy.InitialInterval">
            <summary>
            Backoff interval for the first retry. If coefficient is 1.0 then it is used for all retries.
            Required, no default value.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalRetryPolicy.BackoffCoefficient">
            <summary>
            Coefficient used to calculate the next retry backoff interval.
            The next retry interval is previous interval multiplied by this coefficient.
            Must be 1 or larger. Default is 2.0.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalRetryPolicy.MaximumInterval">
            <summary>
            Specifies the maximim retry interval.  Retries intervals will start at <see cref="P:Neon.Cadence.Internal.InternalRetryPolicy.InitialInterval"/>
            and then be multiplied by <see cref="P:Neon.Cadence.Internal.InternalRetryPolicy.BackoffCoefficient"/> for each retry attempt until the
            interval reaches or exceeds <see cref="P:Neon.Cadence.Internal.InternalRetryPolicy.MaximumInterval"/>, at which point point each
            retry will use <see cref="P:Neon.Cadence.Internal.InternalRetryPolicy.MaximumInterval"/> for all subsequent attempts.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalRetryPolicy.ExpirationInterval">
            <summary>
            Maximum time to retry.  Either <see cref="P:Neon.Cadence.Internal.InternalRetryPolicy.ExpirationInterval"/> or <see cref="P:Neon.Cadence.Internal.InternalRetryPolicy.MaximumAttempts"/> is 
            required.  Retries will stop when this is exceeded even if maximum retries is not been reached.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalRetryPolicy.MaximumAttempts">
            <summary>
            Maximum number of attempts.  When exceeded the retries stop.  If not set or set to 0, it means 
            unlimited, and the policy will rely on <see cref="P:Neon.Cadence.Internal.InternalRetryPolicy.ExpirationInterval"/> to decide when to stop
            retrying.  Either <see cref="P:Neon.Cadence.Internal.InternalRetryPolicy.MaximumAttempts"/> or <see cref="P:Neon.Cadence.Internal.InternalRetryPolicy.MaximumInterval"/>"/> is required.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalRetryPolicy.NonRetriableErrorReasons">
            <summary>
            <para>
            Specifies Cadence errors that should not be retried. This is optional. Cadence server 
            will stop retrying if error reason matches this list.
            </para>
            <list type="bullet">
            <item>Custom errors: <b>cadence.NewCustomError(reason)</b></item>
            <item>Panic errors: <b>cadenceInternal:Panic</b></item>
            <item>Generic errors: <b>cadenceInternal:Generic</b></item>
            <item>
            Timeout errors: <b>cadenceInternal:Timeout TIMEOUT_TYPE</b>, where
            <b>TIMEOUT_TYPE</b> can be be <b>START_TO_CLOSE</b> or <b>HEARTBEAT</b>.
            </item>
            </list>
            <note>
            Cancellation is not a failure, so it won't be retried.
            </note>
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalStartWorkflowOptions">
            <summary>
            <para>
            <b>INTERNAL USE ONLY:</b> Specifies workflow execution options.  This maps 
            pretty closely to this Cadence GOLANG structure:
            </para>
            <para>
            https://godoc.org/go.uber.org/cadence/internal#StartWorkflowOptions
            </para>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalStartWorkflowOptions.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalStartWorkflowOptions.ID">
            <summary>
            ID - The business identifier of the workflow execution.
            Optional: defaulted to a uuid.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalStartWorkflowOptions.TaskList">
            <summary>
            TaskList - The decisions of the workflow are scheduled on this queue.
            This is also the default task list on which activities are scheduled. The workflow author can choose
            to override this using activity options.  Mandatory: No default.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalStartWorkflowOptions.ExecutionStartToCloseTimeout">
            <summary>
            ExecutionStartToCloseTimeout - The timeout for duration of workflow execution (expressed
            in nanoseconds).  Mandatory: No default.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalStartWorkflowOptions.DecisionTaskStartToCloseTimeout">
            <summary>
            DecisionTaskStartToCloseTimeout - The timeout for processing decision task from the time the worker
            pulled this task. If a decision task is lost, it is retried after this timeout.
            Expressed as nanoseconds.  Optional: defaulted to 10 secs.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalStartWorkflowOptions.WorkflowIdReusePolicy">
            <summary>
            WorkflowIDReusePolicy - Whether server allow reuse of workflow ID, can be useful
            for dedup logic if set to WorkflowIdReusePolicyRejectDuplicate.
            Optional: defaulted to WorkflowIdReusePolicyAllowDuplicate.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalStartWorkflowOptions.RetryPolicy">
            <summary>
            RetryPolicy - Optional retry policy for workflow. If a retry policy is specified, in case of workflow failure
            server will start new workflow execution if needed based on the retry policy.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalStartWorkflowOptions.CronSchedule">
            <summary>
            <para>
            CronSchedule - Optional cron schedule for workflow. If a cron schedule is specified, the workflow will execution
            as a CRON workflow based on the schedule. The scheduling will be based on UTC time. Schedule for next execution only happen
            after the current execution is completed/failed/timeout. If a RetryPolicy is also supplied, and the workflow failed
            or timeout, the workflow will be retried based on the retry policy. While the workflow is retrying, it won't
            schedule its next execution. If next schedule is due while workflow is running (or retrying), then it will skip that
            schedule. Cron workflow will not stop until it is terminated or cancelled (by returning cadence.CanceledError).
            The cron spec is as following:
            </para>
            <code>
            ┌───────────── minute (0 - 59)
            │ ┌───────────── hour (0 - 23)
            │ │ ┌───────────── day of the month (1 - 31)
            │ │ │ ┌───────────── month (1 - 12)
            │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)
            │ │ │ │ │
            │ │ │ │ │
            * * * * *
            </code>
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalStartWorkflowOptions.Memo">
            <summary>
            Memo - Optional info that will be shown in list workflow.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalTaskList">
            <summary>
            <b>INTERNAL USE ONLY:</b> Describes a task list.  This maps directly to the Cadence GOLANG <b>TaskList</b> structure.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalTaskList.Name">
            <summary>
            Identifies the task list.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalTaskList.TaskListKind">
            <summary>
            Indicates the task list kind.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalTaskListKind">
            <summary>
            <b>INTERNAL USE ONLY:</b> Enumerates the different kinds of task lists.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalTaskListKind.NORMAL">
            <summary>
            Normal.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalTaskListKind.STICKY">
            <summary>
            Sticky.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalWorkerOptions">
            <summary>
            <b>INTERNAL USE ONLY:</b> Specifies the options Cadence will use when assigning
            workflow and activity executions to a user's worker service.  This maps fairly 
            closely to the  Cadence GOLANG <b>WorkerOptions</b>, but we removed a few fields
            that don't make sense to serialize.  See the remarks for more information.
            </summary>
            <remarks>
            <list type="table">
            <item>
                <term><b>MetricsScope</b></term>
                <description>
                I don't believe we'll really need to specify this on a per-workflow basis.
                </description>
            </item>
            <item>
                <term><b>Logger</b></term>
                <description>
                We're not going to support custom workflow loggers.
                </description>
            </item>
            <item>
                <term><b>BackgroundActivityContext </b></term>
                <description>
                I believe the <b>cadence-proxy</b> can a common context for all
                workflow executions.
                </description>
            </item>
            <item>
                <term><b>DataConverter </b></term>
                <description>
                This is not required because <b>cadence-proxy</b> deals only with
                raw byte arrays.
                </description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.MaxConcurrentActivityExecutionSize">
            <summary>
            Specifies the maximum concurrent activity executions this worker can have.
            The zero value of this uses the default value of <b>1K</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.WorkerActivitiesPerSecond">
            <summary>
            Specifies the rate limiting on number of activities that can be executed per second per
            worker.  This defaults to <b>100K</b> when the value is zero.
            </summary>
            <remarks>
            This can be used to limit resources used by the worker.   Notice that the number is represented 
            in float, so that you can set it to less than 1 if needed. For example, set the number to 0.1 
            means you want your activity to be executed once for every 10 seconds. This can be used to
            protect down stream services from flooding.
            </remarks>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.MaxConcurrentLocalActivityExecutionSize">
            <summary>
            Specifies the maximum concurrent local activity executions this worker can have.
            This defaults to <b>1K</b> when the value is zero.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.WorkerLocalActivitiesPerSecond">
            <summary>
            Specifies the rate limiting on number of local activities that can be executed per second per
            worker. This can be used to limit resources used by the worker.  This defaults to <b>100K</b> when
            the value is zero.
            </summary>
            <remarks>
            This can be used to limit resources used by the worker.  Notice that the number is represented in float,
            so that you can set it to less than 1 if needed. For example, set the number to 0.1 means you want your
            local activity to be executed once for every 10 seconds. This can be used to protect down stream services 
            from flooding.
            </remarks>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.TaskListActivitiesPerSecond">
            <summary>
            Specifies rate limiting on number of activities that can be executed per second.
            This defaults to <b>100K</b> when the value is zero.
            </summary>
            <remarks>
            This is managed by the server and controls activities per second for your entire task list
            whereas WorkerActivityTasksPerSecond controls activities only per worker.
            Notice that the number is represented in float, so that you can set it to less than
            1 if needed. For example, set the number to 0.1 means you want your activity to be executed
            once for every 10 seconds. This can be used to protect down stream services from flooding.
            </remarks>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.MaxConcurrentDecisionTaskExecutionSize">
            <summary>
            Specifies the maximum concurrent decision task executions this worker can have.
            This defaults to <b>1K</b> when the value is zero.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.WorkerDecisionTasksPerSecond">
            <summary>
            Specifies the rate limiting on number of decision tasks that can be executed per second per
            worker. This can be used to limit resources used by the worker.
            The zero value of this uses the default value. Default: 100k
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.AutoHeartBeat">
            <summary>
            Enables auto heart-beating for activities.  This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.Identity">
            <summary>
            Specifies an identity that will be used to track this host for debugging.
            This will be included in the Cadence woirkflow history.  This defaults to
            a string including the current hostname, groupName and process ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.EnableLoggingInReplay">
            <summary>
            Optionally enables logging during workflow replay.  This defaults to <c>false</c>.
            </summary>
            <remarks>
            By default, the workflow logger will not log events while workflows are replaying to
            avoid duplicate logs.   Enabling this is generally useful only for debugging purposes.
            </remarks>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.DisableWorkflowWorker">
            <summary>
            Optionally prevents the worker from executing workflows.  This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.DisableActivityWorker">
            <summary>
            Optionally prevents the worker from executing activities.  This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.DisableStickyExecution">
            <summary>
            Optionally disables sticky execution.  This defaults to <c>false</c>.
            </summary>
            <remarks>
            Sticky Execution is to run the decision tasks for one workflow execution on same worker host. This is an
            optimization for workflow execution. When sticky execution is enabled, worker keeps the workflow state in
            memory. New decision task contains the new history events will be dispatched to the same worker. If this
            worker crashes, the sticky decision task will timeout after StickyScheduleToStartTimeout, and cadence server
            will clear the stickiness for that workflow execution and automatically reschedule a new decision task that
            is available for any worker to pick up and resume the progress.
            </remarks>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.StickyScheduleToStartTimeout">
            <summary>
            Optionally disables the sticky schedule to start timeout.  This defaults to <b>5 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.NonDeterministicWorkflowPolicy">
            <summary>
            Configures how decision worker deals with non-deterministic history events.  This defaults to
            <see cref="F:Neon.Cadence.NonDeterministicPolicy.BlockWorkflow"/> which logs an error but does not fail the
            workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkerOptions.WorkerStopTimeout">
            <summary>
            Specifies the maximum time the client will wait for the worker to shutdown gracefully
            before it will be forcefully terminated.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalWorkflowCloseStatus">
            <summary>
            Enumerates the states for a pending activity.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalWorkflowCloseStatus.COMPLETED">
            <summary>
            The workflow completed successfully.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalWorkflowCloseStatus.FAILED">
            <summary>
            The workflow failed.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalWorkflowCloseStatus.CANCELLED">
            <summary>
            The workflow was cancelled.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalWorkflowCloseStatus.TERMINATED">
            <summary>
            The workflow was terminated.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalWorkflowCloseStatus.CONTINUED_AS_NEW">
            <summary>
            The workflow was restarted (aka <i>continued as new</i>).
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.InternalWorkflowCloseStatus.TIMED_OUT">
            <summary>
            The workflow timed out.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalWorkflowExecution">
            <summary>
            <b>INTERNAL USE ONLY:</b> Cadence workflow execution details.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecution.ID">
            <summary>
            The original ID assigned to the workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecution.RunID">
            <summary>
            The latest ID assigned to the workflow.  Note that this will differ
            from <see cref="P:Neon.Cadence.Internal.InternalWorkflowExecution.ID"/> when the workflow has been restarted.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalWorkflowExecution.ToPublic">
            <summary>
            Converts the instance into a public <see cref="T:Neon.Cadence.WorkflowExecution"/>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalWorkflowExecution2">
            <summary>
            <b>INTERNAL USE ONLY:</b> Cadence workflow execution details.  Unforunately, this
            extra class is required because the GOLANG client also defines a second class
            that serializes slightly differently.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecution2.ID">
            <summary>
            The original ID assigned to the workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecution2.RunID">
            <summary>
            The latest ID assigned to the workflow.  Note that this will differ
            from <see cref="P:Neon.Cadence.Internal.InternalWorkflowExecution2.ID"/> when the workflow has been restarted.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalWorkflowExecution2.ToPublic">
            <summary>
            Converts the instance into a public <see cref="T:Neon.Cadence.WorkflowExecution"/>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalWorkflowExecutionConfiguration">
            <summary>
            <b>INTERNAL USE ONLY:</b> Describes a workflow configuration.  This maps directly
            to the Cadence GOLANG  <b>WorkflowExecutionConfiguration </b> structure.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecutionConfiguration.TaskList">
            <summary>
            Identifies the task list where the workflow was scheduled.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecutionConfiguration.ExecutionStartToCloseTimeout">
            <summary>
            Maximum time the entire workflow may take to complete end-to-end (nanoseconds).
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecutionConfiguration.TaskStartToCloseTimeoutSeconds">
            <summary>
            Maximum time a workflow task/decision may take to complete (nanoseconds).
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecutionConfiguration.ChildPolicy">
            <summary>
            The termination policy to apply to the child workflow when
            the parent workflow is terminated.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalWorkflowExecutionConfiguration.ToPublic">
            <summary>
            Coverts the instance to a public <see cref="T:Neon.Cadence.WorkflowConfig"/>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalWorkflowExecutionInfo">
            <summary>
            <b>INTERNAL USE ONLY:</b> Describes a workflow execution.  This maps directly to the Cadence GOLANG <b>WorkflowExecutionInfo</b> structure. 
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecutionInfo.Execution">
            <summary>
            Describes the workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecutionInfo.WorkflowType">
            <summary>
            Identifies the workflow implementation.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecutionInfo.StartTime">
            <summary>
            Workflow start time.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecutionInfo.CloseTime">
            <summary>
            Workflow close time.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecutionInfo.WorkflowCloseStatus">
            <summary>
            Workflow close status.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecutionInfo.HistoryLength">
            <summary>
            Workflow history length.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecutionInfo.ParentDomainId">
            <summary>
            Identifies the domain where the parent workflow is running.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecutionInfo.ParentExecution">
            <summary>
            Identfies the parent workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecutionInfo.ExecutionTime">
            <summary>
            The workflow execution time.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowExecutionInfo.Memo">
            <summary>
            Optional workflow metadata.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalWorkflowExecutionInfo.ComputeExecutionTime">
            <summary>
            Hack to compute the workflowm execution time.
            </summary>
            <returns>The execution <see cref="T:System.TimeSpan"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.InternalWorkflowExecutionInfo.ToPublic">
            <summary>
            Converts the instance into a public <see cref="T:Neon.Cadence.WorkflowStatus"/>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.InternalWorkflowType">
            <summary>
            <b>INTERNAL USE ONLY:</b> Identifies a workflow type name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.InternalWorkflowType.Name">
            <summary>
            Identifies the workflow implementation.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.ITypedWorkflowStub">
            <summary>
            <b>INTERNAL USE ONLY:</b> Interface implemented by generated typed workflow stubs.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ITypedWorkflowStub.ToUntypedAsync">
            <summary>
            Creates an untyped <see cref="T:Neon.Cadence.WorkflowStub"/> from a typed stub.
            </summary>
            <returns>The untyped stub.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.ITypedWorkflowStub.GetExecutionAsync">
            <summary>
            Obtains the workflow execution for stubs that have been started.  This
            fails for unstarted workflows.
            </summary>
            <returns>The workflow <see cref="T:Neon.Cadence.WorkflowExecution"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the stub has not been started.</exception>
        </member>
        <member name="P:Neon.Cadence.Internal.ITypedWorkflowStub.HasExecution">
            <summary>
            Returns <c>true</c> if the stub has already ontained its workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.ITypedWorkflowStub.WaitForExecutionAsync">
            <summary>
            Waits for the workflow stub to be assigned an external or child workflow
            execution.  This is useful for ensuring that the workflow method execution
            has proceeded far enough to have actually submitted the workflow to Cadence.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.Internal.LocalActivityAction">
            <summary>
            Holds information about the activity type to be instantiated and the
            method to be called when a local activity is invoked.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.LocalActivityAction.#ctor(System.Type,System.Reflection.ConstructorInfo,System.Reflection.MethodInfo)">
            <summary>
            Constructor.
            </summary>
            <param name="activityConstructor">The activity constructor.</param>
            <param name="activityType">The target activity type.</param>
            <param name="activityMethod">The target activity method.</param>
        </member>
        <member name="P:Neon.Cadence.Internal.LocalActivityAction.ActivityType">
            <summary>
            The target activity type.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.LocalActivityAction.ActivityConstructor">
            <summary>
            The target activity constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.LocalActivityAction.ActivityMethod">
            <summary>
            The target activity method.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.MemoryStreamPool">
            <summary>
            Manages a pool of <see cref="T:System.IO.MemoryStream"/> instances used for serializing
            and deserializing proxy messages.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.MemoryStreamPool.Alloc">
            <summary>
            Allocates a stream from the pool.
            </summary>
            <returns>The allocated stream.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.MemoryStreamPool.Free(System.IO.MemoryStream)">
            <summary>
            Frees the stream by adding it back to the pool.
            </summary>
            <param name="stream">The stream being freed.</param>
        </member>
        <member name="T:Neon.Cadence.Internal.PropertyNames">
            <summary>
            Enumerates the Cadence proxy message property names as <see cref="T:Neon.Cadence.Internal.PropertyNameUtf8"/>
            values that have the UTF-8 encodings pre-computed.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.PropertyNames.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.PropertyNames.Add(Neon.Cadence.Internal.PropertyNameUtf8)">
            <summary>
            Adds a property name to the internal hash table.
            </summary>
            <param name="propertyName">The property name.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.PropertyNames.Lookup(System.Span{System.Byte})">
            <summary>
            Looks up a property name from a <c>byte</c> <see cref="T:System.Span`1"/>.
            </summary>
            <param name="byteSpan">The byte span.</param>
            <returns>The <see cref="T:Neon.Cadence.Internal.PropertyNameUtf8"/>.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the requested property name does not exist.</exception>
        </member>
        <member name="T:Neon.Cadence.Internal.PropertyNameUtf8">
            <summary>
            Maps a property name string to its UTF-8 form.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.PropertyNameUtf8.ComputeHash(System.Byte[])">
            <summary>
            Computes the hash code for a byte array.
            </summary>
            <param name="bytes">The byte array.</param>
            <returns>The hash code.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.PropertyNameUtf8.ComputeHash(System.Span{System.Byte})">
            <summary>
            Computes the hash code for a <c>byte</c> <see cref="T:System.Span`1"/>.
            </summary>
            <param name="bytes">The byte array.</param>
            <returns>The hash code.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.PropertyNameUtf8.Equal(System.Span{System.Byte},System.Byte[])">
            <summary>
            Compares a <b>byte</b> <see cref="T:System.Span`1"/> against a <c>byte</c> array
            for equality.
            </summary>
            <param name="byteSpan">The byte span.</param>
            <param name="byteArray">The byte array.</param>
            <returns><c>true</c> if the items are equal.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.PropertyNameUtf8.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">The property name string.</param>
        </member>
        <member name="P:Neon.Cadence.Internal.PropertyNameUtf8.Name">
            <summary>
            Returns the property name as a string.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.PropertyNameUtf8.NameUtf8">
            <summary>
            Returns the property name encoded as IUTF-8 bytes.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.PropertyNameUtf8.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.PropertyNameUtf8.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.StubManager">
            <summary>
            Manages the dynamic generation of workflow and activity stub classes.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.StubManager.WorkflowMethodKind">
            <summary>
            Describes what a workflow interface method does.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.StubManager.WorkflowMethodKind.Query">
            <summary>
            The method implements a query.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.StubManager.WorkflowMethodKind.Signal">
            <summary>
            The method implements a signal.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Internal.StubManager.WorkflowMethodKind.Workflow">
            <summary>
            The method is a workflow entry point.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.StubManager.WorkflowMethodDetails">
            <summary>
            Holds additional information about a workflow interface method.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.StubManager.WorkflowMethodDetails.Kind">
            <summary>
            The workflow method type.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.StubManager.WorkflowMethodDetails.SignalMethodAttribute">
            <summary>
            The signal attributes for signal methods
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.StubManager.WorkflowMethodDetails.QueryMethodAttribute">
            <summary>
            The query attributes for query methods.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.StubManager.WorkflowMethodDetails.WorkflowMethodAttribute">
            <summary>
            The workflow attributes for workflow methods.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.StubManager.WorkflowMethodDetails.IsVoid">
            <summary>
            Indicates whether the workflow result is <see cref="T:System.Void"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.StubManager.WorkflowMethodDetails.ReturnType">
            <summary>
            The workflow result type, not including the wrapping <see cref="T:System.Threading.Tasks.Task"/>.
            This will be <see cref="T:System.Void"/> for methods that don't return a value.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.StubManager.WorkflowMethodDetails.Method">
            <summary>
            The low-level method information.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.StubManager.ActivityMethodDetails">
            <summary>
            Holds additional information about an activity method.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.StubManager.ActivityMethodDetails.ActivityMethodAttribute">
            <summary>
            The activity method attribute (or <c>null</c>).
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.StubManager.ActivityMethodDetails.IsVoid">
            <summary>
            Indicates whether the activity result is <see cref="T:System.Void"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.StubManager.ActivityMethodDetails.ReturnType">
            <summary>
            The activity result type, not including the wrapping <see cref="T:System.Threading.Tasks.Task"/>.
            This will be <see cref="T:System.Void"/> for methods that don't return a value.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.StubManager.ActivityMethodDetails.Method">
            <summary>
            The low-level method information.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.NormalizeTypeName(System.Type)">
            <summary>
            Returns C# compatible fully qualified type name for a type.
            </summary>
            <param name="type">The type.</param>
            <returns>The fully qualified type name.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.AppendStubHelper(System.Text.StringBuilder)">
            <summary>
            Generates the static <b>___StubHelper</b> class that exposes internal methods
            and constructors from <see cref="T:Neon.Cadence.CadenceClient"/> and other types that are
            required by generated workflow and activity stubs.  The generated class uses
            reflection to gain access these members.
            </summary>
            <param name="sbSource">The builder used to generated C# source.</param>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.GetWorkflowStub(System.Type,System.Boolean)">
            <summary>
            Returns the <see cref="T:Neon.Cadence.Internal.DynamicWorkflowStub"/> for a workflow interface, dynamically generating code
            to implement the stub if necessary.
            </summary>
            <param name="workflowInterface">The workflow interface type.</param>
            <param name="isChild">Indicates whether an external or child workflow stub is required.</param>
            <returns>The stub instance.</returns>
            <exception cref="T:Neon.Cadence.WorkflowTypeException">Thrown when there are problems with the <paramref name="workflowInterface"/>.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.NewWorkflowStub``1(Neon.Cadence.CadenceClient,System.String,System.String,System.String)">
            <summary>
            Creates a dynamically generated stub to be used to connect to an existing an external workflow.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="workflowId">Specifies the workflow ID.</param>
            <param name="runId">Optionally specifies the workflow's run ID.</param>
            <param name="domain">Optionally specifies a domain that </param>
            <returns>The stub instance.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.NewWorkflowStub``1(Neon.Cadence.CadenceClient,Neon.Cadence.WorkflowOptions,System.String)">
            <summary>
            Creates a dynamically generated stub to be used to create an external workflow with the
            specified workflow interface.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="options">Optionally specifies the workflow options.</param>
            <param name="workflowTypeName">Optionally specifies the workflow type name.</param>
            <returns>The stub instance.</returns>
            <exception cref="T:Neon.Cadence.WorkflowTypeException">Thrown when there are problems with the <typeparamref name="TWorkflowInterface"/>.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.NewChildWorkflowStub``1(Neon.Cadence.CadenceClient,Neon.Cadence.Workflow,Neon.Cadence.ChildWorkflowOptions,System.String)">
            <summary>
            Creates a dynamically generated stub for the specified child workflow interface.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="options">Optionally specifies the workflow options.</param>
            <param name="workflowTypeName">Optionally specifies the workflow type name.</param>
            <returns>The stub instance.</returns>
            <exception cref="T:Neon.Cadence.WorkflowTypeException">Thrown when there are problems with the <typeparamref name="TWorkflowInterface"/>.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.NewChildWorkflowStub``1(Neon.Cadence.CadenceClient,Neon.Cadence.Workflow,System.String,Neon.Cadence.Internal.ChildExecution)">
            <summary>
            Creates a dynamically generated stub for the specified child workflow interface.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowTypeName">Optionally specifies the workflow type name.</param>
            <param name="childExecution">The child execution.</param>
            <returns>The stub instance.</returns>
            <exception cref="T:Neon.Cadence.WorkflowTypeException">Thrown when there are problems with the <typeparamref name="TWorkflowInterface"/>.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.NewChildWorkflowStubById``1(Neon.Cadence.CadenceClient,Neon.Cadence.Workflow,System.String,System.String)">
            <summary>
            Creates a dynamically generated external stub for an existing child workflow using the
            workflow ID and optional domain.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowId">The child workflow ID.</param>
            <param name="domain">Optionally overrides the parent workflow domain.</param>
            <returns>The stub instance.</returns>
            <exception cref="T:Neon.Cadence.WorkflowTypeException">Thrown when there are problems with the <typeparamref name="TWorkflowInterface"/>.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.NewChildWorkflowStubById``1(Neon.Cadence.CadenceClient,Neon.Cadence.Workflow,Neon.Cadence.WorkflowExecution)">
            <summary>
            Creates a dynamically generated external stub for an existing child workflow using the
            workflow execution.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="execution">The child's external workflow execution.</param>
            <returns>The stub instance.</returns>
            <exception cref="T:Neon.Cadence.WorkflowTypeException">Thrown when there are problems with the <typeparamref name="TWorkflowInterface"/>.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.NewContinueAsNewStub``1(Neon.Cadence.CadenceClient,Neon.Cadence.ContinueAsNewOptions)">
            <summary>
            Creates a dynamically generated stub that when called will continue the workflow as new.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="options">Optionally continuation options.</param>
            <returns>The stub instance.</returns>
            <exception cref="T:Neon.Cadence.WorkflowTypeException">Thrown when there are problems with the <typeparamref name="TWorkflowInterface"/>.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.GetActivityStub(System.Type)">
            <summary>
            Returns a <see cref="T:Neon.Cadence.Internal.DynamicActivityStub"/> wrapping the specified activity interface for
            a workflow, dynamically generating the required type if required.
            </summary>
            <param name="activityInterface">The activity interface type.</param>
            <returns>The activity stub instance.</returns>
            <exception cref="T:Neon.Cadence.ActivityTypeException">Thrown when there are problems with the <paramref name="activityInterface"/>.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.NewActivityStub``1(Neon.Cadence.CadenceClient,Neon.Cadence.Workflow,Neon.Cadence.ActivityOptions)">
            <summary>
            Creates a dynamically generated normal (non-local) activity stub for the specified activity interface.
            </summary>
            <typeparam name="TActivityInterface">The activity interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="workflow">The parent workflow.</param>
            <param name="options">Optionally specifies the activity options.</param>
            <returns>The activity stub instance.</returns>
            <exception cref="T:Neon.Cadence.ActivityTypeException">Thrown when there are problems with the <typeparamref name="TActivityInterface"/>.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.NewLocalActivityStub``2(Neon.Cadence.CadenceClient,Neon.Cadence.Workflow,Neon.Cadence.LocalActivityOptions)">
            <summary>
            Creates a dynamically generated local activity stub for the specified activity interface.
            </summary>
            <typeparam name="TActivityInterface">The activity interface type.</typeparam>
            <typeparam name="TActivityImplementation">The activity implementation.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Cadence.CadenceClient"/>.</param>
            <param name="workflow">The parent workflow.</param>
            <param name="options">Optionally specifies the activity options.</param>
            <returns>The activity stub instance.</returns>
            <exception cref="T:Neon.Cadence.ActivityTypeException">Thrown when there are problems with the <typeparamref name="TActivityInterface"/>.</exception>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.SerializeArgsExpression(System.Reflection.ParameterInfo[])">
            <summary>
            Returns the C# expression that uses the stub's data converter to
            serialize workflow method parameters to a byte array.
            </summary>
            <param name="args">The parameters.</param>
            <returns>The C# expression.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.SerializeMethodParameterTypes(System.Reflection.MethodInfo)">
            <summary>
            Renders the parameter types for a method into an array definition suitable for
            including in generated source code.
            </summary>
            <param name="method">The target method information.</param>
            <returns>The array source code.</returns>
        </member>
        <member name="M:Neon.Cadence.Internal.StubManager.StringLiteral(System.String)">
            <summary>
            Renders the string passed as a C# literal, escaping any double quotes.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.SyncSignalCall">
            <summary>
            <b>INTERNAL USE ONLY:</b> Holds information necessary to implement synchronous 
            signals.  This is used internally for transmitting synchronous signals 
            to workflows.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.SyncSignalCall.#ctor(System.String,System.String,System.Byte[])">
            <summary>
            Constructor.
            </summary>
            <param name="targetSignal">Identifies the target signal.</param>
            <param name="signalId">The globally unique signal ID.</param>
            <param name="userArgs">The encoded user arguments being passed to the signal.</param>
        </member>
        <member name="P:Neon.Cadence.Internal.SyncSignalCall.TargetSignal">
            <summary>
            Identifies the signal method targeted by the user.  We need this because the 
            the signal will be sent to <see cref="P:Neon.Cadence.Internal.SyncSignalCall.TargetSignal"/> and the internal handler
            will need this to identify the actual user single method to be called.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.SyncSignalCall.SignalId">
            <summary>
            Specifies a globally unique ID for the signal request operation.  The
            target worker will manage the current state of the signal request and
            the client will use this to poll the worker for the current state.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.SyncSignalCall.UserArgs">
            <summary>
            The encoded user arguments being passed to the signal.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.SyncSignalStatus">
            <summary>
            Holds the status of a synchronous signal execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.SyncSignalStatus.Args">
            <summary>
            Returns the dictionary of signal method arguments keyed by parameter name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.SyncSignalStatus.Completed">
            <summary>
            Returns <c>true</c> if the workflow has finished executing the signal
            and that the result is available (for non-void signals).
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.SyncSignalStatus.Error">
            <summary>
            <para>
            Returns potential error information when <see cref="P:Neon.Cadence.Internal.SyncSignalStatus.Completed"/><c>=true</c>.  This
            will return <c>null</c> if the signal completed without error or else an error
            string describing the exception thrown by the signal method.
            </para>
            <note>
            This string must be formatted by <see cref="M:Neon.Cadence.SyncSignalException.GetError(System.Exception)"/>.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.SyncSignalStatus.Result">
            <summary>
            Returns the encoded result for signals that return results.  This will be <c>null</c> for 
            signals that don't return a result.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.SyncSignalStatus.Acknowledged">
            <summary>
            Returns <c>true</c> after the workflow has returned the result of the
            completed signal operation to a polling query.  This is used internally
            to delay returning from the workflow while there remain outstanding
            synchronous signals that have not been answered.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.SyncSignalStatus.AcknowledgeTimeUtc">
            <summary>
            Returns the time (UTC) when the signal was acknowledged.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowCancelChildReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowCancelChildRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowCancelChildReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowCancelChildReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowCancelChildReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowCancelChildRequest">
            <summary>
            <b>client --> proxy:</b> Cancels a child workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowCancelChildRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowCancelChildRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowCancelChildRequest.ChildId">
            <summary>
            Identifies the child workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowCancelChildRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowCancelChildRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowCancelReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowCancelRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowCancelReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowCancelReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowCancelReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowCancelRequest">
            <summary>
            <b>proxy --> client:</b> Cancels a workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowCancelRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowCancelRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowCancelRequest.WorkflowId">
            <summary>
            Identifies the workflow by ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowCancelRequest.RunId">
            <summary>
            Identifies the specific workflow execution to be cancelled.  The latest run
            will be cancelled when this is <c>null</c> or empty.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowCancelRequest.Domain">
            <summary>
            Optionally overrides the current client domain.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowCancelRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowCancelRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowDescribeExecutionReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowDescribeExecutionRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowDescribeExecutionReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowDescribeExecutionReply.Details">
            <summary>
            The workflow execution details.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowDescribeExecutionReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowDescribeExecutionReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowDescribeExecutionRequest">
            <summary>
            <b>proxy --> client:</b> Describes an executing workflow instance.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowDescribeExecutionRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowDescribeExecutionRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowDescribeExecutionRequest.WorkflowId">
            <summary>
            Identifies the workflow by ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowDescribeExecutionRequest.RunId">
            <summary>
            Identifies the specific workflow execution to be cancelled.  The latest run
            will be cancelled when this is <c>null</c> or empty.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowDescribeExecutionRequest.Domain">
            <summary>
            Optionally identifies the target domain when <see cref="P:Neon.Cadence.Internal.WorkflowDescribeExecutionRequest.RunId"/> isn't passed.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowDescribeExecutionRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowDescribeExecutionRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowDisconnectContextReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowDisconnectContextRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowDisconnectContextReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowDisconnectContextReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowDisconnectContextReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowDisconnectContextRequest">
            <summary>
            <b>client --> proxy:</b> Commands cadence-proxy to replace the current workflow
            context with context that is disconnected from the parent context.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowDisconnectContextRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowDisconnectContextRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowDisconnectContextRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowDisconnectContextRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowExecuteChildReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowExecuteChildReply"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowExecuteChildReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowExecuteChildReply.ChildId">
            <summary>
            The child workflow identifier.  This will be used in other messages such 
            as <see cref="T:Neon.Cadence.Internal.WorkflowSignalChildRequest"/>, <see cref="T:Neon.Cadence.Internal.WorkflowWaitForChildRequest"/>,
            and <see cref="T:Neon.Cadence.Internal.WorkflowCancelChildRequest"/> to identify the target child workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowExecuteChildReply.Execution">
            <summary>
            Returns details identifying the child workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowExecuteChildReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowExecuteChildReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowExecuteChildRequest">
            <summary>
            <b>client --> proxy:</b> Begins execution of a child workflow returning the
            new workflow IDs.  A subsequent <see cref="T:Neon.Cadence.Internal.WorkflowWaitForChildRequest"/> message
            will be sent to wait for the workflow to actually finish.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowExecuteChildRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowExecuteChildRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowExecuteChildRequest.Workflow">
            <summary>
            Specifies the child workflow to be executed.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowExecuteChildRequest.Args">
            <summary>
            Specifies the child workflow arguments.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowExecuteChildRequest.Options">
            <summary>
            Specifies the child workflow options.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowExecuteChildRequest.ScheduleToStartTimeout">
            <summary>
            Specifies the maximum time the workflow will wait after being scheduled
            until it is executed to a worker.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowExecuteChildRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowExecuteChildRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowExecuteReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowExecuteRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowExecuteReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowExecuteReply.Execution">
            <summary>
            Returns details identifying the workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowExecuteReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowExecuteReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowExecuteRequest">
            <summary>
            <b>proxy --> client:</b> Starts a workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowExecuteRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowExecuteRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowExecuteRequest.Workflow">
            <summary>
            Identifies the workflow implementation to be started.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowExecuteRequest.Args">
            <summary>
            Optionally specifies the workflow arguments encoded as a byte array.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowExecuteRequest.Options">
            <summary>
            Optionally specifies the workflow start options.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowExecuteRequest.Domain">
            <summary>
            Specifies the Cadence domain where the workflow will run.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowExecuteRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowExecuteRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowFutureReadyReply">
            <summary>
            <para>
            <b>proxy --> client:</b> This is a special reply message sent for workflow operations that
            are implemented in GOLANG as futures and may be executed in parallel.  <b>cadence-proxy</b>
            will send this message after it has submitted the operation to Cadence but before the future
            actually completes.  The .NET client uses this reply as an indication that another Cadence
            operation may be started.
            </para>
            <note>
            This message does not have a corresponding request message (which is why the name doesn't end with "Reply".
            </note>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowFutureReadyReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowFutureReadyReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowFutureReadyReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowFutureReadyRequest">
            <summary>
            <b>proxy --> client:</b> Sent for workflow operations that are implemented in GOLANG as futures 
            and may be executed in parallel.  <b>cadence-proxy</b> will send this message after it has 
            submitted the operation to Cadence but before the future actually completes.  The .NET client 
            uses this as an indication that another Cadence operation may be started.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowFutureReadyRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowFutureReadyRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowFutureReadyRequest.FutureOperationId">
            <summary>
            The ID of the original operation what has been submitted to Cadence
            and who's future has been returned.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowFutureReadyRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowFutureReadyRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowGetLastLastReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowGetLastResultRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetLastLastReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowGetLastLastReply.Result">
            <summary>
            Indicates the workflow's last completion result.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetLastLastReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetLastLastReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowGetLastResultRequest">
            <summary>
            <b>client --> proxy:</b> Returns the result from the last execution of the workflow.
             This can be used by CRON workflows to retrieve state from the last workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetLastResultRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowGetLastResultRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetLastResultRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetLastResultRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowGetResultReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowGetResultRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetResultReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowGetResultReply.Result">
            <summary>
            The query result bytes or <c>null</c>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetResultReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetResultReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowGetResultRequest">
            <summary>
            <b>proxy --> client:</b> Requests the results from a workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetResultRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowGetResultRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowGetResultRequest.WorkflowId">
            <summary>
            Identifies the workflow by ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowGetResultRequest.RunId">
            <summary>
            Identifies the specific workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowGetResultRequest.Domain">
            <summary>
            Identifies the target domain.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetResultRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetResultRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowGetTimeReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowGetTimeReply"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetTimeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowGetTimeReply.Time">
            <summary>
            The current workflow time expressed as 100 nanosecond ticks
            since 01/01/0001 00:00.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetTimeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetTimeReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowGetTimeRequest">
            <summary>
            <b>client --> proxy:</b> Requests the current workflow time.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetTimeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowGetTimeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetTimeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetTimeRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowGetVersionReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowGetVersionRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetVersionReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowGetVersionReply.Version">
            <summary>
            Returns the workflow implementation version. 
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetVersionReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetVersionReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowGetVersionRequest">
            <summary>
            <b>client --> proxy:</b> Manages workflow versioning.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetVersionRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowGetVersionRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowGetVersionRequest.ChangeId">
            <summary>
            Identifies change from one workflow implementation version to another.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowGetVersionRequest.MinSupported">
            <summary>
            Specifies the minimum supported workflow implementation version.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowGetVersionRequest.MaxSupported">
            <summary>
            Specifies the maximum supported workflow implementation version.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetVersionRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowGetVersionRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowHasLastResultReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowHasLastResultRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowHasLastResultReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowHasLastResultReply.HasResult">
            <summary>
            Indicates whether the workflow has a last completion result.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowHasLastResultReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowHasLastResultReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowHasLastResultRequest">
            <summary>
            <b>client --> proxy:</b> Determines whether the last execution of the workflow has
             a completion result.  This can be used by CRON workflows to determine whether the
             last execution returned a result.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowHasLastResultRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowHasLastResultRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowHasLastResultRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowHasLastResultRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowInvokeReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowInvokeRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowInvokeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeReply.Result">
            <summary>
            The workflow execution result or <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeReply.ContinueAsNew">
            <summary>
            Indicates whether the workflow should be exited and then restarted,
            with an empty history.  This is useful for very long running looping
            workflows that would otherwise end up with very long task histories.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeReply.ContinueAsNewArgs">
            <summary>
            Specifies the arguments to use for the new workflow when 
            <see cref="P:Neon.Cadence.Internal.WorkflowInvokeReply.ContinueAsNew"/> is <c>true</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeReply.ContinueAsNewExecutionStartToCloseTimeout">
            <summary>
            Optionally overrides the current workflow's timeout for the restarted
            workflow when this value is greater than zero.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeReply.ContinueAsNewScheduleToCloseTimeout">
            <summary>
            Optionally overrides the current workflow's timeout for the restarted
            workflow when this value is greater than zero.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeReply.ContinueAsNewScheduleToStartTimeout">
            <summary>
            Optionally overrides the current workflow's timeout for the restarted
            workflow when this value is greater than zero.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeReply.ContinueAsNewStartToCloseTimeout">
            <summary>
            Optionally overrides the current workflow's timeout for the restarted
            workflow when this value is greater than zero.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeReply.ContinueAsNewWorkflow">
            <summary>
             Optionally overrides the current workflow scheduled for 
             execution upon restart when this value is not <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeReply.ContinueAsNewTaskList">
            <summary>
            Optionally overrides the current workflow's task list for the restarted
            workflow when this value is not <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeReply.ContinueAsNewDomain">
            <summary>
            Optionally overrides the current workflow's domain for the restarted
            workflow when this value is not <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeReply.ForceReplay">
            <summary>
            Optionally indicates that the workflow should be aborted such that it
            will be restarted with decision tasks being replayed as required.  The
            <b>cadence-proxy</b> should do this via a GOLANG <b>panic("force-replay")</b>
            within the workflow function.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowInvokeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowInvokeReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Invokes a workflow instance.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowInvokeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeRequest.Name">
            <summary>
            Identifies the workflow implementation to be started.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeRequest.Args">
            <summary>
            The workflow arguments encoded into a byte array (or <c>null</c>).
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeRequest.Domain">
            <summary>
            The domain hosting the workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeRequest.WorkflowId">
            <summary>
            The original workflow ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeRequest.RunId">
            <summary>
            The workflow run ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeRequest.WorkflowType">
            <summary>
            The workflow type name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeRequest.TaskList">
            <summary>
            The task list where the workflow is executing.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeRequest.ExecutionStartToCloseTimeout">
            <summary>
            The maximum duration the workflow is allowed to run.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowInvokeRequest.ReplayStatus">
            <summary>
            Indicates the current workflow replay state.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowInvokeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowInvokeRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowMutableReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowMutableRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowMutableReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowMutableReply.Result">
            <summary>
            Holds the mutable result.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowMutableReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowMutableReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowMutableRequest">
            <summary>
            <b>proxy --> client:</b> Invokes a workflow instance.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowMutableRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowMutableRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowMutableRequest.MutableId">
            <summary>
            Identifies the mutable value.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowMutableRequest.Result">
            <summary>
            The mutable value to be returned.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowMutableRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowMutableRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowQueryInvokeReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowQueryInvokeRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueryInvokeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueryInvokeReply.Result">
            <summary>
            The query result bytes or <c>null</c>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueryInvokeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueryInvokeReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowQueryInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Queries a running workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueryInvokeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueryInvokeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueryInvokeRequest.QueryName">
            <summary>
            Identifies the query.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueryInvokeRequest.QueryArgs">
            <summary>
            Optionally specifies the query arguments.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueryInvokeRequest.ReplayStatus">
            <summary>
            Indicates the current workflow replay state.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueryInvokeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueryInvokeRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowQueryReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowQueryRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueryReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueryReply.Result">
            <summary>
            The query result bytes or <c>null</c>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueryReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueryReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowQueryRequest">
            <summary>
            <b>proxy --> client:</b> Queries a running workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueryRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueryRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueryRequest.WorkflowId">
            <summary>
            Identifies the workflow by ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueryRequest.RunId">
            <summary>
            Identifies the specific workflow execution to be queried.  The latest run
            will be queried when this is <c>null</c> or empty.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueryRequest.Domain">
            <summary>
            Identifies the target domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueryRequest.QueryName">
            <summary>
            Identifies the query.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueryRequest.QueryArgs">
            <summary>
            Optionally specifies the query arguments.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueryRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueryRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowQueueCloseReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowQueueNewRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueCloseReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueCloseReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueCloseReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowQueueCloseRequest">
            <summary>
            <b>proxy --> client:</b> Closes a workflow queue.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueCloseRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueCloseRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueCloseRequest.QueueId">
            <summary>
            Identifies the queue.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueCloseRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueCloseRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowQueueNewReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowQueueNewRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueNewReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueNewReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueNewReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowQueueNewRequest">
            <summary>
            <b>proxy --> client:</b> Creates a new workflow queue.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueNewRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueNewRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueNewRequest.QueueId">
            <summary>
            Identifies the queue.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueNewRequest.Capacity">
            <summary>
            Specifies the capacity of the queue.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueNewRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueNewRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowQueueReadReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowQueueReadRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueReadReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueReadReply.IsClosed">
            <summary>
            Set to <c>true</c> when the queue has been closed.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueReadReply.Data">
            <summary>
            The data item read from the queue or <c>null</c> if the operation
            timed out or the queue has been closed.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueReadReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueReadReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowQueueReadRequest">
            <summary>
            <b>proxy --> client:</b> Reads data from a workflow queue.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueReadRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueReadRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueReadRequest.QueueId">
            <summary>
            Identifies the queue.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueReadRequest.Timeout">
            <summary>
            The maximum time to wait for a data item or <see cref="F:System.TimeSpan.Zero"/> to 
            wait indefinitiely.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueReadRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueReadRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowQueueWriteReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowQueueWriteRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueWriteReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueWriteReply.IsFull">
            <summary>
            Indicates when the queue is full and the item could not be written.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueWriteReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueWriteReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowQueueWriteRequest">
            <summary>
            <b>proxy --> client:</b> Writes data to a workflow queue.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueWriteRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueWriteRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueWriteRequest.QueueId">
            <summary>
            Identifies the queue.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueWriteRequest.NoBlock">
            <summary>
            Indicates whether the write operation should not block when
            the queue is full.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowQueueWriteRequest.Data">
            <summary>
            The data to be written to the queue.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueWriteRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowQueueWriteRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowRegisterReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowRegisterRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowRegisterReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowRegisterReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowRegisterReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowRegisterRequest">
            <summary>
            <b>client --> proxy:</b> Registers a workflow handler by name.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowRegisterRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowRegisterRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowRegisterRequest.Name">
            <summary>
            Identifies the workflow implementation.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowRegisterRequest.Domain">
            <summary>
            Identifies the target workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowRegisterRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowRegisterRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowReply">
            <summary>
            Base class for all workflow related replies.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowReply.ContextId">
            <summary>
            <para>
            Uniquely identifies the workflow context associated with this request.
            </para>
            <note>
            Not all derived classes actually require this property.  In those cases,
            this can remain as its default zero value.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowReply.ReplayStatus">
            <summary>
            For workflow requests related to an executing workflow, this will indicate
            the current history replay state.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowRequest">
            <summary>
            Base class for all workflow related requests.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowRequest.ContextId">
            <summary>
            <para>
            Uniquely identifies the workflow context associated with this request.
            </para>
            <note>
            Not all derived classes actually require this property.  In those cases,
            this can remain as its default zero value.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSetCacheSizeReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowSetCacheSizeRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSetCacheSizeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSetCacheSizeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSetCacheSizeReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSetCacheSizeRequest">
            <summary>
            <b>client --> proxy:</b> Sets the maximum number of bytes the client will use
            to cache the history of a sticky workflow on a workflow worker as a performance
            optimization.  When this is exceeded for a workflow, its full history will
            need to be retrieved from the Cadence cluster the next time the workflow
            instance is assigned to a worker. 
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSetCacheSizeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSetCacheSizeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSetCacheSizeRequest.Size">
            <summary>
            Specifies the maximum number of bytes used for caching sticky workflows.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSetCacheSizeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSetCacheSizeRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSetQueryHandlerReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowExecuteRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSetQueryHandlerReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSetQueryHandlerReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSetQueryHandlerReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSetQueryHandlerRequest">
            <summary>
            <b>proxy --> client:</b> Sends a signal to a running workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSetQueryHandlerRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSetQueryHandlerRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSetQueryHandlerRequest.QueryName">
            <summary>
            Identifies the query.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSetQueryHandlerRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSetQueryHandlerRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSignalChildReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowSignalChildRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalChildReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalChildReply.Result">
            <summary>
            Returns the result of signaling a child workflow
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalChildReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalChildReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSignalChildRequest">
            <summary>
            <b>proxy --> client:</b> Sends a signal to a child workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalChildRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalChildRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalChildRequest.ChildId">
            <summary>
            Identifies child workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalChildRequest.SignalName">
            <summary>
            Identifies the signal.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalChildRequest.SignalArgs">
            <summary>
            Optionally specifies the signal arguments.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalChildRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalChildRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSignalInvokeReply">
            <summary>
            <b>client --> proxy:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowSignalInvokeRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalInvokeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalInvokeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalInvokeReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSignalInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Sends a received signal to a running workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalInvokeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalInvokeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalInvokeRequest.SignalName">
            <summary>
            Identifies the signal.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalInvokeRequest.SignalArgs">
            <summary>
            Optionally specifies the signal arguments.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalInvokeRequest.ReplayStatus">
            <summary>
            Indicates the current workflow replay state.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalInvokeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalInvokeRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSignalReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowSignalRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSignalRequest">
            <summary>
            <b>proxy --> client:</b> Sends a signal to a running workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalRequest.WorkflowId">
            <summary>
            Identifies the workflow by ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalRequest.RunId">
            <summary>
            Identifies the specific workflow execution to be cancelled.  The latest run
            will be cancelled when this is <c>null</c> or empty.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalRequest.Domain">
            <summary>
            Identifies the target domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalRequest.SignalName">
            <summary>
            Identifies the signal.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalRequest.SignalArgs">
            <summary>
            Optionally specifies the signal arguments.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSignalSubscribeReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowSignalSubscribeRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalSubscribeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalSubscribeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalSubscribeReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSignalSubscribeRequest">
            <summary>
            <b>proxy --> client:</b> Subscribes a workflow to a named signal.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalSubscribeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalSubscribeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalSubscribeRequest.SignalName">
            <summary>
            Identifies the signal being subscribed.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalSubscribeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalSubscribeRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSignalWithStartReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowSignalWithStartRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalWithStartReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalWithStartReply.Execution">
            <summary>
            Returns details identifying the workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalWithStartReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalWithStartReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSignalWithStartRequest">
            <summary>
            <b>proxy --> client:</b> Sends a signal to a workflow, starting the
            workflow if it doesn't exist.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalWithStartRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalWithStartRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalWithStartRequest.Workflow">
            <summary>
            Identifies the workflow to be executed if the workflow instance
            idntified by <see cref="P:Neon.Cadence.Internal.WorkflowSignalWithStartRequest.WorkflowId"/> is not currently running.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalWithStartRequest.WorkflowId">
            <summary>
            Identifies the workflow by ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalWithStartRequest.Domain">
            <summary>
            Identifies the target domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalWithStartRequest.SignalName">
            <summary>
            Identifies the signal.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalWithStartRequest.SignalArgs">
            <summary>
            Optionally specifies the signal arguments.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalWithStartRequest.Options">
            <summary>
            Optionally specifies the workflow start options.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSignalWithStartRequest.WorkflowArgs">
            <summary>
            Optionally specifies the workflow arguments.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalWithStartRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSignalWithStartRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSleepReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowSleepRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSleepReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSleepReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSleepReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowSleepRequest">
            <summary>
            <b>client --> proxy:</b> Commands the workflow to sleep for a period of time.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSleepRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSleepRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowSleepRequest.Duration">
            <summary>
            Specifies the time to sleep.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSleepRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowSleepRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowTerminateReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowTerminateRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowTerminateReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowTerminateReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowTerminateReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowTerminateRequest">
            <summary>
            <b>proxy --> client:</b> Terminates a workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowTerminateRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowTerminateRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowTerminateRequest.WorkflowId">
            <summary>
            Identifies the workflow by ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowTerminateRequest.RunId">
            <summary>
            Identifies the specific workflow execution to be cancelled.  The latest run
            will be cancelled when this is <c>null</c> or empty.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowTerminateRequest.Domain">
            <summary>
            Identifies the target domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowTerminateRequest.Reason">
            <summary>
            Optionally indicates the termination reason.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowTerminateRequest.Details">
            <summary>
            Optionally includes additional termination details encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowTerminateRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowTerminateRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowWaitForChildReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Cadence.Internal.WorkflowWaitForChildRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowWaitForChildReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowWaitForChildReply.Result">
            <summary>
            The child workflow results encoded as bytes.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowWaitForChildReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowWaitForChildReply.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.WorkflowWaitForChildRequest">
            <summary>
            <b>client --> proxy:</b> Waits for a child workflow to complete.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowWaitForChildRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowWaitForChildRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Internal.WorkflowWaitForChildRequest.ChildId">
            <summary>
            Identifies the child workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowWaitForChildRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.Internal.WorkflowWaitForChildRequest.CopyTo(Neon.Cadence.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.Internal.SyncSignalReply">
            <summary>
            Holds the internal reply for synchronous signals.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.SyncSignalReply.Error">
            <summary>
            Used to indicate that an exception was thrown by the signal method.
            This will be set to the exception name and error message.  This will
            be <c>null</c> when the signal method completed successfully.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Internal.SyncSignalReply.Result">
            <summary>
            This holds the result for signals that return result and will be
            <c>null</c> for signals that don't return a result.
            </summary>
        </member>
        <member name="T:Neon.Cadence.CadenceSettings">
            <summary>
            Cadence client settings.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceSettings.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceSettings.#ctor(System.String[])">
            <summary>
            Constructs an instance with server URIs.
            </summary>
            <param name="servers">Specifies one or more server URIs.</param>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.Servers">
            <summary>
            One or more Cadence server URIs.
            </summary>
            <remarks>
            You must specify the URI for at least one operating Cadence node.  The Cadence
            client will use this to discover the remaining nodes.  It is a best practice to
            specify multiple nodes in a clustered environment to avoid initial connection
            problems if any single node is down.
            </remarks>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ListenPort">
            <summary>
            Optionally specifies the port where the client will listen for traffic from the 
            associated <b>cadence-proxy</b>.  This defaults to 0 which specifies that lets the 
            operating system choose an unused ephermal port.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.DefaultDomain">
            <summary>
            Specifies the default Cadence domain for this client.  This defaults to <c>null</c>.
            </summary>
            <remarks>
            <para>
            Specifying a default domain can be convienent for many scenarios, especially for those where
            the application workflows and activities are restricted to a single domain (which is pretty common).
            This defaults to <b>"default"</b>.
            </para>
            <para>
            The default domain can be overridden for workflow interfaces via <see cref="P:Neon.Cadence.WorkflowInterfaceAttribute.Domain"/>
            or for specific interface methods via <see cref="P:Neon.Cadence.WorkflowMethodAttribute.Domain"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.CreateDomain">
            <summary>
            <para>
            Optionally create the <see cref="P:Neon.Cadence.CadenceSettings.DefaultDomain"/> if it doesn't already exist.
            This defaults to <c>false</c>.
            </para>
            <note>
            Enabling this can be handy for unit testing where you'll likely be starting
            off with a virgin Cadence server when the test start.  We don't recommend
            enabling this for production services.  For production, you should explicitly
            create your domains with suitable setttings such has how long workflow histories
            are to be retained.
            </note>
            <note>
            If the default domain doesn't exist when <see cref="P:Neon.Cadence.CadenceSettings.CreateDomain"/><c>=true</c> when a
            connection is established, it will be initialized to retain workflow histories for
            up to <b>7 days</b>.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.DefaultTaskList">
            <summary>
            Specifies the default Cadence task list for this client.  This defaults to <c>null</c>.
            </summary>
            <remarks>
            <para>
            Specifying a default task list can be convienent for many scenarios, especially for those where
            the application workflows and activities are restricted to a single task list.
            </para>
            <para>
            The default task list can be overridden for workflow interfaces via <see cref="P:Neon.Cadence.WorkflowInterfaceAttribute.TaskList"/>
            or for specific interface methods via <see cref="P:Neon.Cadence.WorkflowMethodAttribute.TaskList"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ClientTimeoutSeconds">
            <summary>
            Optionally specifies the maximum time the client should wait for synchronous 
            operations to complete.  This defaults to <b>10 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ClientTimeout">
            <summary>
            Returns <see cref="P:Neon.Cadence.CadenceSettings.ClientTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ClientIdentity">
            <summary>
            Optionally identifies the client application establishing the connection so that
            Cadence may include this in its logs and metrics.  This defaults to <b>"unknown"</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.SecurityToken">
            <summary>
            <para>
            The Cadence cluster security token.  This defaults to <c>null</c>.
            </para>
            <note>
            This is not currently supported by the .NET Cadence client and should be
            left alone for now.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ProxyTimeoutSeconds">
            <summary>
            Optionally specifies the maximum time to allow the <b>cadence-proxy</b>
            to indicate that it has received a proxy request message by returning an
            OK response.  The proxy will be considered to be unhealthy when this 
            happens.  This defaults to <b>5 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ProxyTimeout">
            <summary>
            Returns <see cref="P:Neon.Cadence.CadenceSettings.ProxyTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.HeartbeatIntervalSeconds">
            <summary>
            Optionally specifies the interval at which heartbeats are transmitted to
            <b>cadence-proxy</b> as a health check.  This defaults to <b>5 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.HeartbeatInterval">
            <summary>
            Returns <see cref="P:Neon.Cadence.CadenceSettings.HeartbeatIntervalSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.HeartbeatTimeoutSeconds">
            <summary>
            Optionally specifies the maximum time to allow the <b>cadence-proxy</b>
            to respond to a heartbeat message.  The proxy will be considered to be 
            unhealthy when this happens.  This defaults to <b>5 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.HeartbeatTimeout">
            <summary>
            Returns <see cref="P:Neon.Cadence.CadenceSettings.HeartbeatTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ConnectRetries">
            <summary>
            Specifies the number of times to retry connecting to the Cadence cluster.  This defaults
            to <b>3</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ConnectRetryDelaySeconds">
            <summary>
            Specifies the number of seconds to delay between cluster connection attempts.
            This defaults to <b>5.0 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ConnectRetryDelay">
            <summary>
            Returns <see cref="P:Neon.Cadence.CadenceSettings.ConnectRetryDelaySeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.WorkflowStartToCloseTimeoutSeconds">
            <summary>
            Specifies the default maximum workflow execution time.  This defaults to <b>24 hours</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.WorkflowStartToCloseTimeout">
            <summary>
            Returns <see cref="P:Neon.Cadence.CadenceSettings.WorkflowStartToCloseTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.WorkflowScheduleToStartTimeoutSeconds">
            <summary>
            Specifies the default maximum time a workflow can wait between being scheduled
            and actually begin executing.  This defaults to <c>24 hours</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.WorkflowScheduleToStartTimeout">
            <summary>
            Returns <see cref="P:Neon.Cadence.CadenceSettings.WorkflowScheduleToStartTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.WorkflowDecisionTaskTimeoutSeconds">
            <summary>
            Specifies the default maximum time a workflow decision task may execute.
            This must be with the range of <b>1 &lt; value &lt;= 60</b> seconds.
            This defaults to <b>10 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.WorkflowDecisionTaskTimeout">
            <summary>
            Returns <see cref="P:Neon.Cadence.CadenceSettings.WorkflowDecisionTaskTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.WorkflowIdReusePolicy">
            <summary>
            Specifies what happens when Cadence workflows attempt to reuse workflow IDs.
            This defaults to <see cref="F:Neon.Cadence.WorkflowIdReusePolicy.AllowDuplicate"/>.
            Workflows can customize this via <see cref="T:Neon.Cadence.WorkflowOptions"/> or <see cref="T:Neon.Cadence.ChildWorkflowOptions"/>
            or by setting this in the <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/> tagging the 
            workflow entry point method
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ActivityScheduleToCloseTimeoutSeconds">
            <summary>
            Specifies the default maximum time an activity is allowed to wait after being
            scheduled until it's actually scheduled to execute on a worker.  This defaults
            to <b>24 hours</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ActivityScheduleToCloseTimeout">
            <summary>
            Returns <see cref="P:Neon.Cadence.CadenceSettings.ActivityScheduleToCloseTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ActivityStartToCloseTimeoutSeconds">
            <summary>
            Specifies the default maximum time an activity may run after being started.
            This defaults to <b>24</b> hours.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ActivityStartToCloseTimeout">
            <summary>
            Returns <see cref="P:Neon.Cadence.CadenceSettings.ActivityStartToCloseTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ActivityScheduleToStartTimeoutSeconds">
            <summary>
            Specifies the default maximum time an activity may wait to be started after being scheduled.
            This defaults to <b>24</b> hours.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ActivityScheduleToStartTimeout">
            <summary>
            Returns <see cref="P:Neon.Cadence.CadenceSettings.ActivityScheduleToStartTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ActivityHeartbeatTimeoutSeconds">
            <summary>
            Specifies the default maximum allowed between activity heartbeats.  Activities that
            don't submit heartbeats within the time will be considered to be unhealthy and will
            be terminated.  This defaults to <b>60 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.ActivityHeartbeatTimeout">
            <summary>
            Returns <see cref="P:Neon.Cadence.CadenceSettings.ActivityHeartbeatTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.MaxWorkflowDelaySeconds">
            <summary>
            <b>EXPERIMENTAL:</b> Specifies the maximum seconds that a workflow will be kept alive after
            the workflow method returns to handle any oustanding synchronous signal queries.  This defaults
            to <b>30.0 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.MaxWorkflowDelay">
            <summary>
            Returns <see cref="P:Neon.Cadence.CadenceSettings.MaxWorkflowDelaySeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.MaxWorkflowWaitUntilRunningSeconds">
            <summary>
            The default maximum time the <see cref="M:Neon.Cadence.CadenceClient.WaitForWorkflowStartAsync(Neon.Cadence.WorkflowExecution,System.String,System.Nullable{System.TimeSpan})"/> method
            will wait for a workflow to start.  This defaults to <b>30.0 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.MaxWorkflowWaitUntilRunning">
            <summary>
            Returns <see cref="P:Neon.Cadence.CadenceSettings.MaxWorkflowWaitUntilRunningSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.BinaryFolder">
            <summary>
            Optionally specifies the folder where the embedded <b>cadence-proxy</b> binary 
            will be written before starting it.  This defaults to <c>null</c> which specifies
            that the binary will be written to the same folder where the <b>Neon.Cadence</b>
            assembly resides.  This folder may not be writable by the current user so this
            allows you to specify an alternative folder.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.BinaryPath">
            <summary>
            <para>
            Optionally specifies the path to the <b>cadence-proxy</b> executable file.  This
            file must already be present on disk when a <see cref="T:Neon.Cadence.CadenceClient"/> connection
            is established and the appropriate execute permissions must be set for Linux and
            OS/X.  This property takes presidence over <see cref="P:Neon.Cadence.CadenceSettings.BinaryFolder"/> when set.
            </para>
            <para>
            This is useful for situations where the executable must be pre-provisioned for
            security.  One example is deploying Cadence workers to a Docker container with
            a read-only file system.
            </para>
            <note>
            You can use the <see cref="M:Neon.Cadence.CadenceClient.ExtractCadenceProxy(System.String)"/> method to extract
            the Windows, Linux, and OS/X builds of the <b>cadence-proxy</b> executable from
            the <b>Neon.Cadence</b> assembly.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.LogLevel">
            <summary>
            Optionally specifies the logging level for the associated <b>cadence-proxy</b>.
            This defaults to <see cref="F:Neon.Diagnostics.LogLevel.None"/> which will be appropriate for most
            production situations.  You may wish to set this to <see cref="F:Neon.Diagnostics.LogLevel.Info"/>
            or <see cref="F:Neon.Diagnostics.LogLevel.Debug"/> while debugging.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.LogCadence">
            <summary>
            Optionally specifies that messages from the embedded GOLANG Cadence client 
            will be included in the log output.  This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.LogCadenceProxy">
            <summary>
            Optionally specifies that messages from the internal <b>cadence-proxy</b>
            code that bridges between .NET and the embedded GOLANG Cadence client
            will be included in the log output.  This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.LogDuringReplay">
            <summary>
            Optionally enable workflow logging while the workflow is being
            replayed from history.  This should generally be enabled only
            while debugging.  This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.Debug">
            <summary>
            Optionally specifies that the connection should run in DEBUG mode.  This currently
            launches the <b>cadence-proxy</b> with a command window (on Windows only) to make 
            it easy to see any output it generates and also has <b>cadence-proxy</b>.  This
            defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.DebugPrelaunched">
            <summary>
            <b>INTERNAL USE ONLY:</b> Optionally indicates that the <b>cadence-proxy</b> will
            already be running for debugging purposes.  When this is <c>true</c>, the 
            <b>cadence-client</b> be hardcoded to listen on <b>127.0.0.1:5001</b> and
            the <b>cadence-proxy</b> will be assumed to be listening on <b>127.0.0.1:5000</b>.
            This defaults to <c>false.</c>
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.DebugDisableHeartbeats">
            <summary>
            <b>INTERNAL USE ONLY:</b> Optionally disable health heartbeats.  This can be
            useful while debugging the client but should never be set for production.
            This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.DebugDisableHandshakes">
            <summary>
            <b>INTERNAL USE ONLY:</b> Optionally indicates that the <b>cadence-client</b>
            will not perform the <see cref="T:Neon.Cadence.Internal.InitializeRequest"/>/<see cref="T:Neon.Cadence.Internal.InitializeReply"/>
            and <see cref="T:Neon.Cadence.Internal.TerminateRequest"/>/<see cref="T:Neon.Cadence.Internal.TerminateReply"/> handshakes 
            with the <b>cadence-proxy</b> for debugging purposes.  This defaults to
            <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.DebugIgnoreTimeouts">
            <summary>
            <b>INTERNAL USE ONLY:</b> Optionally ignore operation timeouts.  This can be
            useful while debugging the client but should never be set for production.
            This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.DebugIgnoreHeartbeats">
            <summary>
            <b>INTERNAL USE ONLY:</b> Optionally disables heartbeat handling by the
            emulated <b>cadence-proxy</b> for testing purposes.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceSettings.DebugHttpTimeout">
            <summary>
            <b>INTERNAL USE ONLY:</b> Optionally specifies the timeout to use for 
            HTTP requests made to the <b>cadence-proxy</b>.  This defaults to
            <b>5 seconds</b>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceSettings.Clone">
            <summary>
            Returns a copy of the current instance.
            </summary>
            <returns>The cloned <see cref="T:Neon.Cadence.CadenceSettings"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.ChildWorkflowFuture">
            <summary>
            Implements a child workflow future that returns <c>void</c>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowFuture.#ctor(Neon.Cadence.Workflow,Neon.Cadence.Internal.ChildExecution)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="childExecution">The child workflow execution.</param>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowFuture.Execution">
            <summary>
            Returns the workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowFuture.GetAsync">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.ChildWorkflowFuture`1">
            <summary>
            Implements a child workflow future that returns a value.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowFuture`1.#ctor(Neon.Cadence.Workflow,Neon.Cadence.Internal.ChildExecution)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="childExecution">The child workflow execution.</param>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowFuture`1.Execution">
            <summary>
            Returns the workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowFuture`1.GetAsync">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.ChildWorkflowFutureStub">
            <summary>
            <para>
            Manages starting and signalling a child workflow instance based on
            its workflow type name and arguments.  This is useful when you need
            to perform other operations in parallel with a child by separating
            workflow execution and retrieving the result into separate operations.
            </para>
            <para>
            Use this version for workflows that don't return a result.
            </para>
            </summary>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowFutureStub.#ctor(Neon.Cadence.Workflow,System.String,Neon.Cadence.ChildWorkflowOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowTypeName">The workflow type name.</param>
            <param name="options">Optional child workflow options.</param>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowFutureStub.Options">
            <summary>
            Returns the child workflow options.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowFutureStub.WorkflowTypeName">
            <summary>
            Returns the workflow type name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowFutureStub.Execution">
            <summary>
            Returns the child workflow <see cref="T:Neon.Cadence.WorkflowExecution"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the workflow has not been started.</exception>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowFutureStub.StartAsync(System.Object[])">
            <summary>
            Starts the child workflow, returning an <see cref="T:Neon.Tasks.IAsyncFuture"/> that can be used
            to wait for the workflow to complete.  This version doesn't return a workflow result.
            </summary>
            <param name="args">The workflow arguments.</param>
            <returns>An <see cref="T:Neon.Cadence.ChildWorkflowFuture"/> that can be used to retrieve the workflow result as an <c>object</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the child workflow has already been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow arguments.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowFutureStub.StartAsync``1(System.Object[])">
            <summary>
            Starts the child workflow, returning an <see cref="T:Neon.Tasks.IAsyncFuture"/> that can be used
            to wait for the the workflow to complete and obtain its result.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
            <param name="args">The workflow arguments.</param>
            <returns>An <see cref="T:Neon.Cadence.ChildWorkflowFuture`1"/> that can be used to retrieve the workflow result as an <c>object</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the child workflow has already been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow arguments.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowFutureStub.SignalAsync(System.String,System.Object[])">
            <summary>
            Signals the workflow.
            </summary>
            <param name="signalName">The signal name.</param>
            <param name="args">The signal arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the child workflow has not been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow signal arguments.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.UntypedChildWorkflowFutureStub`1">
            <summary>
            <para>
            Manages starting and signalling a child workflow instance based on
            its workflow type name and arguments.  This is useful when you need
            to perform other operations in parallel with a child.
            </para>
            <para>
            Use this version for workflows that return a result.
            </para>
            </summary>
            <typeparam name="TResult">Specifies the workflow result type.</typeparam>
        </member>
        <member name="M:Neon.Cadence.UntypedChildWorkflowFutureStub`1.#ctor(Neon.Cadence.Workflow,System.String,Neon.Cadence.ChildWorkflowOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowTypeName">The workflow type name.</param>
            <param name="options">Optional child workflow options.</param>
        </member>
        <member name="P:Neon.Cadence.UntypedChildWorkflowFutureStub`1.Options">
            <summary>
            Returns the child workflow options.
            </summary>
        </member>
        <member name="P:Neon.Cadence.UntypedChildWorkflowFutureStub`1.WorkflowTypeName">
            <summary>
            Returns the workflow type name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.UntypedChildWorkflowFutureStub`1.Execution">
            <summary>
            Returns the child workflow <see cref="T:Neon.Cadence.WorkflowExecution"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the workflow has not been started.</exception>
        </member>
        <member name="M:Neon.Cadence.UntypedChildWorkflowFutureStub`1.StartAsync(System.Object[])">
            <summary>
            Starts the child workflow, returning an <see cref="T:Neon.Cadence.ChildWorkflowFuture`1"/> that can be used
            to retrieve the workflow result.
            </summary>
            <param name="args">The workflow arguments.</param>
            <returns>An <see cref="T:Neon.Cadence.ChildWorkflowFuture`1"/> that can be used to retrieve the workflow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the child workflow has already been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters and 
            result type passed are compatible with the target workflow arguments.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.UntypedChildWorkflowFutureStub`1.SignalAsync(System.String,System.Object[])">
            <summary>
            Signals the workflow.
            </summary>
            <param name="signalName">The signal name.</param>
            <param name="args">The signal arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the child workflow has not been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow signal arguments.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.ChildWorkflowOptions">
            <summary>
            Specifies the options to use when executing a child workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowOptions.Normalize(Neon.Cadence.CadenceClient,Neon.Cadence.ChildWorkflowOptions,System.Type,System.Reflection.MethodInfo)">
            <summary>
            <b>INTERNAL USE ONLY:</b> Normalizes the options passed by creating or cloning a new 
            instance as required and filling unset properties using default client settings.
            </summary>
            <param name="client">The associated Cadence client.</param>
            <param name="options">The input options or <c>null</c>.</param>
            <param name="workflowInterface">Optionally specifies the workflow interface definition.</param>
            <param name="method">Optionally specifies the target workflow method.</param>
            <returns>The normalized options.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if a valid task list is not specified.</exception>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowOptions.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowOptions.Domain">
            <summary>
            Optionally specifies the target domain.  This defaults to the domain
            specified by <see cref="P:Neon.Cadence.WorkflowMethodAttribute.Domain"/>, 
            <see cref="P:Neon.Cadence.WorkflowInterfaceAttribute.Domain"/>, or 
            to the client's default domain as specified by <see cref="P:Neon.Cadence.CadenceSettings.DefaultDomain"/>
            (in that order of precedence).
            </summary>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowOptions.WorkflowId">
            <summary>
            Optionally specifies the workflow ID to assign to the child workflow.
            A UUID will be generated by default.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowOptions.TaskList">
            <summary>
            Optionally specifies the Cadence task list where the child workflow will be
            scheduled.  This defaults to the domain specified by <see cref="P:Neon.Cadence.WorkflowMethodAttribute.TaskList"/>
            or <see cref="P:Neon.Cadence.WorkflowInterfaceAttribute.TaskList"/>, or the parent workflow's
            domain, in that order of precedence.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowOptions.StartToCloseTimeout">
            <summary>
            Specifies the maximum time the child workflow may execute from start
            to finish.  This defaults to <see cref="P:Neon.Cadence.CadenceSettings.WorkflowStartToCloseTimeoutSeconds"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowOptions.ScheduleToStartTimeout">
            <summary>
            Optionally specifies the default maximum time a workflow can wait between being scheduled
            and actually begin executing.  This defaults to <c>24 hours</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowOptions.DecisionTaskTimeout">
            <summary>
            Optionally specifies the decision task timeout for the child workflow.
            This defaults to <see cref="P:Neon.Cadence.CadenceSettings.WorkflowDecisionTaskTimeout"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowOptions.ChildPolicy">
            <summary>
            Optionally specifies what happens to the child workflow when the parent is terminated.
            This defaults to <see cref="F:Neon.Cadence.ParentClosePolicy.RequestCancel"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowOptions.WaitUntilFinished">
            <summary>
            Optionally specifies whether to wait for the child workflow to finish for any
            reason including being: completed, failed, timedout, terminated, or canceled.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowOptions.WorkflowIdReusePolicy">
            <summary>
            Optionally determines how Cadence handles workflows that attempt to reuse workflow IDs.
            This generally defaults to <see cref="F:Neon.Cadence.WorkflowIdReusePolicy.AllowDuplicate"/>
            but the default can be customized via the <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/> tagging
            the workflow entry point method or <see cref="P:Neon.Cadence.CadenceSettings.WorkflowIdReusePolicy"/>
            (which also defaults to <see cref="F:Neon.Cadence.WorkflowIdReusePolicy.AllowDuplicate"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowOptions.RetryOptions">
            <summary>
            Optionally specifies retry options.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowOptions.CronSchedule">
            <summary>
            Optionally specifies a recurring schedule for the workflow.  This can be set to a string specifying
            the minute, hour, day of month, month, and day of week scheduling parameters using the standard Linux
            CRON format described here: <a href="https://en.wikipedia.org/wiki/Cron">https://en.wikipedia.org/wiki/Cron</a>
            </summary>
            <remarks>
            <para>
            Cadence accepts a CRON string formatted as a single line of text with 5 parameters separated by
            spaces.  The parameters specified the minute, hour, day of month, month, and day of week values:
            </para>
            <code>
            ┌───────────── minute (0 - 59)
            │ ┌───────────── hour (0 - 23)
            │ │ ┌───────────── day of the month (1 - 31)
            │ │ │ ┌───────────── month (1 - 12)
            │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)
            │ │ │ │ │
            │ │ │ │ │
            * * * * * 
            </code>
            <para>
            Each parameter may be set to one of:
            </para>
            <list type="table">
            <item>
                <term><b>*</b></term>
                <description>
                Matches any value.
                </description>
            </item>
            <item>
                <term><b>value</b></term>
                <description>
                Matches a specific integer value.
                </description>
            </item>
            <item>
                <term><b>first-last</b></term>
                <description>
                Matches a range of integer values (inclusive).
                </description>
            </item>
            <item>
                <term><b>value1,value2,...</b></term>
                <description>
                Matches a list of integer values.
                </description>
            </item>
            <item>
                <term><b>first/step</b></term>
                <description>
                Matches values starting at <b>first</b> and then succeeding incremented by <b>step</b>.
                </description>
            </item>
            </list>
            <para>
            You can use this handy CRON calculator to see how this works: <a href="https://crontab.guru">https://crontab.guru</a>
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowOptions.ToInternal">
            <summary>
            Converts this instance into the corresponding internal object.
            </summary>
            <returns>The equivalent <see cref="T:Neon.Cadence.Internal.InternalChildWorkflowOptions"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowOptions.Clone">
            <summary>
            Returns a shallow clone of the current instance.
            </summary>
            <returns>The cloned <see cref="T:Neon.Cadence.WorkflowOptions"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowOptions.ToWorkflowOptions">
            <summary>
            Used internally within generated workflow stubs to convert a <see cref="T:Neon.Cadence.ChildWorkflowOptions"/>
            instance into an equivalent <see cref="T:Neon.Cadence.WorkflowOptions"/> as a bit of a hack.
            </summary>
            <returns>The converted <see cref="T:Neon.Cadence.WorkflowOptions"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.ChildWorkflowStub`1">
            <summary>
            Used to execute a child workflow in parallel with other child workflows or activities.
            Instances are created via <see cref="M:Neon.Cadence.Workflow.NewChildWorkflowFutureStub``1(System.String,Neon.Cadence.ChildWorkflowOptions)"/>.
            </summary>
            <typeparam name="TWorkflowInterface">Specifies the workflow interface.</typeparam>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowStub`1.#ctor(Neon.Cadence.Workflow,System.String,Neon.Cadence.ChildWorkflowOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parentWorkflow">The associated parent workflow.</param>
            <param name="methodName">Identifies the target workflow method or <c>null</c> or empty.</param>
            <param name="options">The child workflow options or <c>null</c>.</param>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowStub`1.StartAsync``1(System.Object[])">
            <summary>
            Starts the target workflow that returns <typeparamref name="TResult"/>, passing any specified arguments.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
            <param name="args">The arguments to be passed to the workflow.</param>
            <returns>The <see cref="T:Neon.Cadence.ChildWorkflowFuture`1"/> with the <see cref="M:Neon.Cadence.ChildWorkflowFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a future stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target workflow parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Cadence.ChildWorkflowStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.ChildWorkflowStub`1.StartAsync(System.Object[])">
            <summary>
            Starts the target workflow that returns <c>void</c>, passing any specified arguments.
            </summary>
            <param name="args">The arguments to be passed to the workflow.</param>
            <returns>The <see cref="T:Neon.Cadence.ChildWorkflowFuture`1"/> with the <see cref="M:Neon.Cadence.ChildWorkflowFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a future stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target workflow parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Cadence.ChildWorkflowStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.Cadence.ChildWorkflowStub`1.Stub">
            <summary>
            <para>
            Returns the underlying <typeparamref name="TWorkflowInterface"/> stub for the child workflow.
            This includes all the workflow entrypoint, query and signal methods.
            </para>
            <note>
            The entrypoint methods won't work because the workflow will already be running but you can
            interact with the child workflow using any query and signal methods.       
            </note>
            </summary>
        </member>
        <member name="T:Neon.Cadence.ContinueAsNewOptions">
            <summary>
            Specifies the options to be used when continuing a workflow as a 
            new instance.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewOptions.ExecutionStartToCloseTimeout">
            <summary>
            Optionally overrides the current workflow's timeout for the restarted
            workflow when this value is greater than <see cref="F:System.TimeSpan.Zero"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewOptions.ScheduleToCloseTimeout">
            <summary>
            Optionally overrides the current workflow's timeout for the restarted
            workflow when this value is greater than <see cref="F:System.TimeSpan.Zero"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewOptions.ScheduleToStartTimeout">
            <summary>
            Optionally overrides the current workflow's timeout for the restarted
            workflow when this value is greater than <see cref="F:System.TimeSpan.Zero"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewOptions.TaskStartToCloseTimeout">
            <summary>
            Optionally overrides the current workflow's decision task timeout for 
            the restarted workflow when this value is greater than <see cref="F:System.TimeSpan.Zero"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewOptions.Workflow">
            <summary>
            Optionally overrides the name of the workflow to continue as new.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewOptions.TaskList">
            <summary>
            Optionally overrides the current workflow's task list when restarting.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewOptions.Domain">
            <summary>
            Optionally overrides the current workflow's domain when restarting.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewOptions.RetryOptions">
            <summary>
            Optionally overrides the current workflow's retry options when restarting.
            </summary>
        </member>
        <member name="T:Neon.Cadence.DomainConfiguration">
            <summary>
            Domain configuration options.
            </summary>
        </member>
        <member name="P:Neon.Cadence.DomainConfiguration.RetentionDays">
            <summary>
            The workflow history retention period in days.
            </summary>
        </member>
        <member name="P:Neon.Cadence.DomainConfiguration.EmitMetrics">
            <summary>
            Enables metrics for workflows and activities running in the domain.
            </summary>
        </member>
        <member name="T:Neon.Cadence.DomainDescription">
            <summary>
            Information returned by <see cref="M:Neon.Cadence.CadenceClient.DescribeDomainAsync(System.String)"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.DomainDescription.DomainInfo">
            <summary>
            The domain information.
            </summary>
        </member>
        <member name="P:Neon.Cadence.DomainDescription.Configuration">
            <summary>
            The domain configuration.
            </summary>
        </member>
        <member name="P:Neon.Cadence.DomainDescription.IsGlobalDomain">
            <summary>
            Indicates whether the domain is global.
            </summary>
        </member>
        <member name="T:Neon.Cadence.DomainInfo">
            <summary>
            Information about a Cadence domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.DomainInfo.Name">
            <summary>
            The domain name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.DomainInfo.Status">
            <summary>
            The domain status.
            </summary>
        </member>
        <member name="P:Neon.Cadence.DomainInfo.Description">
            <summary>
            Ths domain description.
            </summary>
        </member>
        <member name="P:Neon.Cadence.DomainInfo.OwnerEmail">
            <summary>
            The domain owner's email address.
            </summary>
        </member>
        <member name="T:Neon.Cadence.DomainListPage">
            <summary>
            Holds a page of domain information listed from Cadence.
            </summary>
        </member>
        <member name="P:Neon.Cadence.DomainListPage.Domains">
            <summary>
            Lists the domain information.
            </summary>
        </member>
        <member name="P:Neon.Cadence.DomainListPage.NextPageToken">
            <summary>
            Indicates that there's at least one more page of domain information
            to be returned from Cadence when this is not <c>null</c>.  Otherwise,
            this is an opaque token that may be passed to <see cref="M:Neon.Cadence.CadenceClient.ListDomainsAsync(System.Int32,System.Byte[])"/>
            to retrieve the next page of domain information.
            </summary>
        </member>
        <member name="T:Neon.Cadence.DomainStatus">
            <summary>
            Indicates a Cadence domain status.
            </summary>
        </member>
        <member name="F:Neon.Cadence.DomainStatus.Registered">
            <summary>
            The domain is registered and active.
            </summary>
        </member>
        <member name="F:Neon.Cadence.DomainStatus.Deprecated">
            <summary>
            The domain is closed for new workflows but will remain
            until already running workflows are completed and the
            history retention period for the last executed workflow
            has been satisified.
            </summary>
        </member>
        <member name="F:Neon.Cadence.DomainStatus.Deleted">
            <summary>
            The domain is deleted.
            </summary>
        </member>
        <member name="T:Neon.Cadence.AccessDeniedException">
            <summary>
            Thrown when an operation cannot be performed to access limits.
            </summary>
        </member>
        <member name="M:Neon.Cadence.AccessDeniedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.AccessDeniedException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.AccessDeniedException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.ActivityHeartbeatTimeoutException">
            <summary>
            Thrown when an activity did not send a timely heartbeat to Cadence.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityHeartbeatTimeoutException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.ActivityHeartbeatTimeoutException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.ActivityHeartbeatTimeoutException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.ActivityTypeException">
            <summary>
            Thrown when ak activity interface or implementation is not valid.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityTypeException.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityTypeException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="T:Neon.Cadence.ActivityWorkerStartedException">
            <summary>
            Thrown when an attempt is made to register an activity implementation after an
            activity worker has been started on a client.  You must register all implementations
            before starting a worker.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityWorkerStartedException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ActivityWorkerStartedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies the inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.ActivityWorkerStartedException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.BadRequestException">
            <summary>
            Thrown when a Cadence receives an invalid request.
            </summary>
        </member>
        <member name="M:Neon.Cadence.BadRequestException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.BadRequestException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.BadRequestException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.CadenceCustomException">
            <summary>
            Thrown when a Cadence <b>custom</b> error is encountered.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceCustomException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.CadenceCustomException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.CadenceException">
            <summary>
            Base class for all Cadence related exceptions.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies the inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.CadenceException.CadenceError">
            <summary>
            Returns the Cadence GOLANG client's error string corresponding to the
            exception or <c>null</c> when the exception does not map directly to a
            Cadence error string.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceException.CadenceErrorType">
            <summary>
            Returns the Cadence error type.
            </summary>
        </member>
        <member name="P:Neon.Cadence.CadenceException.Reason">
            <summary>
            The Cadence error reason used for specifying non-retryable errors
            within a <see cref="T:Neon.Cadence.RetryOptions"/> instance.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceException.ToCadenceError">
            <summary>
            Converts the exception into a <see cref="P:Neon.Cadence.CadenceException.CadenceError"/>.
            </summary>
            <returns>The <see cref="P:Neon.Cadence.CadenceException.CadenceError"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.CadenceGenericException">
            <summary>
            Thrown when a Cadence <b>generic</b> error is encountered.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceGenericException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.CadenceGenericException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.CadenceInternalException">
            <summary>
            Base class for Cadence exceptions that must not be caught and handled
            by workflow entry point methods.  The Cadence client must be allowed
            to handle these.
            </summary>
            <remarks>
            <para>
            If your workflow needs a general exception handler, you should include
            a <c>catch</c> clause that catches and rethrows any derived exceptions
            before your custom handler.  This will look something like:
            </para>
            <code language="c#">
            public class MyWorkflow
            {
                public Task Entrypoint()
                {
                    try
                    {
                        // Workflow implementation.
                    }
                    catch (CadenceInternalException)
                    {
                        // Rethrow so Cadence can handle these exceptions.        
            
                        throw;
                    }
                    catch (Exception e)
                    {
                        // Your exception handler.
                    }
                }
            }
            </code>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.CadencePanicException">
            <summary>
            Thrown when a Cadence <b>panic</b> error is encountered.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadencePanicException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.CadencePanicException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.CadenceTimeoutException">
            <summary>
            Indicates that a Cadence operation timed out.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CadenceTimeoutException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies the inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.CadenceTimeoutException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.CancellationAlreadyRequestedException">
            <summary>
            Thrown when attempting to cancel an operation that has already been cancelled.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CancellationAlreadyRequestedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.CancellationAlreadyRequestedException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.CancellationAlreadyRequestedException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.CancelledException">
            <summary>
            Thrown when a Cadence operation is cancelled.
            </summary>
        </member>
        <member name="M:Neon.Cadence.CancelledException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.CancelledException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.ClientVersionNotSupportedException">
            <summary>
            Thrown when the underlying GOLANG client version is not supported by the Cadence cluster.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ClientVersionNotSupportedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.ClientVersionNotSupportedException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.ClientVersionNotSupportedException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.ConnectException">
            <summary>
            Thrown when a Cadence connection could not be established.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ConnectException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies the inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.ConnectException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.ContinueAsNewException">
            <summary>
            <b>INTERNAL USE ONLY:</b> Thrown by <see cref="M:Neon.Cadence.Workflow.ContinueAsNewAsync(Neon.Cadence.ContinueAsNewOptions,System.Object[])"/>
            or <see cref="M:Neon.Cadence.Workflow.ContinueAsNewAsync(System.Object[])"/> as well as any continue-as-new stubs to be handled 
            internally by <see cref="T:Neon.Cadence.WorkflowBase"/>.
            </summary>
            <remarks>
            <para>
            If your workflow needs a general exception handler, you should include
            a <c>catch</c> clause that catches and rethrows any <see cref="T:Neon.Cadence.CadenceInternalException"/>
            derived exceptions before your custom handler.  This will look something like:
            </para>
            <code language="c#">
            public class MyWorkflow
            {
                public Task Entrypoint()
                {
                    try
                    {
                        // Workflow implementation.
                    }
                    catch (CadenceInternalException)
                    {
                        // Rethrow so Cadence can handle these exceptions.        
            
                        throw;
                    }
                    catch (Exception e)
                    {
                        // Your exception handler.
                    }
                }
            }
            </code>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.ContinueAsNewException.#ctor(System.Byte[],System.String,System.String,System.String,System.TimeSpan,System.TimeSpan,System.TimeSpan,System.TimeSpan,Neon.Cadence.RetryOptions)">
            <summary>
            Constructs an instance using explicit arguments.
            </summary>
            <param name="args">Optional arguments for the new execution.</param>
            <param name="workflow">Optional workflow for the new execution.</param>
            <param name="domain">Optional domain for the new execution.</param>
            <param name="taskList">Optional task list for the new execution.</param>
            <param name="startToCloseTimeout">Optional execution to start timeout for the new execution.</param>
            <param name="scheduleToCloseTimeout">Optional schedule to close timeout for the new execution.</param>
            <param name="scheduleToStartTimeout">Optional schedule to start timeout for the new execution.</param>
            <param name="decisionTaskTimeout">Optional decision task start to close timeout for the new execution.</param>
            <param name="retryOptions">Optional retry options for the new execution.</param>
        </member>
        <member name="M:Neon.Cadence.ContinueAsNewException.#ctor(System.Byte[],Neon.Cadence.ContinueAsNewOptions)">
            <summary>
            Constructs an instance using a <see cref="T:Neon.Cadence.ContinueAsNewOptions"/>.
            </summary>
            <param name="args">Arguments for the new execution (this may be <c>null)</c>).</param>
            <param name="options">Options for the new execution  (this may be <c>null</c>).</param>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewException.Args">
            <summary>
            Returns the arguments for the next workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewException.Workflow">
            <summary>
            Optionally overrides the name of the workflow to continue as new.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewException.Domain">
            <summary>
            Optionally specifies the new domain for the next workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewException.TaskList">
            <summary>
            Optionally specifies the new task list for the next workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewException.StartToCloseTimeout">
            <summary>
            Optionally specifies the new timeout for the next workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewException.ScheduleToCloseTimeout">
            <summary>
            Optionally specifies the new timeout for the next workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewException.ScheduleToStartTimeout">
            <summary>
            Optionally specifies the new timeout for the next workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewException.DecisionTaskTimeout">
            <summary>
            Optionally specifies the new decision task timeout for the next workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.ContinueAsNewException.RetryOptions">
            <summary>
            Optionally specifies the new retry options for the next workflow execution.
            </summary>
        </member>
        <member name="T:Neon.Cadence.DomainAlreadyExistsException">
            <summary>
            Thrown when a Cadence domain already exists.
            </summary>
        </member>
        <member name="M:Neon.Cadence.DomainAlreadyExistsException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.DomainAlreadyExistsException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.DomainAlreadyExistsException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.DomainNotActiveException">
            <summary>
            Thrown when a Cadence domain has been deprecated.
            </summary>
        </member>
        <member name="M:Neon.Cadence.DomainNotActiveException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.DomainNotActiveException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.DomainNotActiveException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.EntityNotExistsException">
            <summary>
            Thrown when a Cadence request references an entity that doesn't exist.
            </summary>
        </member>
        <member name="M:Neon.Cadence.EntityNotExistsException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.EntityNotExistsException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.EntityNotExistsException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.ForceReplayException">
            <summary>
            Thrown internally by <see cref="M:Neon.Cadence.Workflow.ForceReplayAsync"/> to be handled internally by
            <see cref="T:Neon.Cadence.WorkflowBase"/>.
            a workflow.
            </summary>
            <remarks>
            <para>
            If your workflow needs a general exception handler, you should include
            a <c>catch</c> clause that catches and rethrows any <see cref="T:Neon.Cadence.CadenceInternalException"/>
            derived exceptions before your custom handler.  This will look something like:
            </para>
            <code language="c#">
            public class MyWorkflow
            {
                public Task Entrypoint()
                {
                    try
                    {
                        // Workflow implementation.
                    }
                    catch (CadenceInternalException)
                    {
                        // Rethrow so Cadence can handle these exceptions.        
            
                        throw;
                    }
                    catch (Exception e)
                    {
                        // Your exception handler.
                    }
                }
            }
            </code>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.InternalServiceException">
            <summary>
            Thrown when a Cadence experienced an internal error.
            </summary>
        </member>
        <member name="M:Neon.Cadence.InternalServiceException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.InternalServiceException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.InternalServiceException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.LimitExceededException">
            <summary>
            Thrown when a Cadence workflow query failed.
            </summary>
        </member>
        <member name="M:Neon.Cadence.LimitExceededException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.LimitExceededException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.LimitExceededException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.QueryFailedException">
            <summary>
            Thrown when a Cadence workflow query failed.
            </summary>
        </member>
        <member name="M:Neon.Cadence.QueryFailedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.QueryFailedException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.QueryFailedException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.RetryTaskException">
            <summary>
            Thrown when a workflow task could not be retried.
            </summary>
        </member>
        <member name="M:Neon.Cadence.RetryTaskException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.RetryTaskException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.RetryTaskException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.ServiceBusyException">
            <summary>
            Thrown when the Cadence cluster is too busy to perform an operation.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ServiceBusyException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.ServiceBusyException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.ServiceBusyException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.StartToCloseTimeoutException">
            <summary>
            Thrown when a workflow or activity did not complete within the required time.
            </summary>
        </member>
        <member name="M:Neon.Cadence.StartToCloseTimeoutException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.StartToCloseTimeoutException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.StartToCloseTimeoutException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.StubCompilerException">
            <summary>
            Thrown when there's a problem compiling a workflow or activity stub.
            </summary>
        </member>
        <member name="M:Neon.Cadence.StubCompilerException.GetMessage(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic},System.String)">
            <summary>
            Converts compiler diagnostics into a string.
            </summary>
            <param name="diagnostics">The compiler diagnostics.</param>
            <param name="source">Optionally specifies the invalid source code.</param>
            <returns>The message string.</returns>
        </member>
        <member name="M:Neon.Cadence.StubCompilerException.#ctor(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic},System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="diagnostics">The compiler diagnostics.</param>
            <param name="source">Optionally specifies the invalid source code.</param>
        </member>
        <member name="T:Neon.Cadence.SyncSignalException">
            <summary>
            Thrown when a synchronous signal sent to a workflow fails.
            </summary>
        </member>
        <member name="M:Neon.Cadence.SyncSignalException.GetError(System.Exception)">
            <summary>
            Converts an exception into a string suitable for using to construct
            a <see cref="T:Neon.Cadence.SyncSignalException"/>.
            </summary>
            <param name="e">The exception.</param>
            <returns>The formatted error string.</returns>
        </member>
        <member name="M:Neon.Cadence.SyncSignalException.GetError``1(System.String)">
            <summary>
            Converts an exception type and message into a string suitable for using to construct
            a <see cref="T:Neon.Cadence.SyncSignalException"/>.
            </summary>
            <typeparam name="TException">The exception type.</typeparam>
            <param name="message">The error message.</param>
            <returns>The formatted error string.</returns>
        </member>
        <member name="M:Neon.Cadence.SyncSignalException.GetMessage(System.String)">
            <summary>
            Extracts the message from the error string.
            </summary>
            <param name="error">The error string.</param>
            <returns>The message.</returns>
        </member>
        <member name="M:Neon.Cadence.SyncSignalException.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="error">The error information as formatted by <see cref="M:Neon.Cadence.SyncSignalException.GetError(System.Exception)"/>.</param>
        </member>
        <member name="P:Neon.Cadence.SyncSignalException.ExceptionName">
            <summary>
            The fully qualified name of the exception thrown by the target signal method.
            </summary>
        </member>
        <member name="T:Neon.Cadence.TerminatedException">
            <summary>
            Thrown when a Cadence <b>terminated</b> error is encountered.
            </summary>
        </member>
        <member name="M:Neon.Cadence.TerminatedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.TerminatedException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.WaitForSignalReplyException">
            <summary>
            <para>
            <b>EXPERIMENTAL:</b> Thrown by workflow synchronous signal methods when the
            signal has been marshalled to the workflow method via a <see cref="T:Neon.Cadence.WorkflowQueue`1"/>
            and the workflow method will handle the signal reply.
            </para>
            <note>
            Synchronous signals are an experimental feature that will likely be replaced
            in the coming months by a new Cadence feature.
            </note>
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowExecutionAlreadyStartedException">
            <summary>
            Thrown when attempting to cancel an operation that has already been cancelled.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowExecutionAlreadyStartedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.WorkflowExecutionAlreadyStartedException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.WorkflowExecutionAlreadyStartedException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.WorkflowParallelOperationException">
            <summary>
            Thrown when an operation is requested on an executing workflow while 
            another operation is already pending.  Workflows cannot have multiple
            operations running in parallel because this will likely break 
            workflow determinism.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowParallelOperationException.#ctor(System.String[])">
            <summary>
            Consutuctor.
            </summary>
            <param name="otherStackTraces">
            Optionally specifies the stack traces for the other pending operations
            that triggered this exception.
            </param>
        </member>
        <member name="P:Neon.Cadence.WorkflowParallelOperationException.OtherStackTraces">
            <summary>
            Returns the stack traces for the other pending operations when <see cref="P:Neon.Cadence.CadenceSettings.Debug"/>
            is set to <c>true</c>.  You can use this to discover where the other pending operations that
            triggered this exception were initiated.  The current operation stack trace will be available
            as <see cref="P:System.Exception.StackTrace"/> property on this exception.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowQueueClosedException">
            <summary>
            Indicates that a Cadence <see cref="M:Neon.Cadence.WorkflowQueue`1.DequeueAsync(System.TimeSpan)"/> operation
            failed because the queue has been closed.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowQueueClosedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies the inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.WorkflowQueueClosedException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.WorkflowRunningException">
            <summary>
            Thrown when a workflow cannot be started because another workflow with
            the same ID is already running.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowRunningException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.WorkflowRunningException.CadenceError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.WorkflowRunningException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.WorkflowTypeException">
            <summary>
            Thrown when ak workflow interface or implementation is not valid.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowTypeException.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowTypeException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="T:Neon.Cadence.WorkflowWorkerStartedException">
            <summary>
            Thrown when an attempt is made to register a workflow implementation after an
            workflow worker has been started on a client.  You must register all implementations
            before starting a worker.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowWorkerStartedException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowWorkerStartedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies the inner exception.</param>
        </member>
        <member name="P:Neon.Cadence.WorkflowWorkerStartedException.CadenceErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.ExternalWorkflowFuture">
            <summary>
            Implements an external workflow future that returns <c>void</c>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ExternalWorkflowFuture.#ctor(Neon.Cadence.CadenceClient,Neon.Cadence.WorkflowExecution,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="client">The associated client.</param>
            <param name="execution">The workflow execution.</param>
            <param name="domain">Optionally specifies the target domain.  This defaults to the default client domain.</param>
        </member>
        <member name="P:Neon.Cadence.ExternalWorkflowFuture.Execution">
            <summary>
            Returns the workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ExternalWorkflowFuture.GetAsync">
            <summary>
            Waits for the workflow to complete.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.ExternalWorkflowFuture`1">
            <summary>
            Implements an external workflow future that returns a value.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
        </member>
        <member name="M:Neon.Cadence.ExternalWorkflowFuture`1.#ctor(Neon.Cadence.CadenceClient,Neon.Cadence.WorkflowExecution,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="client">The associated client.</param>
            <param name="execution">The workflow execution.</param>
            <param name="domain">Optionally specifies the target domain.  This defaults to the default client domain.</param>
        </member>
        <member name="P:Neon.Cadence.ExternalWorkflowFuture`1.Execution">
            <summary>
            Returns the workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ExternalWorkflowFuture`1.GetAsync">
            <summary>
            Waits for the workflow to complete.
            </summary>
            <returns>The workflow result.</returns>
        </member>
        <member name="T:Neon.Cadence.ExternalWorkflowStub">
            <summary>
            Supports signalling and cancelling any workflow.  This is useful when an
            external workflow interface type is not known at compile time or to manage 
            workflows written in another language.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ExternalWorkflowStub.ILocalOperations.CancelAsync(Neon.Cadence.WorkflowExecution)">
            <summary>
            Cancels the specified workflow.
            </summary>
            <param name="execution">The target workflow execution.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.ExternalWorkflowStub.ILocalOperations.GetResultAsync(Neon.Cadence.WorkflowExecution)">
            <summary>
            Waits for the specified workflow to complete.
            </summary>
            <param name="execution">The target workflow execution.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.ExternalWorkflowStub.ILocalOperations.GetResultBytesAsync(Neon.Cadence.WorkflowExecution)">
            <summary>
            Waits for the specified workflow to complete and then returns the
            workflow result.
            </summary>
            <param name="execution">The target workflow execution.</param>
            <returns>The workflow result.</returns>
        </member>
        <member name="M:Neon.Cadence.ExternalWorkflowStub.ILocalOperations.SignalAsync(Neon.Cadence.WorkflowExecution,System.String,System.Object[])">
            <summary>
            Signals the specified workflow.
            </summary>
            <param name="execution">The target workflow execution.</param>
            <param name="signalName">The signal name.</param>
            <param name="args">The signal arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.ExternalWorkflowStub.#ctor(Neon.Cadence.CadenceClient,Neon.Cadence.WorkflowExecution,System.String)">
            <summary>
            Internal constructor for use outside of a workflow.
            </summary>
            <param name="client">Specifies the associated client.</param>
            <param name="execution">Specifies the target workflow execution.</param>
            <param name="domain">Optionally specifies the target domain (defaults to the client's default domain).</param>
        </member>
        <member name="M:Neon.Cadence.ExternalWorkflowStub.#ctor(Neon.Cadence.Workflow,Neon.Cadence.WorkflowExecution,System.String)">
            <summary>
            Internal constructor for use within a workflow.
            </summary>
            <param name="parentWorkflow">Specifies the parent workflow.</param>
            <param name="execution">Specifies the target workflow execution.</param>
            <param name="domain">Optionally specifies the target domain (defaults to the client's default domain).</param>
        </member>
        <member name="P:Neon.Cadence.ExternalWorkflowStub.Execution">
            <summary>
            Returns the workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ExternalWorkflowStub.CancelAsync">
            <summary>
            Cancels the workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.ExternalWorkflowStub.SignalAsync(System.String,System.Object[])">
            <summary>
            Signals the workflow.
            </summary>
            <param name="signalName">Specifies the signal name.</param>
            <param name="args">Specifies the signal arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.ExternalWorkflowStub.GetResultAsync">
            <summary>
            Waits for the workflow complete if necessary, without returning the result.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.ExternalWorkflowStub.GetResultAsync``1">
            <summary>
            Returns the workflow result, waiting for the workflow to complete if necessary.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
            <returns>The workflow result.</returns>
        </member>
        <member name="T:Neon.Cadence.IActivity">
            <summary>
            All activity interfaces must derive from this interface.
            </summary>
        </member>
        <member name="T:Neon.Cadence.IDataConverter">
            <summary>
            Used by <see cref="T:Neon.Cadence.Worker"/> instances to manage serialization of method parameters and results
            for workflow and activity methods to/from byte arrays for persistence in the Cadence cluster
            database.
            </summary>
        </member>
        <member name="M:Neon.Cadence.IDataConverter.FromData``1(System.Byte[])">
            <summary>
            Deserializes a single value from a byte array as the specified generic type parameter.
            </summary>
            <typeparam name="T">Specifies the result type.</typeparam>
            <param name="content">The input bytes.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:Neon.Cadence.IDataConverter.FromData(System.Type,System.Byte[])">
            <summary>
            Deserializes a single value from a byte array as the specified type.
            </summary>
            <param name="type">The result type.</param>
            <param name="content">The input bytes.</param>
            <returns>The deserialized value returned as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.IDataConverter.FromDataArray(System.Byte[],System.Type[])">
            <summary>
            Deserializes an array of values from a byte array.
            </summary>
            <param name="content">The input bytes.</param>
            <param name="valueTypes">Specifies the expected number of array elements and their types.</param>
            <returns>The deserialized values.</returns>
        </member>
        <member name="M:Neon.Cadence.IDataConverter.ToData(System.Object)">
            <summary>
            Serializes a value into a byte array
            </summary>
            <param name="value">The value being serialized.</param>
            <returns>The serialized bytes.</returns>
        </member>
        <member name="M:Neon.Cadence.IDataConverter.ToDataArray(System.Object[])">
            <summary>
            Serializes an array of values into a byte array.  This is typically
            used to serialize arguments passed to workflow and acrivity methods.
            </summary>
            <param name="values">The values being serialized (or <c>null</c>).</param>
            <returns>The serialized bytes.</returns>
        </member>
        <member name="T:Neon.Cadence.InternalBadBinaries">
            <summary>
            $todojefflill): Don't know what this is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.InternalBadBinaries.Binaries">
            <summary>
            $todojefflill): Don't know what this is.
            </summary>
        </member>
        <member name="T:Neon.Cadence.IWorkflow">
            <summary>
            All workflow interfaces must derive from this interface.
            </summary>
        </member>
        <member name="T:Neon.Cadence.JsonDataConverter">
            <summary>
            <para>
            Implements <see cref="T:Neon.Cadence.IDataConverter"/> by serializing data to/from
            UTF-8 encoded JSON text.
            </para>
            <note>
            This converter uses the Newtonsoft <a href="https://www.newtonsoft.com/json">JSON.NET</a>
            package so you can decorate your data types with attributes such as <c>[JsonProperty]</c>,
            <c>[JsonIgnore]</c>,... to control how your data is serialized.
            </note>
            <note>
            This implementation also supports values that implement <see cref="T:Neon.Data.IRoundtripData"/> to make
            it easier to manage data schema changes. 
            </note>
            </summary>
        </member>
        <member name="P:Neon.Cadence.JsonDataConverter.Instance">
            <summary>
            Returns a global <see cref="T:Neon.Cadence.JsonDataConverter"/> instance.  This is used
            internally by <b>Neon.Cadence</b> library.
            </summary>
        </member>
        <member name="M:Neon.Cadence.JsonDataConverter.FromData``1(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.JsonDataConverter.FromData(System.Type,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.JsonDataConverter.FromDataArray(System.Byte[],System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.JsonDataConverter.ToData(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.JsonDataConverter.ToDataArray(System.Object[])">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.LocalActivityFutureStub`2">
            <summary>
            Used to execute a local activity in parallel with other activities or child workflows.
            Instances are created via <see cref="M:Neon.Cadence.Workflow.NewLocalActivityStub``2(Neon.Cadence.LocalActivityOptions)"/>.
            </summary>
            <typeparam name="TActivityInterface">Specifies the activity interface.</typeparam>
            <typeparam name="TActivityImplementation">Specifies the local activity implementation class.</typeparam> 
        </member>
        <member name="T:Neon.Cadence.LocalActivityFutureStub`2.AsyncFuture">
            <summary>
            Implements the activity future that returns <c>void</c>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.LocalActivityFutureStub`2.AsyncFuture.#ctor(Neon.Cadence.Workflow,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="activityId">The workflow local activity ID.</param>
        </member>
        <member name="M:Neon.Cadence.LocalActivityFutureStub`2.AsyncFuture.GetAsync">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Cadence.LocalActivityFutureStub`2.AsyncFuture`1">
            <summary>
            Implements an activity future that returns a value.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
        </member>
        <member name="M:Neon.Cadence.LocalActivityFutureStub`2.AsyncFuture`1.#ctor(Neon.Cadence.Workflow,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="activityId">The workflow local activity ID.</param>
        </member>
        <member name="M:Neon.Cadence.LocalActivityFutureStub`2.AsyncFuture`1.GetAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cadence.LocalActivityFutureStub`2.#ctor(Neon.Cadence.Workflow,System.String,Neon.Cadence.LocalActivityOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parentWorkflow">The associated parent workflow.</param>
            <param name="methodName">
            Optionally identifies the target activity method by the name specified in
            the <c>[ActivityMethod]</c> attribute tagging the method.  Pass a <c>null</c>
            or empty string to specify the default method.
            </param>
            <param name="options">The activity options or <c>null</c>.</param>
        </member>
        <member name="M:Neon.Cadence.LocalActivityFutureStub`2.StartAsync``1(System.Object[])">
            <summary>
            Starts the target activity that returns <c>void</c>, passing the specified arguments.
            </summary>
            <typeparam name="TResult">The local activity result type.</typeparam>
            <param name="args">The arguments to be passed to the activity.</param>
            <returns>The <see cref="T:Neon.Tasks.IAsyncFuture`1"/> with the <see cref="M:Neon.Tasks.IAsyncFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target activity parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Cadence.ActivityFutureStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.LocalActivityFutureStub`2.StartAsync(System.Object[])">
            <summary>
            Starts the target activity that returns <c>void</c>, passing the specified arguments.
            </summary>
            <param name="args">The arguments to be passed to the activity.</param>
            <returns>The <see cref="T:Neon.Tasks.IAsyncFuture`1"/> with the <see cref="M:Neon.Tasks.IAsyncFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target activity parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Cadence.ActivityFutureStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.LocalActivityOptions">
            <summary>
            Specifies options used when running a local workflow activity.
            </summary>
        </member>
        <member name="M:Neon.Cadence.LocalActivityOptions.Normalize(Neon.Cadence.CadenceClient,Neon.Cadence.LocalActivityOptions)">
            <summary>
            Normalizes the options passed by creating or cloning a new instance as
            required and filling unset properties using default client settings.
            </summary>
            <param name="client">The associated Cadence client.</param>
            <param name="options">The input options or <c>null</c>.</param>
            <returns>The normalized options.</returns>
        </member>
        <member name="M:Neon.Cadence.LocalActivityOptions.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.LocalActivityOptions.ScheduleToCloseTimeout">
            <summary>
            Optionally specifies the maximum time the activity can run.
            </summary>
        </member>
        <member name="P:Neon.Cadence.LocalActivityOptions.RetryOptions">
            <summary>
            The activity retry options.
            </summary>
        </member>
        <member name="M:Neon.Cadence.LocalActivityOptions.ToInternal">
            <summary>
            Converts this instance into the corresponding internal object.
            </summary>
            <returns>The equivalent <see cref="T:Neon.Cadence.Internal.InternalLocalActivityOptions"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.LocalActivityOptions.Clone">
            <summary>
            Returns a shallow copy of the instance.
            </summary>
            <returns>The cloned <see cref="T:Neon.Cadence.LocalActivityOptions"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.NamespaceDoc">
            <summary>
            This namespace defines the Neon .NET client for the Uber Cadence workflow service.
            </summary>
        </member>
        <member name="T:Neon.Cadence.NonDeterministicPolicy">
            <summary>
            Enumerates how a decision task handler deals with mismatched history events 
            (presumably arising from non-deterministic workflow definitions). 
            </summary>
        </member>
        <member name="F:Neon.Cadence.NonDeterministicPolicy.BlockWorkflow">
            <summary>
            This policy logs an error to the console but does not reply to the server.  This is
            the default policy.
            </summary>
        </member>
        <member name="F:Neon.Cadence.NonDeterministicPolicy.FailWorkflow">
            <summary>
            This policy signals Cadence to fail the workflow.
            </summary>
        </member>
        <member name="T:Neon.Cadence.NonRetriableErrors">
            <summary>
            Used in conjunction with <see cref="T:Neon.Cadence.RetryOptions"/> to specify errors that
            <b>will not</b> cause a workflow related operation to be retried.
            </summary>
        </member>
        <member name="M:Neon.Cadence.NonRetriableErrors.Custom(System.String)">
            <summary>
            Returns the non-retriable error string for a <b>custom error</b>.
            </summary>
            <param name="reason">The reason string.</param>
            <returns>The error string.</returns>
        </member>
        <member name="M:Neon.Cadence.NonRetriableErrors.Panic">
            <summary>
            Returns the non-retriable error string for a <b>panic error</b>.
            </summary>
            <returns>The error string.</returns>
        </member>
        <member name="M:Neon.Cadence.NonRetriableErrors.Generic">
            <summary>
            Returns the non-retriable error string for a <b>generic error</b>.
            </summary>
            <returns>The error string.</returns>
        </member>
        <member name="M:Neon.Cadence.NonRetriableErrors.StartToCloseTimeout">
            <summary>
            Returns the non-retriable error string for a <b>start-to-close timeout</b>.
            </summary>
            <returns>The error string.</returns>
        </member>
        <member name="M:Neon.Cadence.NonRetriableErrors.HeartbeatTimeout">
            <summary>
            Returns the non-retriable error string for a <b>heartbeat timeout</b>.
            </summary>
            <returns>The error string.</returns>
        </member>
        <member name="T:Neon.Cadence.ParentClosePolicy">
            <summary>
            Enumerates the possible child workflow behaviors when the parent
            workflow is closed.
            </summary>
        </member>
        <member name="F:Neon.Cadence.ParentClosePolicy.Terminate">
            <summary>
            All open child workflows will be terminated when parent workflow is closed.
            </summary>
        </member>
        <member name="F:Neon.Cadence.ParentClosePolicy.RequestCancel">
            <summary>
            Cancel requests will be sent to all open child workflows to all open child 
            workflows when parent workflow is closed.    This is the <b>default policy</b>.
            </summary>
        </member>
        <member name="F:Neon.Cadence.ParentClosePolicy.Abandon">
            <summary>
            Child workflow execution will continue unaffected when parent workflow is closed,
            essentially becoming orphaned.
            </summary>
        </member>
        <member name="T:Neon.Cadence.PendingActivityInfo">
            <summary>
            Describes the current state of a scheduled or executing activity.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingActivityInfo.Client">
            <summary>
            The associated Cadence client.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingActivityInfo.ActivityID">
            <summary>
            The activity ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingActivityInfo.Name">
            <summary>
            Identifies the activity type.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingActivityInfo.Status">
            <summary>
            The activity state.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingActivityInfo.HeartbeatDetails">
            <summary>
            Details from the last activity heartbeart.
            </summary>
        </member>
        <member name="M:Neon.Cadence.PendingActivityInfo.GetHeartbeatDetails``1">
            <summary>
            Returns the <see cref="P:Neon.Cadence.PendingActivityInfo.HeartbeatDetails"/> converted to <typeparamref name="TResult"/>
            using the client <see cref="T:Neon.Cadence.IDataConverter"/>.
            </summary>
            <typeparam name="TResult">The result type.</typeparam>
            <returns>The heartbeat details as a<typeparamref name="TResult"/>.</returns>
        </member>
        <member name="P:Neon.Cadence.PendingActivityInfo.LastHeartbeatTimeUtc">
            <summary>
            Time when the last activity heartbeat was received.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingActivityInfo.LastStartedTimeUtc">
            <summary>
            Time when the activity was most recently started.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingActivityInfo.Attempt">
            <summary>
            The number of times the activity has been started/restarted.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingActivityInfo.MaximumAttempts">
            <summary>
            The maximum times the activity may be started.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingActivityInfo.ScheduledTimeUtc">
            <summary>
            Time when the activity is scheduled to run.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingActivityInfo.ExpirationTimeUtc">
            <summary>
            Time when the activity must complete.
            </summary>
        </member>
        <member name="T:Neon.Cadence.PendingChildExecutionInfo">
            <summary>
            Decribes the current state of a pending; child workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.PendingChildExecutionInfo.#ctor">
            <summary>
            Internal constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingChildExecutionInfo.WorkflowId">
            <summary>
            Returns the workflow ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingChildExecutionInfo.RunId">
            <summary>
            Returns the workflow run ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingChildExecutionInfo.WorkflowTypeName">
            <summary>
            Returns the workflow type name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingChildExecutionInfo.InitatedId">
            <summary>
            $todo(jefflill): Don't know what this is.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PendingChildExecutionInfo.ParentClosePolicy">
            <summary>
            Returns policy used to close this child when its parent is closed.
            </summary>
        </member>
        <member name="T:Neon.Cadence.PollerInfo">
            <summary>
            Describes the status of a poller (AKA worker) listening to a task list.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PollerInfo.LastAccessTime">
            <summary>
            The last time the poller accessed Cadence (UTC).
            </summary>
        </member>
        <member name="P:Neon.Cadence.PollerInfo.Identity">
            <summary>
            Identifies the poller.
            </summary>
        </member>
        <member name="P:Neon.Cadence.PollerInfo.RatePerSecond">
            <summary>
            Operations per second from the poller.
            </summary>
        </member>
        <member name="T:Neon.Cadence.QueryMethodAttribute">
            <summary>
            Used to identify a workflow interface method as a query.
            </summary>
        </member>
        <member name="M:Neon.Cadence.QueryMethodAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">Specifies the Cadence query type.</param>
        </member>
        <member name="P:Neon.Cadence.QueryMethodAttribute.Name">
            <summary>
            Returns the query name. 
            </summary>
        </member>
        <member name="T:Neon.Cadence.RetryOptions">
            <summary>
            Describes a Cadence retry policy.
            </summary>
        </member>
        <member name="M:Neon.Cadence.RetryOptions.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.RetryOptions.#ctor(Neon.Retry.LinearRetryPolicy)">
            <summary>
            Constructs an instance from a <see cref="T:Neon.Retry.LinearRetryPolicy"/>.
            </summary>
            <param name="policy">The policy.</param>
        </member>
        <member name="M:Neon.Cadence.RetryOptions.#ctor(Neon.Retry.ExponentialRetryPolicy)">
            <summary>
            Constructs an instance from a <see cref="T:Neon.Retry.ExponentialRetryPolicy"/>,
            </summary>
            <param name="policy">The policy.</param>
        </member>
        <member name="P:Neon.Cadence.RetryOptions.InitialInterval">
            <summary>
            Specifies the backoff interval for the first retry.  If coefficient is 1.0 then
            it is used for all retries.  Required, no default value.
            </summary>
        </member>
        <member name="P:Neon.Cadence.RetryOptions.BackoffCoefficient">
            <summary>
            Specifies the coefficient used to calculate the next retry backoff interval.  
            The next retry interval is previous interval multiplied by this coefficient. 
            This must be 1 or larger. Default is 2.0.
            </summary>
        </member>
        <member name="P:Neon.Cadence.RetryOptions.MaximumInterval">
            <summary>
            Specifies the maximim retry interval.  Retries intervals will start at <see cref="P:Neon.Cadence.RetryOptions.InitialInterval"/>
            and then be multiplied by <see cref="P:Neon.Cadence.RetryOptions.BackoffCoefficient"/> for each retry attempt until the
            interval reaches or exceeds <see cref="P:Neon.Cadence.RetryOptions.MaximumInterval"/>, at which point point each
            retry will use <see cref="P:Neon.Cadence.RetryOptions.MaximumInterval"/> for all subsequent attempts.
            </summary>
        </member>
        <member name="P:Neon.Cadence.RetryOptions.ExpirationInterval">
            <summary>
            Maximum time to retry.  Either <see cref="P:Neon.Cadence.RetryOptions.ExpirationInterval"/> or <see cref="P:Neon.Cadence.RetryOptions.MaximumAttempts"/> is 
            required.  Retries will stop when this is exceeded even if maximum retries is not been reached.
            </summary>
        </member>
        <member name="P:Neon.Cadence.RetryOptions.MaximumAttempts">
            <summary>
            Maximum number of attempts.  When exceeded the retries stop.  If not set or set to 0, it means 
            unlimited, and the policy will rely on <see cref="P:Neon.Cadence.RetryOptions.ExpirationInterval"/> to decide when to stop
            retrying.  Either <see cref="P:Neon.Cadence.RetryOptions.MaximumAttempts"/> or <see cref="P:Neon.Cadence.RetryOptions.MaximumInterval"/>"/> is required.
            </summary>
        </member>
        <member name="P:Neon.Cadence.RetryOptions.NonRetriableErrors">
            <summary>
            <para>
            Specifies Cadence errors that <b>should not</b> trigger a retry. This is optional.  Cadence server 
            will stop retrying if error reason matches this list.  Use the <see cref="T:Neon.Cadence.NonRetriableErrors"/>
            class methods to initialize this list as required.
            </para>
            <note>
            Cancellation is not a failure, so that won't be retried.
            </note>
            </summary>
            <remarks>
            <para>
            You can specify non-retryable error reasons directly here or use the <see cref="M:Neon.Cadence.RetryOptions.DoNotRetry(System.String)"/> method
            to append a specific reason string or <see cref="M:Neon.Cadence.RetryOptions.DoNotRetry``1"/> to specify the error reason for an
            exception type.
            </para>
            <para>
            We recommend that you use <see cref="M:Neon.Cadence.RetryOptions.DoNotRetry``1"/> most of the time and reserve
            <see cref="M:Neon.Cadence.RetryOptions.DoNotRetry(System.String)"/> for interop situations where you need to integrate 
            with something written in another language.
            </para>
            <para>
            For native Cadence exceptions like <see cref="T:Neon.Cadence.CadenceTimeoutException"/>, <see cref="M:Neon.Cadence.RetryOptions.DoNotRetry``1"/> is smart
            enough to append the proper error reason.  For other exception types, this method will use the fully qualified
            exception type name as the reason.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.RetryOptions.DoNotRetry``1">
            <summary>
            <para>
            Appends the error reason corresponding to an exception type.  For built-in Cadence exceptions, this
            will append the apporpriate reason string and for other exception type, this will append the fully
            qualified exception type name.
            </para>
            <note>
            We generally recommend that you use <see cref="M:Neon.Cadence.RetryOptions.DoNotRetry``1"/> by default and
            reserve this for situations where you need to specify a specific reason, probably for interoperating
            with workflows and activities written in other lanagues, etc.
            </note>
            </summary>
            <typeparam name="ExceptionType">The exception type.</typeparam>
        </member>
        <member name="M:Neon.Cadence.RetryOptions.DoNotRetry(System.String)">
            <summary>
            <para>
            Appends the string passed to <see cref="P:Neon.Cadence.RetryOptions.NonRetriableErrors"/> as a reason not to be retried.
            </para>
            <note>
            We generally recommend that you use <see cref="M:Neon.Cadence.RetryOptions.DoNotRetry``1"/> by default and
            reserve this for situations where you need to specify a specific reason, probably for interoperating
            with workflows and activities written in other lanagues, etc.
            </note>
            </summary>
            <param name="reason">The reason string.</param>
        </member>
        <member name="M:Neon.Cadence.RetryOptions.ToInternal">
            <summary>
            Converts the instance into an <see cref="T:Neon.Cadence.Internal.InternalRetryPolicy"/>.
            </summary>
            <returns>The converted instance.</returns>
        </member>
        <member name="T:Neon.Cadence.SignalMethodAttribute">
            <summary>
            Used to identify a workflow interface methods as a signal.
            </summary>
        </member>
        <member name="M:Neon.Cadence.SignalMethodAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">Specifies the Cadence signal name.</param>
        </member>
        <member name="P:Neon.Cadence.SignalMethodAttribute.Name">
            <summary>
            Returns the signal name. 
            </summary>
        </member>
        <member name="P:Neon.Cadence.SignalMethodAttribute.Synchronous">
            <summary>
            <para>
            <b>EXPERIMENTAL:</b> Indicates whether the tagged signal method should be generated 
            as a synchronous method rather than as a fire-and-forget asynchronous call, which is
            the Cadence default.  This property defaults to <c>false</c>.
            </para>
            <note>
            Synchronous signals are considered experimental which means that this feature will 
            probably have a limited lifespan.  Cadence will introduce new <b>update</b>
            semantics at some point that will ultimately obsolete synchronous signals.
            </note>
            </summary>
            <remarks>
            <para>
            Normal Cadence signals are sent to workflows asynchronously.  This means that the
            signal method being called by the application will return ragardless of whether the
            workflow has actually received and processed the signal or not.  This is quite
            efficient and has the advantage of not requring the sending application to wait
            for a somewhat indeterminate period of time for the workflow to receive and process
            the signal.
            </para>
            <para>
            Sometimes though, you calling applications really need to know that the workflow
            actually handled a signal before moving on.  Applications may also need information
            back from the workflow, such as whether the workflow was able to process the signal
            request sucessfully.  So it would be nice if workflow signals could also return a
            result.
            </para>
            <para>
            The Neon Cadence client supports synchronous signals by setting this property to
            <c>true</c>.  When you do this, the Cadence client allows the signal method to
            return a result as a <see cref="T:System.Threading.Tasks.Task`1"/> as well returning just a simple
            <see cref="T:System.Threading.Tasks.Task"/>.  For both cases, the Cadence client will generate a signal
            stub that waits for the signal to be processed by the target workflow before
            returning.
            </para>
            <para>
            This is an experimental feature.  Cadence server doesn't currently have a 
            synchronous way to interact with a running workflow, so the Neon Cadence client emulates
            this behavior using a combination of internal signals and queries.  As a developer, 
            you couild have done something like this yourself, but we felt this was going to be 
            such a useful  pattern that it was worth building into the client.  This will ultimately
            be replaced by upcoming Cadence server features.
            </para>
            <para>
            See the documentation site for more information: <a href="https://doc.neonkube.com/Neon.Cadence-Workflow-SyncSignals.htm">Synchronous Signals</a>
            </para>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.SignalRequest">
            <summary>
            <para>
            <b>EXPERIMENTAL:</b> Used to relay a received synchronous signal's 
            arguments to the workflow logic via a <see cref="T:Neon.Cadence.WorkflowQueue`1"/> allowing
            the workflow handle the signal by executing activities, child workflows, etc.
            This class also provides a way for the workflow to specify the signal reply. 
            </para>
            <para>
            This non-generic version of the class is intended for signals that return <c>void</c>.
            Use <see cref="T:Neon.Cadence.SignalRequest`1"/> for signals that return a result.
            </para>
            <note>
            This synchronous signals are considered experimental which means that this feature will 
            probably have a limited lifespan.  Cadence will introduce new <b>update</b>
            semantics at some point that will ultimately obsolete synchronous signals.
            </note>
            </summary>
            <remarks>
            <para>
            The <see cref="P:Neon.Cadence.SignalRequest.Args"/> property returns a dictionary that is intialized with the
            signal arguments keyed by parameter name.  Your signal method should queue this
            request to a workflow queue your workflow logic is listening on and then return
            from your signal method.
            </para>
            <para>
            Your workflow logic will dequeue the signal request, extract the signal arguments 
            cast them to the appropriate types, and then perform any necessary operations.
            Then call <see cref="M:Neon.Cadence.SignalRequest.ReplyAsync"/> which indicates that signal processing
            is finished.
            </para>
            <para>
            See the documentation site for more information: <a href="https://doc.neonkube.com/Neon.Cadence-Workflow-SynchronousSignals.htm">Synchronous Signals</a>
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.SignalRequest.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.SignalRequest.SignalId">
            <summary>
            Uniquely identifies the signal.
            </summary>
        </member>
        <member name="P:Neon.Cadence.SignalRequest.SignalStatus">
            <summary>
            Returns the signal status for this signal request.
            </summary>
        </member>
        <member name="P:Neon.Cadence.SignalRequest.Args">
            <summary>
            Returns the dictionary holding the signal arguments keyed by parameter name.  You can
            access the arguments here, casting the <see cref="T:System.Object"/> values as required or
            you can use the generic <see cref="M:Neon.Cadence.SignalRequest.Arg``1(System.String)"/> method, which is a bit nicer.
            </summary>
        </member>
        <member name="M:Neon.Cadence.SignalRequest.Arg``1(System.String)">
            <summary>
            Returns the named argument cast into the specified type.
            </summary>
            <typeparam name="T">The argument type.</typeparam>
            <param name="name">The argument name.</param>
            <returns>The argument value cast to <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.SignalRequest.ReplyAsync">
            <summary>
            Called by your workflow logic to indicate that processing for the synchronous
            signal is complete.  This method also waits for a period of time before
            returning to help ensure that the signal result can be delivered back to
            the calling client before the workflow terminates.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.SignalRequest`1">
            <summary>
            <para>
            <b>EXPERIMENTAL:</b> Used to relay a received synchronous signal's 
            arguments to the workflow logic via a <see cref="T:Neon.Cadence.WorkflowQueue`1"/> allowing
            the workflow handle the signal by executing activities, child workflows, etc.
            This class also provides a way for the workflow to specify the signal reply. 
            </para>
            <para>
            This generic version of the class is intended for signals that return results.
            Use <see cref="T:Neon.Cadence.SignalRequest"/> for signals that return <c>void</c>.
            </para>
            <note>
            This synchronous signals are considered experimental which means that this feature will 
            probably have a limited lifespan.  Cadence will introduce new <b>update</b>
            semantics at some point that will ultimately obsolete synchronous signals.
            </note>
            </summary>
            <typeparam name="TResult">The signal result type.</typeparam>
            <remarks>
            <para>
            The <see cref="P:Neon.Cadence.SignalRequest`1.Args"/> property returns a dictionary that is intialized with the
            signal arguments keyed by parameter name.  Your signal method should queue this
            request to a workflow queue your workflow logic is listening on and then return
            from the signal method.  The value your return will be ignore in this case and
            the actual value returned to the calling client will be specified by your workflow
            logic via a <see cref="M:Neon.Cadence.SignalRequest`1.ReplyAsync(`0)"/> call.
            </para>
            <para>
            Your workflow logic will dequeue the signal request, extract the signal arguments,
            casting them to the appropriate types, and then perform any necessary operations
            before calling <see cref="M:Neon.Cadence.SignalRequest`1.ReplyAsync(`0)"/> which indicates that signal processing
            is finished was well as specifying the value to be returned as the signal result.
            </para>
            <para>
            See the documentation site for more information: <a href="https://doc.neonkube.com/Neon.Cadence-Workflow-SynchronousSignals.htm">Synchronous Signals</a>
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.SignalRequest`1.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.SignalRequest`1.SignalId">
            <summary>
            Uniquely identifies the signal.
            </summary>
        </member>
        <member name="P:Neon.Cadence.SignalRequest`1.SignalStatus">
            <summary>
            Returns the signal status for this signal request.
            </summary>
        </member>
        <member name="P:Neon.Cadence.SignalRequest`1.Args">
            <summary>
            Returns the dictionary holding the signal arguments keyed by parameter name.  You can
            access the arguments here, casting the <see cref="T:System.Object"/> values as required or
            you can use the generic <see cref="M:Neon.Cadence.SignalRequest`1.Arg``1(System.String)"/> method, which is a bit nicer.
            </summary>
        </member>
        <member name="M:Neon.Cadence.SignalRequest`1.Arg``1(System.String)">
            <summary>
            Returns the named argument cast into the specified type.
            </summary>
            <typeparam name="T">The argument type.</typeparam>
            <param name="name">The argument name.</param>
            <returns>The argument value cast to <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.SignalRequest`1.ReplyAsync(`0)">
            <summary>
            Called by your workflow logic to indicate that processing for the synchronous
            signal is complete as well as specifying the signal result.
            </summary>
            <param name="result">The value to be returned by the signal.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.TaskListDescription">
            <summary>
            Describes the current status of a Cadence task list.
            </summary>
        </member>
        <member name="P:Neon.Cadence.TaskListDescription.Pollers">
            <summary>
            Lists the pollers (AKA workers) that have communicated with the Cadence cluster over
            the past few minutes.
            </summary>
        </member>
        <member name="T:Neon.Cadence.TaskListKind">
            <summary>
            Enumerates the different kinds of task lists.
            </summary>
        </member>
        <member name="F:Neon.Cadence.TaskListKind.Normal">
            <summary>
            Normal.
            </summary>
        </member>
        <member name="F:Neon.Cadence.TaskListKind.Sticky">
            <summary>
            Sticky.
            </summary>
        </member>
        <member name="T:Neon.Cadence.TaskListType">
            <summary>
            Used to distinguish between decision (AKA workflow) and activity task lists.
            </summary>
        </member>
        <member name="F:Neon.Cadence.TaskListType.Decision">
            <summary>
            Identifies decision (AKA workflow) task lists.
            </summary>
        </member>
        <member name="F:Neon.Cadence.TaskListType.Activity">
            <summary>
            Identifies activity task lists.
            </summary>
        </member>
        <member name="T:Neon.Cadence.UpdateDomainInfo">
            <summary>
            Holds the changes to be made to a Cadence domain's basic properties.
            </summary>
        </member>
        <member name="P:Neon.Cadence.UpdateDomainInfo.Description">
            <summary>
            The updated domain description.
            </summary>
        </member>
        <member name="P:Neon.Cadence.UpdateDomainInfo.OwnerEmail">
            <summary>
            The updated domain owner's email address.
            </summary>
        </member>
        <member name="T:Neon.Cadence.UpdateDomainRequest">
            <summary>
            Holds the changes to be made to a Cadence domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.UpdateDomainRequest.Name">
            <summary>
            The domain name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.UpdateDomainRequest.DomainInfo">
            <summary>
            The updated basic domain properties.
            </summary>
        </member>
        <member name="P:Neon.Cadence.UpdateDomainRequest.Options">
            <summary>
            The updated domain options.
            </summary>
        </member>
        <member name="T:Neon.Cadence.Worker">
            <summary>
            Manages a Cadence activity/workflow worker.
            </summary>
            <remarks>
            <para>
            Cadence doesn't appear to support starting, stopping, and then restarting the same
            worker within an individual Cadence client so this class will prevent this.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Worker.#ctor(Neon.Cadence.CadenceClient,Neon.Cadence.WorkerMode,System.Int64,System.String,System.String)">
            <summary>
            Internal constructor.
            </summary>
            <param name="client">The parent client.</param>
            <param name="mode">Identifies whether the worker will process activities, workflows, or both.</param>
            <param name="workerId">The ID of the worker as tracked by the <b>cadence-proxy</b>.</param>
            <param name="domain">The Cadence domain where the worker is registered.</param>
            <param name="taskList">The Cadence task list.</param>
        </member>
        <member name="M:Neon.Cadence.Worker.Dispose">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Cadence.Worker.Client">
            <summary>
            Returns the parent Cadence client.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Worker.IsDisposed">
            <summary>
            Indicates whether the worker has been fully disposed.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Worker.Mode">
            <summary>
            Identifies whether the worker will process activities, workflows, or both.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Worker.WorkerId">
            <summary>
            Returns the ID of the worker as tracked by the <b>cadence-proxy</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Worker.Domain">
            <summary>
            Returns the Cadence domain where the worker is registered.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Worker.Tasklist">
            <summary>
            Returns the Cadence task list.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Worker.RefCount">
            <summary>
            Returns the current worker reference count.  This will be set to
            <b>0</b> the first time the worker is registered.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkerArgs">
            <summary>
            Holds the opaque arguments passed to <see cref="T:Neon.Cadence.WorkflowBase"/> and <see cref="T:Neon.Cadence.ActivityBase"/>
            implementations by the <see cref="T:Neon.Cadence.CadenceClient"/> when the workflow or activity is 
            executed on a worker.  This must be passed to the base <see cref="T:Neon.Cadence.WorkflowBase"/> or
            <see cref="T:Neon.Cadence.ActivityBase"/> class constructors.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerArgs.Client">
            <summary>
            The parent <see cref="T:Neon.Cadence.CadenceClient"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerArgs.ContextId">
            <summary>
            The ID used to reference the corresponding Cadence context managed by
            the <b>cadence-proxy</b>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkerMode">
            <summary>
            Enumerates the possible worker modes.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkerMode.Unspecified">
            <summary>
            THe worker mode has not been specified.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkerMode.Activity">
            <summary>
            The worker processes activities.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkerMode.Workflow">
            <summary>
            The worker processes workflows.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkerMode.Both">
            <summary>
            The worker processes both activities and workflows.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkerOptions">
            <summary>
            Specifies the options Cadence will use when assigning workflow and activity
            executions to a user worker service.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.MaxConcurrentActivityExecutionSize">
            <summary>
            Optionally sets set the maximum concurrent activity executions this worker can have.
            The zero value of this uses the default value.  Defaults to <b>1000</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.WorkerActivitiesPerSecond">
            <summary>
            <para>
            Optionally sets the rate limiting on number of activities that can be executed per second per
            worker. This can be used to limit resources used by the worker.
            </para>
            <note>
            Notice that the number is represented in float, so that you can set it to less than
            1 if needed. For example, set the number to 0.1 means you want your activity to be executed
            once for every 10 seconds. This can be used to protect down stream services from flooding.
            The zero value of this uses the default value..
            </note>
            <para>
            This defaults to <b>100,000</b>.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.MaxConcurrentLocalActivityExecutionSize">
            <summary>
            Optionally sets the maximum concurrent local activity executions this worker can have.
            The zero value of this uses the default value.  This defaults to <b>1000</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.WorkerLocalActivitiesPerSecond">
            <summary>
            <para>
            Optionally sets the rate limiting on number of local activities that can be executed per second per
            worker. This can be used to limit resources used by the worker.
            </para>
            <note>
            Notice that the number is represented in float, so that you can set it to less than
            1 if needed. For example, set the number to 0.1 means you want your local activity to be executed
            once for every 10 seconds. This can be used to protect down stream services from flooding.
            The zero value of this uses the default value.
            </note>
            <para>
            This defaults to <b>100,000</b>.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.TaskListActivitiesPerSecond">
            <summary>
            <para>
            Optionally sets the rate limiting on number of activities that can be executed per second.
            This is managed by the server and controls activities per second for your entire task list
            whereas WorkerActivityTasksPerSecond controls activities only per worker.
            </para>
            <note>
            Notice that the number is represented in float, so that you can set it to less than
            1 if needed. For example, set the number to 0.1 means you want your activity to be executed
            once for every 10 seconds. This can be used to protect down stream services from flooding.
            </note>
            <para>
            The zero value of this uses the default value. This defaults to <b>100,000</b>.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.MaxConcurrentDecisionTaskExecutionSize">
            <summary>
            Optionally sets the maximum concurrent decision task executions this worker can have.
            The zero value of this uses the default value.  This defaults to <b>100,000</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.WorkerDecisionTasksPerSecond">
            <summary>
            Optionally stes the rate limiting on number of decision tasks that can be executed per
            second per worker. This can be used to limit resources used by the worker.
            The zero value of this uses the default value.  This defaults to <b>1000</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.Identity">
            <summary>
            Optionally sets an identify that can be used to track this host for debugging.
            This defaults to include the hostname, groupName and process ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.EnableLoggingInReplay">
            <summary>
            Optionally enables logging in replay.  This defaults to <c>false</c>.
            </summary>
            <remarks>
            In the workflow code you can use workflow.GetLogger(ctx) to write logs. By default, the logger will skip log
            entry during replay mode so you won't see duplicate logs. This option will enable the logging in replay mode.
            This is only useful for debugging purpose.
            </remarks>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.DisableWorkflowWorker">
            <summary>
            Optionally disable workflow processing on the worker.  This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.DisableActivityWorker">
            <summary>
            Optionally disable activity processing on the worker.  This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.Mode">
            <summary>
            Returns the worker mode.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.DisableStickyExecution">
            <summary>
            Optionally disables sticky execution.  This defaults to <c>false</c>.
            </summary>
            <remarks>
            This is an optimization for workflow execution. When sticky execution is enabled, the worker can maintain
            workflow state and history making workflow replaying faster.
            </remarks>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.StickyScheduleToStartTimeout">
            <summary>
            Optionally sets the sticky schedule to start timeout.  Defaults to <b>5 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.NonDeterministicWorkflowPolicy">
            <summary>
            Optionally sets how decision workers deals with non-deterministic history events,
            presumably arising from non-deterministic workflow definitions or non-backward compatible workflow definition changes.
            This defaults to <see cref="F:Neon.Cadence.NonDeterministicPolicy.BlockWorkflow"/> which 
            just logs error and does not fail the workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkerOptions.WorkerStopTimeout">
            <summary>
            Optionally sets the graceful shutdown timeout.  Defaults to <see cref="F:System.TimeSpan.Zero"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkerOptions.ToInternal">
            <summary>
            Converts the instance into an <see cref="T:Neon.Cadence.Internal.InternalWorkerOptions"/>.
            </summary>
            <returns>The converted instance.</returns>
        </member>
        <member name="T:Neon.Cadence.Workflow">
            <summary>
            Provides useful information and functionality for workflow implementations.
            This will be available via the <see cref="P:Neon.Cadence.WorkflowBase.Workflow"/> property.
            </summary>
        </member>
        <member name="F:Neon.Cadence.Workflow.DefaultVersion">
            <summary>
            The default workflow version returned by <see cref="M:Neon.Cadence.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/> 
            when a version has not been set yet.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Workflow.Current">
            <summary>
            Returns the <see cref="T:Neon.Cadence.Workflow"/> information for the worflow executing within the
            current asynchronous flow or <c>null</c> if the current code is not executing within
            the context of a workflow.  This property use an internal <see cref="T:System.Threading.AsyncLocal`1"/>
            to manage this state.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Workflow.#ctor(Neon.Cadence.WorkflowBase,Neon.Cadence.CadenceClient,System.Int64,System.String,System.String,System.String,System.String,System.String,System.Boolean,Neon.Cadence.WorkflowMethodMap)">
            <summary>
            Constructor.
            </summary>
            <param name="parent">The parent workflow instance.</param>
            <param name="client">The associated client.</param>
            <param name="contextId">The workflow's context ID.</param>
            <param name="workflowTypeName">The workflow type name.</param>
            <param name="domain">The hosting domain.</param>
            <param name="taskList">The hosting task list.</param>
            <param name="workflowId">The workflow ID.</param>
            <param name="runId">The current workflow run ID.</param>
            <param name="isReplaying">Indicates whether the workflow is currently replaying from histor.</param>
            <param name="methodMap">Maps the workflow signal and query methods.</param>
        </member>
        <member name="P:Neon.Cadence.Workflow.WorkflowBase">
            <summary>
            Returns the parent <see cref="T:Neon.Cadence.WorkflowBase"/> implementation.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Workflow.ContextId">
            <summary>
            Returns the workflow's context ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Workflow.Client">
            <summary>
            Returns the <see cref="T:Neon.Cadence.CadenceClient"/> managing this workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Workflow.Logger">
            <summary>
            Returns the logger to be used for logging workflow related events.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Workflow.WorkflowInfo">
            <summary>
            Returns information about the running workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Workflow.MethodMap">
            <summary>
            Returns the workflow types method map.
            </summary>
        </member>
        <member name="P:Neon.Cadence.Workflow.IdToLocalActivityAction">
            <summary>
            Returns the dictionary mapping the IDs to local activity actions
            (the target activity type and method).
            </summary>
        </member>
        <member name="P:Neon.Cadence.Workflow.SignalId">
            <summary>
            Returns the unique ID of the signal being called on the current task.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Workflow.GetNextActivityId">
            <summary>
            Returns the next available workflow local activity ID.
            </summary>
            <returns>The nextr ID.</returns>
        </member>
        <member name="P:Neon.Cadence.Workflow.IsReplaying">
            <summary>
            <para>
            Indicates whether the workflow code is being replayed.
            </para>
            <note>
            <b>WARNING:</b> Never have workflow logic depend on this flag as doing so will
            break determinism.  The only reasonable uses for this flag are for managing
            external things like logging or metric reporting.
            </note>
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="P:Neon.Cadence.Workflow.Execution">
            <summary>
            Returns the execution information for the current workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.Workflow.GetSignalStatus(System.String)">
            <summary>
            Returns the <see cref="T:Neon.Cadence.Internal.SyncSignalStatus"/> information for the specified
            signal ID, adding a status record if one doesn't already exist.
            </summary>
            <param name="signalId">The unique signal ID.</param>
            <returns>The <see cref="T:Neon.Cadence.Internal.SyncSignalStatus"/> for the signal.</returns>
        </member>
        <member name="M:Neon.Cadence.Workflow.SetStackTrace(System.Int32)">
            <summary>
            Handles saving the current stack trace to the parent <see cref="P:Neon.Cadence.WorkflowBase.StackTrace"/>
            property so this will be available for the internal stack trace query.
            </summary>
            <param name="skipFrames">
            The number of frames to skip.  This defaults to 2 such that this method's
            stack frame will be skipped along with the caller (presumably one the public
            methods in this class.
            </param>
        </member>
        <member name="M:Neon.Cadence.Workflow.ExecuteNonParallel``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Executes a Cadence workflow related operation, trying to detect
            when an attempt is made to perform more than one operation in 
            parallel, which will likely break workflow determinism.
            </summary>
            <typeparam name="TResult">The operation result type.</typeparam>
            <param name="actionAsync">The workflow action function.</param>
            <returns>The action result.</returns>
            <remarks>
            <note>
            This method performs the parallel check only when executing within
            the context of a workflow entry point method.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.UpdateReplay``1(``0)">
            <summary>
            Updates the workflow's <see cref="P:Neon.Cadence.Workflow.IsReplaying"/> state to match the
            state specified in the reply from cadence-proxy.
            </summary>
            <typeparam name="TReply">The reply message type.</typeparam>
            <param name="reply">The reply message.</param>
        </member>
        <member name="M:Neon.Cadence.Workflow.UtcNowAsync">
            <summary>
            <para>
            Returns the current workflow time (UTC).
            </para>
            <note>
            This must used instead of calling <see cref="P:System.DateTime.UtcNow"/> or any other
            time method to guarantee determinism when a workflow is replayed.
            </note>
            </summary>
            <returns>The current workflow time.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Cadence.Workflow.ContinueAsNewAsync(System.Object[])">
            <summary>
            Continues the current workflow as a new run using the same workflow options.
            </summary>
            <param name="args">The new run arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Cadence.Workflow.ContinueAsNewAsync(Neon.Cadence.ContinueAsNewOptions,System.Object[])">
            <summary>
            Continues the current workflow as a new run allowing the specification of
            new workflow options.
            </summary>
            <param name="options">The continuation options.</param>
            <param name="args">The new run arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Cadence.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)">
            <summary>
            Used to implement backwards compatible changes to a workflow implementation.
            </summary>
            <param name="changeId">Identifies the change.</param>
            <param name="minSupported">
            Specifies the minimum supported version.  You may pass <see cref="F:Neon.Cadence.Workflow.DefaultVersion"/> <b>(-1)</b>
            which will be set as the version for workflows that haven't been versioned yet.
            </param>
            <param name="maxSupported">Specifies the maximum supported version.</param>
            <returns>The workflow implementation version.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            It is possible to upgrade workflow implementation with workflows in flight using
            the <see cref="M:Neon.Cadence.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/> method.  The essential requirement
            is that the new implementation must execute the same logic for the decision steps
            that have already been executed and recorded to the history fo a previous workflow 
            to maintain workflow determinism.  Subsequent unexecuted steps, are free to implement
            different logic.
            </para>
            <note>
            Cadence attempts to detect when replaying workflow performs actions that are different
            from those recorded as history and will fail the workflow when this occurs.
            </note>
            <para>
            Upgraded workflows will use <see cref="M:Neon.Cadence.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/> to indicate
            where upgraded logic has been inserted into the workflow.  You'll pass a <b>changeId</b>
            string that identifies the change being made.  This can be anything you wish as long as
            it's not empty and is unique for each change made to the workflow.  You'll also pass
            <b>minSupported</b> and <b>maxSupported</b> integers.  <b>minSupported</b> specifies the 
            minimum version of the workflow implementation that will be allowed to continue to
            run.  Workflows start out with their version set to <see cref="F:Neon.Cadence.Workflow.DefaultVersion"/>
            or <b>(-1)</b> and this will often be passed as <b>minSupported</b> such that upgraded
            workflow implementations will be able to take over newly scheduled workflows.  
            <b>maxSupported</b> essentially specifies the current (latest) version of the workflow 
            implementation. 
            </para>
            <para>
            When <see cref="M:Neon.Cadence.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/> called and is not being replayed
            from the workflow history, the method will record the <b>changeId</b> and <b>maxSupported</b>
            values to the workflow history.  When this is being replayed, the method will simply
            return the <b>maxSupported</b> value from the history.  Let's go through an example demonstrating
            how this can be used.  Let's say we start out with a simple two step workflow that 
            first calls <b>ActivityA</b> and then calls <b>ActivityB</b>:
            </para>
            <code lang="C#">
            public class MyWorkflow : WorkflowBase
            {
                public async Task DoSomething()
                {
                    var activities = Workflow.NewActivityStub&lt;MyActivities&gt;();
            
                    await activities.ActivityAAsync();  
                    await activities.ActivityBAsync();  
                }
            }
            </code>
            <para>
            Now, let's assume that we need to replace the call to <b>ActivityA</b> with a call to
            <b>ActivityC</b>.  If there is no chance of any instances of <B>MyWorkflow</B> still
            being in flight, you could simply redepoy the recoded workflow:
            </para>
            <code lang="C#">
            public class MyWorkflow : WorkflowBase
            {
                public async Task&lt;byte[]&gt; RunAsync(byte[] args)
                {
                    var activities = Workflow.NewActivityStub&lt;MyActivities&gt;();
            
                    await activities.ActivityCAsync();  
                    await activities.ActivityBAsync();
                }
            }
            </code>
            <para>
            But, if instances of this workflow may be in flight you'll need to deploy a backwards
            compatible workflow implementation that handles workflows that have already executed 
            <b>ActivityA</b> but haven't yet executed <b>ActivityB</b>.  You can accomplish this
            via:
            </para>
            <code lang="C#">
            public class MyWorkflow : WorkflowBase
            {
                public async Task&lt;byte[]&gt; RunAsync(byte[] args)
                {
                    var activities = Workflow.NewActivityStub&lt;MyActivities&gt;();
                    var version    = await GetVersionAsync("Replace ActivityA", DefaultVersion, 1);    
            
                    switch (version)
                    {
                        case DefaultVersion:
                        
                            await activities.ActivityAAsync();  
                            break;
                            
                        case 1:
                        
                            await activities.ActivityCAsync();  // &lt;-- change
                            break;
                    }
                    
                    await activities.ActivityBAsync();  
                }
            }
            </code>
            <para>
            This upgraded workflow calls <see cref="M:Neon.Cadence.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/> passing
            <b>minSupported=DefaultVersion</b> and <b>maxSupported=1</b>  For workflow instances
            that have already executed <b>ActivityA</b>, <see cref="M:Neon.Cadence.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/>
            will return <see cref="F:Neon.Cadence.Workflow.DefaultVersion"/> and we'll call <b>ActivityA</b>, which will match
            what was recorded in the history.  For workflows that have not yet executed <b>ActivityA</b>,
            <see cref="M:Neon.Cadence.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/> will return <b>1</b>, which we'll use as
            the indication that we can call <b>ActivityC</b>.
            </para>
            <para>
            Now, lets say we need to upgrade the workflow again and change the call for <b>ActivityB</b>
            to <b>ActivityD</b>, but only for workflows that have also executed <b>ActivityC</b>.  This 
            would look something like:
            </para>
            <code lang="C#">
            public class MyWorkflow : WorkflowBase
            {
                public async Task&lt;byte[]&gt; RunAsync(byte[] args)
                {
                    var activities = Workflow.NewActivityStub&lt;MyActivities&gt;();
                    var version    = await GetVersionAsync("Replace ActivityA", DefaultVersion, 1);    
            
                    switch (version)
                    {
                        case DefaultVersion:
                        
                            await activities.ActivityAAsync();  
                            break;
                            
                        case 1:
                        
                            await activities.ActivityCAsync();  // &lt;-- change
                            break;
                    }
                    
                    version = await GetVersionAsync("Replace ActivityB", 1, 2);    
            
                    switch (version)
                    {
                        case DefaultVersion:
                        case 1:
                        
                            await activities.ActivityBAsync();
                            break;
                            
                        case 2:
                        
                            await activities.ActivityDAsync();  // &lt;-- change
                            break;
                    }
                }
            }
            </code>
            <para>
            Notice that the second <see cref="M:Neon.Cadence.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/> call passed a different
            change ID and also that the version range is now <b>1..2</b>.  The version returned will be
            <see cref="F:Neon.Cadence.Workflow.DefaultVersion"/> or <b>1</b> if <b>ActivityA</b> and <b>ActivityB</b> were 
            recorded in the history or <b>2</b> if <b>ActivityC</b> was called.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.GetWorkflowExecutionAsync(System.Object)">
            <summary>
            Returns the <see cref="T:Neon.Cadence.WorkflowExecution"/> for a child workflow created via
            <see cref="M:Neon.Cadence.Workflow.NewChildWorkflowStub``1(Neon.Cadence.ChildWorkflowOptions,System.String)"/>
            or <see cref="M:Neon.Cadence.Workflow.NewExternalWorkflowStub(System.String,System.String)"/>.
            </summary>
            <param name="stub">The child workflow stub.</param>
            <returns>The <see cref="T:Neon.Cadence.WorkflowExecution"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if the stub has not been started.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Cadence.Workflow.MutableSideEffectAsync``1(System.String,System.Func{``0})">
            <summary>
            Calls the specified function and then searches the workflow history
            to see if a value was already recorded with the specified <paramref name="id"/>.
            If no value has been recorded for the <paramref name="id"/> or the
            value returned by the function will be recorded, replacing any existing
            value.  If the function value is the same as the history value, then
            nothing will be recorded.
            </summary>
            <typeparam name="T">Specifies the result type.</typeparam>
            <param name="id">Identifies the value in the workflow history.</param>
            <param name="function">The side effect function.</param>
            <returns>The latest value persisted to the workflow history.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            This is similar to what you could do with a local activity but is
            a bit easier since you don't need to declare the activity and create
            a stub to call it and it's also more efficient because it avoids
            recording the same value multiple times in the history.
            </para>
            <note>
            The function must return within the configured decision task timeout 
            and should avoid throwing exceptions.
            </note>
            <note>
            The function passed should avoid throwing exceptions.  When an exception
            is thrown, this method will catch it and simply return the default 
            value for <typeparamref name="T"/>.
            </note>
            <note>
            <para>
            The .NET version of this method currently works a bit differently than
            the Java and GOLANG clients which will only call the function once.
            The .NET implementation calls the function every time 
            <see cref="M:Neon.Cadence.Workflow.MutableSideEffectAsync``1(System.String,System.Func{``0})"/>
            is called but it will ignore the all but the first call's result.
            </para>
            <para>
            This is an artifact of how the .NET client is currently implemented
            and may change in the future.  You should take care not to code your
            application to depend on this behavior (one way or the other).
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.MutableSideEffectAsync(System.Type,System.String,System.Func{System.Object})">
            <summary>
            <para>
            Calls the specified function and then searches the workflow history
            to see if a value was already recorded with the specified <paramref name="id"/>.
            If no value has been recorded for the <paramref name="id"/> or the
            value returned by the function will be recorded, replacing any existing
            value.  If the function value is the same as the history value, then
            nothing will be recorded.
            </para>
            <para>
            This version of the method uses a parameter to specify the expected
            result type.
            </para>
            </summary>
            <param name="resultType">Specifies the result type.</param>
            <param name="id">Identifies the value in the workflow history.</param>
            <param name="function">The side effect function.</param>
            <returns>The latest value persisted to the workflow history.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            This is similar to what you could do with a local activity but is
            a bit easier since you don't need to declare the activity and create
            a stub to call it and it's also more efficient because it avoids
            recording the same value multiple times in the history.
            </para>
            <note>
            The function must return within the configured decision task timeout 
            and should avoid throwing exceptions.
            </note>
            <note>
            The function passed should avoid throwing exceptions.  When an exception
            is thrown, this method will catch it and simply return <c>null</c>.
            </note>
            <note>
            <para>
            The .NET version of this method currently works a bit differently than
            the Java and GOLANG clients which will only call the function once.
            The .NET implementation calls the function every time 
            <see cref="M:Neon.Cadence.Workflow.MutableSideEffectAsync(System.Type,System.String,System.Func{System.Object})"/>
            is called but it will ignore the all but the first call's result.
            </para>
            <para>
            This is an artifact of how the .NET client is currently implemented
            and may change in the future.  You should take care not to code your
            application to depend on this behavior (one way or the other).
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewGuidAsync">
            <summary>
            <para>
            Returns a replay safe <see cref="T:System.Guid"/>.
            </para>
            <note>
            This must be used instead of calling <see cref="M:System.Guid.NewGuid"/>
            to guarantee determinism when a workflow is replayed.
            </note>
            </summary>
            <returns>The new <see cref="T:System.Guid"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Cadence.Workflow.NextRandomDoubleAsync">
            <summary>
            <para>
            Returns a replay safe random non-negative integer greater than or equal to a minimum value
            less than a maximum value that is greater than or equal to 0.0 and less than 1.0.
            </para>
            <note>
            This must be used instead of something like <see cref="T:System.Random"/> to guarantee 
            determinism when a workflow is replayed.
            </note>
            </summary>
            <returns>The next random double between: <c>0  &lt;= value &lt; 1.0</c></returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            The internal random number generator is seeded such that workflow instances
            will generally see different sequences of random numbers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NextRandomAsync">
            <summary>
            <para>
            Returns a replay safe random non-negative random integer.
            </para>
            <note>
            This must be used instead of something like <see cref="T:System.Random"/> to guarantee 
            determinism when a workflow is replayed.
            </note>
            </summary>
            <returns>The next random integer greater than or equal to 0</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            The internal random number generator is seeded such that workflow instances
            will generally see different sequences of random numbers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NextRandomAsync(System.Int32)">
            <summary>
            <para>
            Returns a replay safe random non-negative integer less than a maximum value.
            </para>
            <note>
            This must be used instead of something like <see cref="T:System.Random"/> to guarantee 
            determinism when a workflow is replayed.
            </note>
            </summary>
            <param name="maxValue">The exclusive upper limit of the value returned.  This cannot be negative.</param>
            <returns>The next random integer between: <c>0  &lt;= value &lt; maxValue</c></returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            The internal random number generator is seeded such that workflow instances
            will generally see different sequences of random numbers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NextRandomAsync(System.Int32,System.Int32)">
            <summary>
            <para>
            Returns a replay safe random non-negative integer greater than or equal to a minimum value
            less than a maximum value.
            </para>
            <note>
            This must be used instead of something like <see cref="T:System.Random"/> to guarantee 
            determinism when a workflow is replayed.
            </note>
            </summary>
            <param name="minValue">The inclusive lower limit of the value returned (may be negative).</param>
            <param name="maxValue">The exclusive upper limit of the value returned (may be negative).</param>
            <returns>The next random integer between: <c>0  &lt;= value &lt; maxValue</c>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            The internal random number generator is seeded such that workflow instances
            will generally see different sequences of random numbers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NextRandomBytesAsync(System.Int32)">
            <summary>
            <para>
            Returns a replay safe byte array filled with random values.
            </para>
            <note>
            This must be used instead of something like <see cref="T:System.Random"/> to guarantee 
            determinism when a workflow is replayed.
            </note>
            </summary>
            <param name="size">The size of the byte array returned (must be positive)..</param>
            <returns>The random bytes.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            The internal random number generator is seeded such that workflow instances
            will generally see different sequences of random numbers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.SideEffectAsync``1(System.Func{``0})">
            <summary>
            Calls the specified function and records the value returned in the workflow
            history such that subsequent calls will return the same value.
            </summary>
            <typeparam name="T">Specifies the result type.</typeparam>
            <param name="function">The side effect function.</param>
            <returns>The value returned by the first function call.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            This is similar to what you could do with a local activity but is
            a bit easier since you don't need to declare the activity and create
            a stub to call it.
            </para>
            <note>
            The function must return within the configured decision task timeout 
            and should avoid throwing exceptions.
            </note>
            <note>
            The function passed should avoid throwing exceptions.  When an exception
            is thrown, this method will catch it and simply return the default 
            value for <typeparamref name="T"/>.
            </note>
            <note>
            <para>
            The .NET version of this method currently works a bit differently than
            the Java and GOLANG clients which will only call the function once.
            The .NET implementation calls the function every time <see cref="M:Neon.Cadence.Workflow.SideEffectAsync``1(System.Func{``0})"/>
            is called but it will ignore the all but the first call's result.
            </para>
            <para>
            This is an artifact of how the .NET client is currently implemented
            and may change in the future.  You should take care not to code your
            application to depend on this behavior (one way or the other).
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.SideEffectAsync(System.Type,System.Func{System.Object})">
            <summary>
            Calls the specified function and records the value returned in the workflow
            history such that subsequent calls will return the same value.  This version
            specifies the expected result type as a parameter.
            </summary>
            <param name="resultType">Specifies the result type.</param>
            <param name="function">The side effect function.</param>
            <returns>The value returned by the first function call.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            This is similar to what you could do with a local activity but is
            a bit easier since you don't need to declare the activity and create
            a stub to call it.
            </para>
            <note>
            The function must return within the configured decision task timeout 
            and should avoid throwing exceptions.
            </note>
            <note>
            The function passed should avoid throwing exceptions.  When an exception
            is thrown, this method will catch it and simply return <c>null</c>.
            </note>
            <note>
            <para>
            The .NET version of this method currently works a bit differently than
            the Java and GOLANG clients which will only call the function once.
            The .NET implementation calls the function every time <see cref="M:Neon.Cadence.Workflow.SideEffectAsync(System.Type,System.Func{System.Object})"/>
            is called but it will ignore the all but the first call's result.
            </para>
            <para>
            This is an artifact of how the .NET client is currently implemented
            and may change in the future.  You should take care not to code your
            application to depend on this behavior (one way or the other).
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.SleepAsync(System.TimeSpan)">
            <summary>
            Pauses the workflow for at least the specified interval.
            </summary>
            <param name="duration">The duration to pause.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/></returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            This must be used instead of calling <see cref="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)"/> or <see cref="M:System.Threading.Thread.Sleep(System.TimeSpan)"/>
            to guarantee determinism when a workflow is replayed.
            </note>
            <note>
            Cadence time interval resolution is limited to whole seconds and
            the duration will be rounded up to the nearest second and the 
            workflow may resumed sometime after the requested interval 
            depending on how busy the registered workers are and how long
            it takes to actually wake the workflow.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.SleepUntilUtcAsync(System.DateTime)">
            <summary>
            Pauses the workflow until at least the specified time (UTC).
            </summary>
            <param name="wakeTimeUtc">The wake time (UTC).</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/></returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            Cadence timers have a resolution of only one second at this time
            and due to processing delays, it's very possible that the workflow
            will wake several seconds later than scheduled.  You should not
            depend on time resolutions less than around 10 seconds.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.IsSetLastCompletionResultAsync">
            <summary>
            Determines whether a previous run of the current CRON workflow completed
            and returned a result.
            </summary>
            <returns><c>true</c> if the a previous CRON workflow run returned a result.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Cadence.Workflow.GetLastCompletionResultAsync``1">
            <summary>
            Returns the result of the last run of the current CRON workflow or
            <c>null</c>.  This is useful for CRON workflows that would like to
            pass information from from one workflow run to the next.
            </summary>
            <typeparam name="TResult">The expected result type.</typeparam>
            <returns>The previous run result as bytes or <c>null</c>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewActivityStub``1(Neon.Cadence.ActivityOptions)">
            <summary>
            Creates a client stub that can be used to launch one or more activity instances
            via the type-safe interface methods.
            </summary>
            <typeparam name="TActivityInterface">The activity interface.</typeparam>
            <param name="options">Optionally specifies the activity options.</param>
            <returns>The new <see cref="T:Neon.Cadence.ActivityStub"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            Unlike workflow stubs, a single activity stub instance can be used to
            launch multiple activities.
            </note>
            <para>
            Activities launched by the returned stub will be scheduled normally
            by Cadence to executed on one of the worker nodes.  Use 
            <see cref="M:Neon.Cadence.Workflow.NewLocalActivityStub``2(Neon.Cadence.LocalActivityOptions)"/>
            to execute short-lived activities locally within the current process.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewExternalActivityStub(System.String,Neon.Cadence.ActivityOptions)">
            <summary>
            Creates an untyped client stub that can be used to launch one or more activity
            instances using a specific activity type name.  This is typically used to launch
            activities written in other languages.
            </summary>
            <param name="activityTypeName">Specifies the target activity type name.</param>
            <param name="options">Optionally specifies the activity options.</param>
            <returns>The untyped <see cref="T:Neon.Cadence.ActivityStub"/> you'll use to execute the activity.</returns>
            <remarks>
            <para>
            <paramref name="activityTypeName"/> specifies the target activity implementation type name and optionally,
            the specific activity method to be called for activity interfaces that have multiple methods.  For
            activity methods tagged by <c>ActivityMethod]</c>[ with specifying a name, the activity type name will default
            to the fully qualified interface type name or the custom type name specified by <see cref="P:Neon.Cadence.ActivityAttribute.Name"/>.
            </para>
            <para>
            For activity methods with <see cref="P:Neon.Cadence.ActivityMethodAttribute.Name"/> specified, the activity type will
            look like:
            </para>
            <code>
            ACTIVITY-TYPE-NAME::METHOD-NAME
            </code>
            <note>
            You may need to customize activity type name when interoperating with activities written
            in other languages.  See <a href="https://doc.neonkube.com/Neon.Cadence-CrossPlatform.htm">Cadence Cross-Platform</a>
            for more information.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewChildWorkflowStub``1(Neon.Cadence.ChildWorkflowOptions,System.String)">
            <summary>
            Creates a workflow client stub that can be used to launch, signal, and query child
            workflows via the type-safe workflow interface methods.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="options">Optionally specifies the child workflow options.</param>
            <param name="workflowTypeName">
            Optionally specifies the workflow type name by overriding the fully 
            qualified <typeparamref name="TWorkflowInterface"/> type name or the name
            specified by a <see cref="T:Neon.Cadence.WorkflowAttribute"/>.
            </param>
            <returns>The child workflow stub.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/>.
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewContinueAsNewStub``1(Neon.Cadence.ContinueAsNewOptions)">
            <summary>
            Creates a typed-safe client stub that can be used to continue the workflow as a new run.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="options">Optionally specifies the new options to use when continuing the workflow.</param>
            <returns>The type-safe stub.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            The workflow stub returned is intended just for continuing the workflow by
            calling one of the workflow entry point methods tagged by <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/>.
            Any signal or query methods defined by <typeparamref name="TWorkflowInterface"/> will 
            throw a <see cref="T:System.InvalidOperationException"/> when called.
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewExternalWorkflowStub(Neon.Cadence.WorkflowExecution)">
            <summary>
            Creates a workflow client stub that can be used communicate with an
            existing workflow identified by a <see cref="T:Neon.Cadence.WorkflowExecution"/>.
            </summary>
            <param name="execution">Identifies the workflow.</param>
            <returns>The workflow stub.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewExternalWorkflowStub(System.String,System.String)">
            <summary>
            Creates a workflow client stub that can be used communicate with an
            existing workflow identified by a workflow ID and optional domain.
            </summary>
            <param name="workflowId">Identifies the workflow.</param>
            <param name="domain">Optionally overrides the parent workflow domain.</param>
            <returns>The workflow stub.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewLocalActivityStub``2(Neon.Cadence.LocalActivityOptions)">
            <summary>
            Creates a client stub that can be used to launch one or more local activity 
            instances via the type-safe interface methods.
            </summary>
            <typeparam name="TActivityInterface">The activity interface.</typeparam>
            <typeparam name="TActivityImplementation">The activity implementation.</typeparam>
            <param name="options">Optionally specifies activity options.</param>
            <returns>The new <see cref="T:Neon.Cadence.ActivityStub"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            Unlike workflow stubs, a single activity stub instance can be used to
            launch multiple activities.
            </note>
            <para>
            Activities launched by the returned stub will be executed in the current
            process.  This is intended to easily and efficiently execute activities
            that will complete very quickly (usually within a few seconds).  Local
            activities are similar to normal activities with these differences:
            </para>
            <list type="bullet">
                <item>
                Local activities are always scheduled to executed within the current process.
                </item>
                <item>
                Local activity types do not need to be registered with the worker.
                </item>
                <item>
                Local activities must complete within the <see cref="P:Neon.Cadence.WorkflowOptions.DecisionTaskTimeout"/>.
                This defaults to 10 seconds and can be set to a maximum of 60 seconds.
                </item>
                <item>
                Local activities cannot heartbeat.
                </item>
            </list>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewChildWorkflowFutureStub``1(System.String,Neon.Cadence.ChildWorkflowOptions)">
            <summary>
            Creates a specialized stub suitable for starting and running a child workflow in parallel
            with other workflow operations such as child workflows or activities.
            </summary>
            <typeparam name="TWorkflowInterface">The target workflow interface.</typeparam>
            <param name="methodName">
            Optionally identifies the target workflow method.  This is the name specified in
            <c>[WorkflowMethod]</c> attribute for the workflow method or <c>null</c>/empty for
            the default workflow method.
            </param>
            <param name="options">Optionally specifies custom <see cref="T:Neon.Cadence.ChildWorkflowOptions"/>.</param>
            <returns>A <see cref="T:Neon.Cadence.ChildWorkflowStub`1"/> instance.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            Sometimes workflows need to run child workflows in parallel with other child workflows or
            activities.  Although the typed workflow stubs return a <see cref="T:System.Threading.Tasks.Task"/> or <see cref="T:System.Threading.Tasks.Task`1"/>,
            workflow developers are required to immediately <c>await</c> every call to these stubs to 
            ensure that the workflow will execute consistently when replayed from history.  This 
            means that you must not do something like this:
            </para>
            <code language="C#">
            public interface IMyWorkflow : IWorkflow
            {
                [WorkflowMethod]
                Task MainAsync();
                
                [WorkflowMethod(Name = "child")]
                Task&lt;string&gt; ChildAsync(string arg);
            }
            
            public class MyWorkflow : WorkflowBase, IMyWorkflow
            {
                public Task MainAsync()
                {
                    var stub1     = Workflow.NewChildWorkflowStub&lt;IMyWorkflow&gt;("FOO");
                    var childTask = stub1.DoChildWorkflow();
                    var stub2     = Workflow.NewChildWorkflowStub&lt;IMyWorkflow&gt;();
                    var value2    = await stub2.DoChildWorkflow("BAR");
                    var value1    = await childTask;
                }
                
                public Task&lt;string&gt; ChildAsync(string arg)
                {
                    return await Task.FromResult(arg);
                }
            }
            </code>
            <para>
            The <c>MainAsync()</c> workflow method here creates and starts a child workflow, but it 
            doesn't immediately <c>await</c> it.  It then runs another child workflow in parallel 
            and then after the second child returns, the workflow awaits the first child.  This pattern 
            is not supported by <b>Neon.Cadence</b> because all workflow related operations need to 
            be immediately awaited to ensure that operations will complete in a consistent order when
            workflows are replayed.
            </para>
            <note>
            The reason for this restriction is related to how the current <b>Neon.Cadence</b> implementation
            uses an embedded GOLANG Cadence client to actually communicate with a Cadence cluster.  This
            may be relaxed in the future if/when we implement native support for the Cadence protocol.
            </note>
            <para>
            A correct implementation would look something like this:
            </para>
            <code language="C#">
            public interface IMyWorkflow : IWorkflow
            {
                [WorkflowMethod]
                Task MainAsync();
                
                [WorkflowMethod(Name = "child")]
                Task&lt;string&gt; ChildAsync(string arg);
            }
            
            public class MyWorkflow : WorkflowBase, IMyWorkflow
            {
                public Task MainAsync()
                {
                    var stub1  = Workflow.NewChildWorkflowFutureStub&lt;IMyWorkflow&gt;("child");
                    var future = await stub1.StartAsync$lt;string&gt;("FOO");   // Starting the child with param: "FOO"
                    var stub2  = Workflow.NewChildWorkflowStub&lt;IMyWorkflow&gt;();
                    var value2 = await stub2.DoChildWorkflow("BAR");            // This returns: "BAR"
                    var value1 = await future.GetAsync();                       // This returns: "FOO"
                }
                
                public Task&lt;string&gt; ChildAsync(string arg)
                {
                    return await Task.FromResult(arg);
                }
            }
            </code>
            <para>
            Here we call <see cref="M:Neon.Cadence.Workflow.NewChildWorkflowFutureStub``1(System.String,Neon.Cadence.ChildWorkflowOptions)"/> specifying
            <b>"child"</b> as the workflow method name.  This matches the <c>[WorkflowMethod(Name = "child")]</c>
            attribute decorating the <c>ChildAsync()</c> workflow interface method.  Then we start the child workflow by awaiting 
            <see cref="M:Neon.Cadence.ChildWorkflowStub`1.StartAsync(System.Object[])"/>. This returns an <see cref="T:Neon.Cadence.ChildWorkflowFuture`1"/> whose 
            <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> method returns the workflow result.  The code above calls this to retrieve the 
            result from the first child after executing the second child in parallel.
            </para>
            <note>
            <para>
            You must take care to pass parameters that match the target method.  <b>Neon.Cadence</b> does check these at
            runtime, but there is no compile-time checking.
            </para>
            <para>
            You'll also need to cast the <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> result to the actual type (if required).
            This method always returns the <c>object</c> type even if referenced workflow and activity methods return
            <c>void</c>.  <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> will return <c>null</c> in these cases.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewUntypedChildWorkflowFutureStub(System.String,Neon.Cadence.ChildWorkflowOptions)">
            <summary>
            Creates an untyped child workflow stub that can be used to start, signal, and wait
            for the child workflow completion.  Use this version for child workflows that
            don't return a value.
            </summary>
            <param name="workflowTypeName">The workflow type name (see the remarks).</param>
            <param name="options">Optionally specifies the child workflow options.</param>
            <returns>The <see cref="T:Neon.Cadence.ChildWorkflowFutureStub"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/>.
            </para>
            <para>
            <paramref name="workflowTypeName"/> specifies the target workflow implementation type name and optionally,
            the specific workflow method to be called for workflow interfaces that have multiple methods.  For
            workflow methods tagged by <c>[WorkflowMethod]</c> with specifying a name, the workflow type name will default
            to the fully qualified interface type name or the custom type name specified by <see cref="P:Neon.Cadence.WorkflowAttribute.Name"/>.
            </para>
            <para>
            For workflow methods with <see cref="P:Neon.Cadence.WorkflowMethodAttribute.Name"/> specified, the workflow type will
            look like:
            </para>
            <code>
            WORKFLOW-TYPE-NAME::METHOD-NAME
            </code>
            <para>
            You'll need to use this format when calling workflows using external untyped stubs or 
            from other languages.  The Java Cadence client works the same way.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewUntypedChildWorkflowFutureStub``1(System.String,Neon.Cadence.ChildWorkflowOptions)">
            <summary>
            Creates an untyped child workflow stub that can be used to start, signal, and wait
            for the child workflow completion.  Use this version for child workflows that
            return a value.
            </summary>
            <typeparam name="TResult">Specifies the child workflow result type.</typeparam>
            <param name="workflowTypeName">The workflow type name (see the remarks).</param>
            <param name="options">Optionally specifies the child workflow options.</param>
            <returns>The <see cref="T:Neon.Cadence.ChildWorkflowFutureStub"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/>.
            </para>
            <para>
            <paramref name="workflowTypeName"/> specifies the target workflow implementation type name and optionally,
            the specific workflow method to be called for workflow interfaces that have multiple methods.  For
            workflow methods tagged by <c>[WorkflowMethod]</c> with specifying a name, the workflow type name will default
            to the fully qualified interface type name or the custom type name specified by <see cref="P:Neon.Cadence.WorkflowAttribute.Name"/>.
            </para>
            <para>
            For workflow methods with <see cref="P:Neon.Cadence.WorkflowMethodAttribute.Name"/> specified, the workflow type will
            look like:
            </para>
            <code>
            WORKFLOW-TYPE-NAME::METHOD-NAME
            </code>
            <para>
            You'll need to use this format when calling workflows using external untyped stubs or 
            from other languages.  The Java Cadence client works the same way.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewUntypedExternalWorkflowStub(Neon.Cadence.WorkflowExecution,System.String)">
            <summary>
            Creates an untyped stub that can be used to signal or cancel a child
            workflow identified by its <see cref="T:Neon.Cadence.WorkflowExecution"/>.
            </summary>
            <param name="execution">The target <see cref="T:Neon.Cadence.WorkflowExecution"/>.</param>
            <param name="domain">Optionally specifies the target domain.  This defaults to the parent workflow's domain.</param>
            <returns>The <see cref="T:Neon.Cadence.ExternalWorkflowStub"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewUntypedExternalWorkflowStub(System.String,System.String)">
            <summary>
            Creates an untyped stub that can be used to signal or cancel a child
            workflow identified by its workflow ID.
            </summary>
            <param name="workflowId">The target workflow ID.</param>
            <param name="domain">Optionally specifies the target domain.  This defaults to the parent workflow's domain.</param>
            <returns>The <see cref="T:Neon.Cadence.ExternalWorkflowStub"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewActivityFutureStub``1(System.String,Neon.Cadence.ActivityOptions)">
             <summary>
             Creates a specialized stub suitable for starting and running an activity in parallel
             with other workflow operations such as child workflows or activities.
             </summary>
             <typeparam name="TActivityInterface">The activity interface.</typeparam>
             <param name="methodName">
             Optionally identifies the target activity method.  This is the name specified in
             <c>[ActivityMethod]</c> attribute for the activity method or <c>null</c>/empty for 
             the default activity method.
             </param>
             <param name="options">Optionally specifies the activity options.</param>
             <returns>The new <see cref="T:Neon.Cadence.ActivityFutureStub`1"/>.</returns>
             <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
             <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
             <remarks>
             <para>
             Sometimes workflows need to run activities in parallel with other child workflows or
             activities.  Although the standard stubs return a <see cref="T:System.Threading.Tasks.Task"/> or <see cref="T:System.Threading.Tasks.Task`1"/>,
             workflow developers are required to immediately <c>await</c> every call to these stubs to 
             ensure that the workflow will execute consistently when replayed from history.  This 
             means that you must not do something like this:
             </para>
             <code language="C#">
             public interface IMyActivity : IActivity
             {
                 [ActivityMethod(Name = "activity-1"]
                 Task&lt;string&gt; FooActivityAsync(string arg);
                 
                 [ActivityMethod(Name = "activity-2"]
                 Task&lt;string&gt; BarActivityAsync(string arg);
             }
             
             public MyActivity : ActivityBase, IMyActivity
             {
                 public Task&lt;string&gt; FooActivityAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
                 
                 public Task&lt;string&gt; BarActivityAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
             }
            
             public class MyWorkflow : WorkflowBase, IMyWorkflow
             {
                 [WorkflowMethod]
                 public Task MainAsync()
                 {
                     var stub     = Workflow.NewActivityStub&lt;IMyActivity&gt;();
                     var fooTask  = stub.FooActivity("FOO");
                     var barValue = await stub.BarActivityAsync("BAR");
                     var fooValue = await fooTask;
                 }
             }
             </code>
             <para>
             The <c>MainAsync()</c> workflow method here starts an activity but doesn't immediately
             <c>await</c> it.  It then runs another activity in parallel and then after the second 
             activity returns, the workflow awaits the first activity.  This pattern is not supported 
             by <b>Neon.Cadence</b> because all workflow related operations need to be immediately
             awaited to ensure that operations will complete in a consistent order when workflows 
             are replayed.
             </para>
             <note>
             The reason for this restriction is related to how the current <b>Neon.Cadence</b> implementation
             uses an embedded GOLANG Cadence client to actually communicate with a Cadence cluster.  This
             may be relaxed in the future if/when we implement native support for the Cadence protocol.
             </note>
             <para>
             A correct implementation would look something like this:
             </para>
             <code language="C#">
             public interface IMyActivity : IActivity
             {
                 [ActivityMethod(Name = "foo"]
                 Task&lt;string&gt; FooAsync(string arg);
                 
                 [ActivityMethod(Name = "bar"]
                 Task&lt;string&gt; BarAsync(string arg);
             }
             
             public MyActivity : ActivityBase, IMyActivity
             {
                 public Task&lt;string&gt; FooAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
                 
                 public Task&lt;string&gt; BarAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
             }
            
             public class MyWorkflow : WorkflowBase, IMyWorkflow
             {
                 [WorkflowMethod]
                 public Task MainAsync()
                 {
                     var fooStub  = Workflow.NewActivityFutureStub("foo");
                     var future   = fooStub.StartAsync&lt;string&gt;("FOO");
                     var barStub  = Workflow.NewActivityStub&lt;IMyActivity&gt;();
                     var barValue = await barStub.BarAsync("BAR");   // Returns: "BAR"
                     var fooValue = await future.GetAsync();         // Returns: "FOO"
                 }
             }
             </code>
             <para>
             Here we call <see cref="M:Neon.Cadence.Workflow.NewActivityFutureStub``1(System.String,Neon.Cadence.ActivityOptions)"/> specifying
             <b>"foo"</b> as the workflow method name.  This matches the <c>[ActivityMethod(Name = "foo")]</c> decorating
             the <c>FooAsync()</c> activity interface method.  Then we start the first activity by awaiting 
             <see cref="T:Neon.Cadence.ActivityFutureStub`1"/>.  This returns an <see cref="T:Neon.Tasks.IAsyncFuture`1"/> whose 
             <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> method returns the activity result.  The code above calls this to
             retrieve the result from the first activity after executing the second activity in parallel.
             </para>
             <note>
             <para>
             You must take care to pass parameters that match the target method.  <b>Neon.Cadence</b> does check these at
             runtime, but there is no compile-time checking for this scheme.
             </para>
             <para>
             You'll also need to cast the <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> result to the actual type (if required).
             This method always returns the <c>object</c> type even if referenced workflow and activity methods return
             <c>void</c>.  <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> will return <c>null</c> in these cases.
             </para>
             </note>
             </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewActivityFutureStub(System.String,Neon.Cadence.ActivityOptions)">
             <summary>
             Creates a specialized untyped stub suitable for starting and running an activity in parallel
             with other workflow operations such as child workflows or activities.  This is typically
             used for executing activities written in another language.
             </summary>
             <param name="activityTypeName">Specifies the target activity type name.</param>
             <param name="options">Optionally specifies the activity options.</param>
             <returns>The new untyped <see cref="T:Neon.Cadence.ActivityFutureStub"/>.</returns>
             <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
             <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
             <remarks>
             <para>
             Sometimes workflows need to run activities written in other languages in parallel with other
             child workflows or activities.  Although the standard stubs return a <see cref="T:System.Threading.Tasks.Task"/> or <see cref="T:System.Threading.Tasks.Task`1"/>,
             workflow developers are required to immediately <c>await</c> every call to these stubs to 
             ensure that the workflow will execute consistently when replayed from history.  This 
             means that you must not do something like this:
             </para>
             <code language="C#">
             public interface IMyActivity : IActivity
             {
                 [ActivityMethod(Name = "activity-1"]
                 Task&lt;string&gt; FooActivityAsync(string arg);
                 
                 [ActivityMethod(Name = "activity-2"]
                 Task&lt;string&gt; BarActivityAsync(string arg);
             }
             
             public MyActivity : ActivityBase, IMyActivity
             {
                 public Task&lt;string&gt; FooActivityAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
                 
                 public Task&lt;string&gt; BarActivityAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
             }
            
             public class MyWorkflow : WorkflowBase, IMyWorkflow
             {
                 [WorkflowMethod]
                 public Task MainAsync()
                 {
                     var stub     = Workflow.NewActivityStub("MyActivity::FooActivityAsync");
                     var fooTask  = stub.StartAsync&lt;string&gt;("FOO");
                     var barStub  = Workflow.NewActivityStub&lt;IMyActivity&gt;();
                     var barValue = await barStub.BarActivityAsync("BAR");
                     var fooValue = await fooTask;
                 }
             }
             </code>
             <para>
             The <c>MainAsync()</c> workflow method here starts an activity but doesn't immediately
             <c>await</c> it.  It then runs another activity in parallel and then after the second 
             activity returns, the workflow awaits the first activity.  This pattern is not supported 
             by <b>Neon.Cadence</b> because all workflow related operations need to be immediately
             awaited to ensure that operations will complete in a consistent order when workflows 
             are replayed.
             </para>
             <note>
             The reason for this restriction is related to how the current <b>Neon.Cadence</b> implementation
             uses an embedded GOLANG Cadence client to actually communicate with a Cadence cluster.  This
             may be relaxed in the future if/when we implement native support for the Cadence protocol.
             </note>
             <para>
             A correct implementation would look something like this:
             </para>
             <code language="C#">
             public interface IMyActivity : IActivity
             {
                 [ActivityMethod(Name = "foo"]
                 Task&lt;string&gt; FooAsync(string arg);
                 
                 [ActivityMethod(Name = "bar"]
                 Task&lt;string&gt; BarAsync(string arg);
             }
             
             public MyActivity : ActivityBase, IMyActivity
             {
                 public Task&lt;string&gt; FooAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
                 
                 public Task&lt;string&gt; BarAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
             }
            
             public class MyWorkflow : WorkflowBase, IMyWorkflow
             {
                 [WorkflowMethod]
                 public Task MainAsync()
                 {
                     var fooStub  = Workflow.NewActivityFutureStub("foo");
                     var future   = await fooStub.StartAsync&lt;string&gt;("FOO");
                     var barStub  = Workflow.NewActivityStub&lt;IMyActivity&gt;();
                     var barValue = await barStub.BarAsync("BAR");   // Returns: "BAR"
                     var fooValue = await future.GetAsync();         // Returns: "FOO"
                 }
             }
             </code>
             <para>
             Here we call <see cref="M:Neon.Cadence.Workflow.NewActivityFutureStub(System.String,Neon.Cadence.ActivityOptions)"/> specifying
             <b>"foo"</b> as the workflow method name.  This matches the <c>[ActivityMethod(Name = "foo")]</c> decorating
             the <c>FooAsync()</c> activity interface method.  Then we start the first activity by awaiting 
             <see cref="T:Neon.Cadence.ActivityFutureStub`1"/>.  This returns an <see cref="T:Neon.Tasks.IAsyncFuture`1"/> whose 
             <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> method returns the activity result.  The code above calls this to
             retrieve the result from the first activity after executing the second activity in parallel.
             </para>
             <note>
             <para>
             You must take care to pass parameters that match the target method.  <b>Neon.Cadence</b> does check these at
             runtime, but there is no compile-time checking for this scheme.
             </para>
             <para>
             You'll also need to cast the <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> result to the actual type (if required).
             This method always returns the <c>object</c> type even if referenced workflow and activity methods return
             <c>void</c>.  <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> will return <c>null</c> in these cases.
             </para>
             </note>
             </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewStartLocalActivityStub``2(System.String,Neon.Cadence.LocalActivityOptions)">
             <summary>
             Creates a specialized stub suitable for starting and running a local activity in parallel
             with other workflow operations such as child workflows or activities.
             </summary>
             <typeparam name="TActivityInterface">Specifies the activity interface.</typeparam>
             <typeparam name="TActivityImplementation">Specifies the local activity implementation class.</typeparam> 
             <param name="methodName">
             Optionally identifies the target activity method.  This is the name specified in
             <c>[ActivityMethod]</c> attribute for the activity method or <c>null</c>/empty for
             the default activity method.
             </param>
             <param name="options">Optionally specifies the local activity options.</param>
             <returns>The new <see cref="M:Neon.Cadence.Workflow.NewStartLocalActivityStub``2(System.String,Neon.Cadence.LocalActivityOptions)"/>.</returns>
             <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
             <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
             <remarks>
             <para>
             Sometimes workflows need to run local activities in parallel with other child workflows or
             activities.  Although the standard stubs return a <see cref="T:System.Threading.Tasks.Task"/> or <see cref="T:System.Threading.Tasks.Task`1"/>,
             workflow developers are required to immediately <c>await</c> every call to these stubs to 
             ensure that the workflow will execute consistently when replayed from history.  This 
             means that you must not do something like this:
             </para>
             <code language="C#">
             public interface IMyActivity : IActivity
             {
                 [ActivityMethod(Name = "activity-1"]
                 Task&lt;string&gt; FooActivityAsync(string arg);
                 
                 [ActivityMethod(Name = "activity-2"]
                 Task&lt;string&gt; BarActivityAsync(string arg);
             }
             
             public MyActivity : ActivityBase, IMyActivity
             {
                 public Task&lt;string&gt; FooActivityAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
                 
                 public Task&lt;string&gt; BarActivityAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
             }
            
             public class MyWorkflow : WorkflowBase, IMyWorkflow
             {
                 [WorkflowMethod]
                 public Task MainAsync()
                 {
                     var stub     = Workflow.NewLocalActivityStub&lt;IMyActivity, MyActivity&gt;();
                     var fooTask  = stub.FooActivity("FOO");
                     var barValue = await stub.BarActivityAsync("BAR");
                     var fooValue = await fooTask;
                 }
             }
             </code>
             <para>
             The <c>MainAsync()</c> workflow method here starts a local activity but doesn't immediately
             <c>await</c> it.  It then runs another activity in parallel and then after the second 
             activity returns, the workflow awaits the first activity.  This pattern is not supported 
             by <b>Neon.Cadence</b> because all workflow related operations need to be immediately
             awaited to ensure that operations will complete in a consistent order when workflows 
             are replayed.
             </para>
             <note>
             The reason for this restriction is related to how the current <b>Neon.Cadence</b> implementation
             uses an embedded GOLANG Cadence client to actually communicate with a Cadence cluster.  This
             may be relaxed in the future if/when we implement native support for the Cadence protocol.
             </note>
             <para>
             A correct implementation would look something like this:
             </para>
             <code language="C#">
             public interface IMyActivity : IActivity
             {
                 [ActivityMethod(Name = "foo"]
                 Task&lt;string&gt; FooAsync(string arg);
                 
                 [ActivityMethod(Name = "bar"]
                 Task&lt;string&gt; BarAsync(string arg);
             }
             
             public MyActivity : ActivityBase, IMyActivity
             {
                 public Task&lt;string&gt; FooAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
                 
                 public Task&lt;string&gt; BarAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
             }
            
             public class MyWorkflow : WorkflowBase, IMyWorkflow
             {
                 [WorkflowMethod]
                 public Task MainAsync()
                 {
                     var fooStub  = Workflow.NewStartLocalActivityStub("foo");
                     var future   = fooStub.StartAsync&lt;string&gt;("FOO");
                     var barStub  = Workflow.NewActivityStub&lt;IMyActivity&gt;();
                     var barValue = await barStub.BarAsync("BAR");   // Returns: "BAR"
                     var fooValue = await future.GetAsync();         // Returns: "FOO"
                 }
             }
             </code>
             <para>
             Here we call <see cref="M:Neon.Cadence.Workflow.NewActivityFutureStub``1(System.String,Neon.Cadence.ActivityOptions)"/> specifying
             <b>"foo"</b> as the workflow method name.  This matches the <c>[ActivityMethod(Name = "foo")]</c> decorating
             the <c>FooAsync()</c> activity interface method.  Then we start the first activity by awaiting 
             <see cref="T:Neon.Cadence.ActivityFutureStub`1"/>.  This returns an <see cref="T:Neon.Tasks.IAsyncFuture`1"/> whose 
             <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> method returns the activity result.  The code above calls this to
             retrieve the result from the first activity after executing the second activity in parallel.
             </para>
             <note>
             <para>
             You must take care to pass parameters that match the target method.  <b>Neon.Cadence</b> does check these at
             runtime, but there is no compile-time checking for this scheme.
             </para>
             <para>
             You'll also need to cast the <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> result to the actual type (if required).
             This method always returns the <c>object</c> type even if referenced workflow and activity methods return
             <c>void</c>.  <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> will return <c>null</c> in these cases.
             </para>
             </note>
             </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.NewQueueAsync``1(System.Int32)">
            <summary>
            Creates a new workflow safe queue.  These are typically used by workflow signal
            methods for communicating with the workflow logic.
            </summary>
            <typeparam name="T">Specifies the queued data type.</typeparam>
            <param name="capacity">
            <para>
            Specifies the maximum number items the queue may hold.
            </para>
            <note>
            This defaults to <see cref="F:Neon.Cadence.WorkflowQueue`1.DefaultCapacity"/>.
            </note>
            </param>
            <returns>The new <see cref="T:Neon.Cadence.WorkflowQueue`1"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            You may write and read data items from the returned queue.  Writes
            will block when the queue is full until an item has been read, freeing
            a slot.
            </para>
            <note>
            Items will be serialized internally using the current <see cref="T:Neon.Cadence.IDataConverter"/> to
            bytes before actually enqueuing the item.  This serialized data must be less
            than 64KiB.
            </note>
            <para>
            See <see cref="T:Neon.Cadence.WorkflowQueue`1"/> for more information.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.Workflow.ExecuteActivityAsync(System.String,System.Byte[],Neon.Cadence.ActivityOptions)">
            <summary>
            Executes an activity with a specific activity type name and waits for it to complete.
            </summary>
            <param name="activityTypeName">Identifies the activity.</param>
            <param name="args">Specifies the encoded activity arguments or <c>null</c> when there are no arguments.</param>
            <param name="options">Specifies the activity options.</param>
            <returns>The activity result encoded as a byte array.</returns>
            <exception cref="T:Neon.Cadence.CadenceException">
            An exception derived from <see cref="T:Neon.Cadence.CadenceException"/> will be be thrown 
            if the child workflow did not complete successfully.
            </exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the Cadence does not exist.</exception>
            <exception cref="T:Neon.Cadence.BadRequestException">Thrown when the request is invalid.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence cluster problems.</exception>
            <exception cref="T:Neon.Cadence.ServiceBusyException">Thrown when Cadence is too busy.</exception>
        </member>
        <member name="M:Neon.Cadence.Workflow.RegisterActivityAction(System.Type,System.Reflection.ConstructorInfo,System.Reflection.MethodInfo)">
            <summary>
            Registers a local activity type and method with the workflow and returns 
            its local activity action ID.
            </summary>
            <param name="activityType">The activity type.</param>
            <param name="activityConstructor">The activity constructor.</param>
            <param name="activityMethod">The target local activity method.</param>
            <returns>The new local activity action ID.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
        </member>
        <member name="M:Neon.Cadence.Workflow.ExecuteLocalActivityAsync(System.Type,System.Reflection.ConstructorInfo,System.Reflection.MethodInfo,System.Byte[],Neon.Cadence.LocalActivityOptions)">
            <summary>
            Executes a local activity and waits for it to complete.
            </summary>
            <param name="activityType">The activity type.</param>
            <param name="activityConstructor">The activity constructor.</param>
            <param name="activityMethod">The target local activity method.</param>
            <param name="args">Specifies specifies the encoded activity arguments or <c>null</c> when there are no arguments.</param>
            <param name="options">Specifies the local activity options.</param>
            <returns>The activity result encoded as a byte array.</returns>
            <exception cref="T:Neon.Cadence.CadenceException">
            An exception derived from <see cref="T:Neon.Cadence.CadenceException"/> will be be thrown 
            if the child workflow did not complete successfully.
            </exception>
            <remarks>
            This method can be used to optimize activities that will complete quickly
            (within seconds).  Rather than scheduling the activity on any worker that
            has registered an implementation for the activity, this method will simply
            instantiate an instance of <paramref name="activityType"/> and call its
            <paramref name="activityMethod"/> method.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Cadence client is disposed.</exception>
            <exception cref="T:Neon.Cadence.EntityNotExistsException">Thrown if the Cadence domain does not exist.</exception>
            <exception cref="T:Neon.Cadence.BadRequestException">Thrown when the request is invalid.</exception>
            <exception cref="T:Neon.Cadence.InternalServiceException">Thrown for internal Cadence cluster problems.</exception>
            <exception cref="T:Neon.Cadence.ServiceBusyException">Thrown when Cadence is too busy.</exception>
        </member>
        <member name="M:Neon.Cadence.Workflow.ForceReplayAsync">
            <summary>
            Forces the current workflow execution to terminate such that it will be rescheduled
            and replayed as required.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.WorkflowAttribute">
            <summary>
            Used to tag workflow implementations that inherit from
            <see cref="T:Neon.Cadence.WorkflowBase"/> to customize the how the workflow is
            registered.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">
            Optionally specifies the workflow type name to be used 
            when registering the workflow implementation with Cadence.
            </param>
        </member>
        <member name="P:Neon.Cadence.WorkflowAttribute.Name">
            <summary>
            The workflow type name.  This defaults to the fully qualified name
            of the implemented workflow interface (without any leading "I").
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowAttribute.AutoRegister">
            <summary>
            Indicates that <see cref="M:Neon.Cadence.CadenceClient.RegisterAssemblyWorkflowsAsync(System.Reflection.Assembly,System.String)"/> will
            automatically register the tagged workflow implementation for the specified assembly.
            This defaults to <c>false</c>
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowBase">
            <summary>
            Base class that must be inherited for all workflow implementations.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowBase.WorkflowCallContext">
            <summary>
            Enumerates the possible contexts workflow code may be executing within.
            This is used to limit what code can do (i.e. query methods shouldn't be
            allowed to execute activities).  This is also used in some situations to
            modify how workflow code behaves.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowBase.WorkflowCallContext.None">
            <summary>
            The current task is not executing within the context
            of any workflow method.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowBase.WorkflowCallContext.Entrypoint">
            <summary>
            The current task is executing within the context of
            a workflow entrypoint.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowBase.WorkflowCallContext.Signal">
            <summary>
            The current task is executing within the context of a
            workflow signal method.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowBase.WorkflowCallContext.Query">
            <summary>
            The current task is executing within the context of a
            workflow query method.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowBase.WorkflowCallContext.Activity">
            <summary>
            The current task is executing within the context of a
            normal or local activity.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowBase.WorkflowInstanceKey">
            <summary>
            Used to map a Cadence client ID and workflow context ID into a
            key that can be used to dereference <see cref="F:Neon.Cadence.WorkflowBase.idToWorkflow"/>.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowBase.WorkflowRegistration">
            <summary>
            Describes the workflow implementation type, entry point method, and 
            signal/query methods for registered workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowBase.WorkflowRegistration.WorkflowType">
            <summary>
            The workflow implemention type.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowBase.WorkflowRegistration.WorkflowMethod">
            <summary>
            The workflow entry point method.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowBase.WorkflowRegistration.WorkflowMethodParameterTypes">
            <summary>
            The workflow entry point parameter types.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowBase.WorkflowRegistration.MethodMap">
            <summary>
            Maps workflow signal and query names to the corresponding
            method implementations.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowBase.CallContext">
            <summary>
            Holds ambient task state indicating whether the current task executing
            in the context of a workflow entry point, signal, or query.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.Reset">
            <summary>
            Restores the class to its initial state.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.CheckCallContext(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Ensures that the current <see cref="T:System.Threading.Tasks.Task"/> is running within the context of a workflow 
            entry point, signal, or query method and also that the context matches one of the parameters
            indicating which contexts are allowed.  This is used ensure that only workflow operations
            that are valid for a context are allowed.
            </summary>
            <param name="allowWorkflow">Optionally indicates that calls from workflow entry point contexts are allowed.</param>
            <param name="allowQuery">Optionally indicates that calls from workflow query contexts are allowed.</param>
            <param name="allowSignal">Optionally indicates that calls from workflow signal contexts are allowed.</param>
            <param name="allowActivity">Optionally indicates that calls from activity contexts are allowed.</param>
            <exception cref="T:System.NotSupportedException">Thrown when the operation is not supported in the current context.</exception>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.GetWorkflowTypeKey(Neon.Cadence.CadenceClient,System.String,Neon.Cadence.WorkflowMethodAttribute)">
            <summary>
            Prepends the Cadence client ID to the workflow type name as well as the optional
            workflow method name to generate the key used to dereference the <see cref="F:Neon.Cadence.WorkflowBase.nameToRegistration"/> 
            dictionary.
            </summary>
            <param name="client">The Cadence client.</param>
            <param name="workflowTypeName">The workflow type name.</param>
            <param name="workflowMethodAttribute">The workflow method attribute. </param>
            <returns>The workflow registration key.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.GetWorkflowTypeNameFromKey(System.String)">
            <summary>
            Strips the leading client ID from the workflow type key passed
            and returns the type name actually registered with Cadence.
            </summary>
            <param name="workflowTypeKey">The workflow type key.</param>
            <returns>The Cadence workflow type name.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.RegisterAsync(Neon.Cadence.CadenceClient,System.Type,System.String,System.String)">
            <summary>
            Registers a workflow implementation.
            </summary>
            <param name="client">The associated client.</param>
            <param name="workflowType">The workflow implementation type.</param>
            <param name="workflowTypeName">The name used to identify the implementation.</param>
            <param name="domain">Specifies the target domain.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if a different workflow class has already been registered for <paramref name="workflowTypeName"/>.</exception>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.UnregisterClient(Neon.Cadence.CadenceClient)">
            <summary>
            Removes all type workflow interface registrations for a Cadence client (when it's being disposed).
            </summary>
            <param name="client">The client being disposed.</param>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.GetWorkflowRegistration(Neon.Cadence.CadenceClient,System.String)">
            <summary>
            Returns the registration for the named Cadence workflow.
            </summary>
            <param name="client">The Cadence client.</param>
            <param name="workflowTypeName">The Cadence workflow type name.</param>
            <returns>The <see cref="T:Neon.Cadence.WorkflowBase.WorkflowRegistration"/> or <c>null</c> if the type was not found.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.GetSignalStatus(System.Int64,System.String)">
            <summary>
            Returns the <see cref="T:Neon.Cadence.Internal.SyncSignalStatus"/> for the specified workflow and signal.
            </summary>
            <param name="contextId">The target workflow context ID.</param>
            <param name="signalId">The target signal ID.</param>
            <returns>The <see cref="T:Neon.Cadence.Internal.SyncSignalStatus"/> for the signal.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.OnProxyRequestAsync(Neon.Cadence.CadenceClient,Neon.Cadence.Internal.ProxyRequest)">
            <summary>
            Called to handle a workflow related request message received from the cadence-proxy.
            </summary>
            <param name="client">The client that received the request.</param>
            <param name="request">The request message.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.GetWorkflow(Neon.Cadence.CadenceClient,System.Int64)">
            <summary>
            Thread-safe method that maps a workflow ID to the corresponding workflow instance.
            </summary>
            <param name="client">The Cadence client.</param>
            <param name="contextId">The workflow's context ID.</param>
            <returns>The <see cref="T:Neon.Cadence.WorkflowBase"/> instance or <c>null</c> if the workflow was not found.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.OnInvokeAsync(Neon.Cadence.CadenceClient,Neon.Cadence.Internal.WorkflowInvokeRequest)">
            <summary>
            Handles workflow invocation.
            </summary>
            <param name="client">The associated Cadence client.</param>
            <param name="request">The request message.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.WaitForPendingWorkflowOperations(Neon.Cadence.WorkflowBase)">
            <summary>
            Waits for any pending workflow operations (like outstanding synchronous signals) to 
            complete.  This is called before returning from a workflow method.
            </summary>
            <param name="workflow">The target workflow.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.OnSignalAsync(Neon.Cadence.CadenceClient,Neon.Cadence.Internal.WorkflowSignalInvokeRequest)">
            <summary>
            Handles workflow signals.
            </summary>
            <param name="client">The Cadence client.</param>
            <param name="request">The request message.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.OnSyncSignalAsync(Neon.Cadence.CadenceClient,Neon.Cadence.Internal.WorkflowSignalInvokeRequest)">
            <summary>
            Handles internal <see cref="F:Neon.Cadence.CadenceClient.SignalSync"/> workflow signals.
            </summary>
            <param name="client">The Cadence client.</param>
            <param name="request">The request message.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.OnQueryAsync(Neon.Cadence.CadenceClient,Neon.Cadence.Internal.WorkflowQueryInvokeRequest)">
            <summary>
            Handles workflow queries.
            </summary>
            <param name="client">The Cadence client.</param>
            <param name="request">The request message.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowBase.OnInvokeLocalActivity(Neon.Cadence.CadenceClient,Neon.Cadence.Internal.ActivityInvokeLocalRequest)">
            <summary>
            Handles workflow local activity invocations.
            </summary>
            <param name="client">The client the request was received from.</param>
            <param name="request">The request message.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="P:Neon.Cadence.WorkflowBase.StackTrace">
            <summary>
            This field holds the stack trace for the most recent decision related 
            <see cref="P:Neon.Cadence.WorkflowBase.Workflow"/> method calls.  This will be returned for internal
            workflow <b>"__stack_trace"</b> queries.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowBase.Workflow">
            <summary>
            Returns a <see cref="P:Neon.Cadence.WorkflowBase.Workflow"/> instance with utilty methods you'll use
            for implementing your workflows.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowConfig">
            <summary>
            Describes a workflow's configuration.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowConfig.TaskList">
            <summary>
            Identifies the task list where the workflow was scheduled.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowConfig.TaskListKind">
            <summary>
            Identifies the type of a task list.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowConfig.ExecutionStartToCloseTimeout">
            <summary>
            Maximum time the entire workflow may take to complete end-to-end.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowConfig.TaskStartToCloseTimeoutSeconds">
            <summary>
            Maximum time a workflow task/decision may take to complete.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowConfig.ParentClosePolicy">
            <summary>
            The termination policy to apply to the child workflow when
            the parent workflow is terminated.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowDescription">
            <summary>
            Describes a workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowDescription.Configuration">
            <summary>
            Describes the workflow's configuration.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowDescription.Status">
            <summary>
            Describes the workflow's execution status.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowDescription.PendingActivities">
            <summary>
            Describes the workflow's scheduled and executing activities.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowDescription.PendingChildren">
            <summary>
            Describes the workflow's scheduled and executing child workflows.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowExecution">
            <summary>
            Describes the state of an executed workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowExecution.#ctor">
            <summary>
            Defaulty constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowExecution.#ctor(System.String,System.String)">
            <summary>
            Internal constructor.
            </summary>
            <param name="workflowId">The original ID for the workflow.</param>
            <param name="runId">Optionally specifies the current run ID for the workflow.</param>
        </member>
        <member name="P:Neon.Cadence.WorkflowExecution.WorkflowId">
            <summary>
            Returns the current ID for workflow execution.  This will be different
            than <see cref="P:Neon.Cadence.WorkflowExecution.RunId"/> when the workflow has been continued as new
            or potentially restarted.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowExecution.RunId">
            <summary>
            The original ID assigned to the workflow when it was started.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowExecutionCloseStatus">
            <summary>
            Enumerates the possible reasons why a workflow was closed.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowExecutionCloseStatus.Completed">
            <summary>
            The workflow completed successfully.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowExecutionCloseStatus.Failed">
            <summary>
            The workflow failed.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowExecutionCloseStatus.Cancelled">
            <summary>
            The workflow was cancelled.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowExecutionCloseStatus.Terminated">
            <summary>
            The workflow was terminated.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowExecutionCloseStatus.Restarted">
            <summary>
            The workflow was restarted (aka <i>continued as new</i>).
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowExecutionCloseStatus.Timedout">
            <summary>
            The workflow timed out.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowFutureStub`1">
            <summary>
            <para>
            Manages starting, signalling, or querying an external workflow instance
            based on its workflow type name and arguments.  This class separates workflow 
            execution and retrieving the result into separate operations.
            </para>
            <para>
            Use this version for workflows that don't return a result.
            </para>
            </summary>
            <typeparam name="WorkflowInterface">Specifies the workflow interface.</typeparam>
        </member>
        <member name="M:Neon.Cadence.WorkflowFutureStub`1.#ctor(Neon.Cadence.CadenceClient,System.String,Neon.Cadence.WorkflowOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="client">The associated client.</param>
            <param name="methodName">
            Optionally identifies the target workflow method by the name specified in
            the <c>[WorkflowMethod]</c> attribute tagging the method.  Pass a <c>null</c>
            or empty string to target the default method.
            </param>
            <param name="options">Optional workflow options.</param>
        </member>
        <member name="P:Neon.Cadence.WorkflowFutureStub`1.Execution">
            <summary>
            Returns the workflow <see cref="T:Neon.Cadence.WorkflowExecution"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the workflow has not been started.</exception>
        </member>
        <member name="M:Neon.Cadence.WorkflowFutureStub`1.StartAsync(System.Object[])">
            <summary>
            Starts the workflow, returning an <see cref="T:Neon.Tasks.IAsyncFuture"/> that can be used
            to wait for the the workflow to complete.  This version does not return a workflow
            result.
            </summary>
            <param name="args">The workflow arguments.</param>
            <returns>An <see cref="T:Neon.Cadence.ExternalWorkflowFuture"/> that can be used to retrieve the workflow result as an <c>object</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the workflow has already been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow method.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.WorkflowFutureStub`1.StartAsync``1(System.Object[])">
            <summary>
            Starts the workflow, returning an <see cref="T:Neon.Tasks.IAsyncFuture"/> that can be used
            to wait for the the workflow to complete and obtain its result.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
            <param name="args">The workflow arguments.</param>
            <returns>An <see cref="T:Neon.Cadence.ExternalWorkflowFuture`1"/> that can be used to retrieve the workflow result as an <c>object</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the workflow has already been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            and the result type are compatible with the target workflow method.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.WorkflowFutureStub`1.SignalAsync(System.String,System.Object[])">
            <summary>
            Signals the workflow.
            </summary>
            <param name="signalName">
            The signal name as defined by the <see cref="T:Neon.Cadence.SignalMethodAttribute"/>
            decorating the workflow signal method.
            </param>
            <param name="args">The signal arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the child workflow has not been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow arguments.  No compile-time type checking
            is performed for this method.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.WorkflowFutureStub`1.SyncSignalAsync(System.String,System.Object[])">
            <summary>
            <b>EXPERIMENTAL:</b> This method synchronously signals the workflow and returns
            only after the workflow has processed received and processed the signal as opposed
            to <see cref="M:Neon.Cadence.WorkflowFutureStub`1.SignalAsync(System.String,System.Object[])"/> which is fire-and-forget and does not wait for the
            signal to be processed.
            </summary>
            <param name="signalName">
            The signal name as defined by the <see cref="T:Neon.Cadence.SignalMethodAttribute"/>
            decorating the workflow signal method.
            </param>
            <param name="args">The signal arguments.</param>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow arguments.  No compile-time type checking
            is performed for this method.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.WorkflowFutureStub`1.SyncSignalAsync``1(System.String,System.Object[])">
            <summary>
            <b>EXPERIMENTAL:</b> This method synchronously signals the workflow and returns
            the signal result only after the workflow has processed received and processed the 
            signal as opposed to <see cref="M:Neon.Cadence.WorkflowFutureStub`1.SignalAsync(System.String,System.Object[])"/> which is fire-and-forget and does 
            not wait for the signal to be processed and cannot return a result.
            </summary>
            <typeparam name="TResult">The signal result type.</typeparam>
            <param name="signalName">
            The signal name as defined by the <see cref="T:Neon.Cadence.SignalMethodAttribute"/>
            decorating the workflow signal method.
            </param>
            <param name="args">The signal arguments.</param>
            <returns>The signal result.</returns>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow arguments.  No compile-time type checking
            is performed for this method.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.WorkflowFutureStub`1.QueryAsync``1(System.String,System.Object[])">
            <summary>
            Queries the workflow.
            </summary>
            <typeparam name="TQueryResult">The query result type.</typeparam>
            <param name="queryName">Identifies the query.</param>
            <param name="args">The query arguments.</param>
            <returns>The query result.</returns>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters and
            result type passed are compatible with the target workflow query arguments.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.WorkflowIdReusePolicy">
            <summary>
            Enumerates the workflow ID reuse policies.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowIdReusePolicy.AllowDuplicateFailedOnly">
            <summary>
            Allows starting a workflow with the same ID as another workflow when
            that workflow is not running and the last execution close state 
            is in [terminated, cancelled, timeout, failed].
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowIdReusePolicy.AllowDuplicate">
            <summary>
            Allows starting a workflow with the same ID as another workflow when
            that workflow is not running for any reason.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowIdReusePolicy.RejectDuplicate">
            <summary>
            Prohibits starting a workflow with the same ID as another workflow,
            whether that workflow is running or not.
            </summary>
        </member>
        <member name="F:Neon.Cadence.WorkflowIdReusePolicy.UseDefault">
            <summary>
            Indicates that the reuse policy specified by <see cref="P:Neon.Cadence.WorkflowOptions.WorkflowIdReusePolicy"/>
            or <see cref="P:Neon.Cadence.CadenceSettings.WorkflowIdReusePolicy"/> should be used.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowInfo">
            <summary>
            Returns information about an executing workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowInfo.Domain">
            <summary>
            Returns the workflow domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowInfo.WorkflowId">
            <summary>
            Returns the workflow ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowInfo.RunId">
            <summary>
            Returns the workflow's current run ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowInfo.WorkflowType">
            <summary>
            Returns the workflow's workflow type name.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowInfo.TaskList">
            <summary>
            Returns the workflow task list.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowInterfaceAttribute">
            <summary>
            Used to tag workflow interfaces and optionally specify the task list
            identifying the workers hosting this workflow.  <see cref="T:Neon.Cadence.CadenceClient"/>
            for more information on how task lists work.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowInterfaceAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowInterfaceAttribute.Domain">
            <summary>
            Optionally specifies the Cadence domain where the workflow is registered.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowInterfaceAttribute.TaskList">
            <summary>
            Optionally specifies the Cadence task list identifying the workers
            hosting this workflow.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowMethodAttribute">
            <summary>
            Used to identify a workflow interface method as a workflow entry point.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowMethodAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowMethodAttribute.Name">
            <summary>
            Specifies the name to be used to identify a specific workflow method.  This is optional
            for workflow interfaces that have only one workflow entry point method but is required
            for interfaces with multiple entry points.
            </summary>
            <remarks>
            <para>
            When specified, this name will be combined with the workflow type name when registering
            and executing a workflow started via the method.  This will typically look like:
            </para>
            <code>
            WORKFLOW_TYPENAME::METHODNAME
            </code>
            <para>
            where <b>WORKFLOW_TYPENAME</b> is either the workflow interface's fully qualified 
            name or the name specified by <see cref="P:Neon.Cadence.WorkflowAttribute.Name"/> and 
            <b>METHOD_NAME</b> is from <see cref="P:Neon.Cadence.WorkflowMethodAttribute.Name"/>.  This
            is the same convention implemented by the Java client.
            </para>
            <para>
            Sometimes it's useful to be able to specify a workflow type name that doesn't
            follow the convention above, for example to interoperate with workflows written
            in another language..  You can do this by setting <see cref="P:Neon.Cadence.WorkflowMethodAttribute.Name"/> to the
            required workflow type name and then setting <see cref="P:Neon.Cadence.WorkflowMethodAttribute.IsFullName"/><c>=true</c>.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Cadence.WorkflowMethodAttribute.IsFullName">
            <summary>
            <para>
            Optionally indicates that <see cref="P:Neon.Cadence.WorkflowMethodAttribute.Name"/> holds the fully qualified type name for
            the workflow and that the .NET client will not add a prefix to <see cref="P:Neon.Cadence.WorkflowMethodAttribute.Name"/>
            when registering the workflow.
            </para>
            <para>
            This is useful when interoperating with workflows written in another language by
            providing a way to specify a specific workflow type name. 
            </para>
            <note>
            <see cref="P:Neon.Cadence.WorkflowMethodAttribute.Name"/> cannot be <c>null</c> or empty when this is <c>true</c>.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowMethodAttribute.StartToCloseTimeoutSeconds">
            <summary>
            Optionally specifies the maximum workflow execution time.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowMethodAttribute.DecisionTaskTimeoutSeconds">
            <summary>
            Optionally specifies the maximum execution time for an individual workflow decision
            task.  The maximum possible duration is <b>60 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowMethodAttribute.ScheduleToStartTimeoutSeconds">
            <summary>
            Optionally specifies the maximum time a workflow can wait
            between being scheduled and being actually executed on a
            worker.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowMethodAttribute.TaskList">
            <summary>
            Optionally specifies the target Cadence task list.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowMethodAttribute.Domain">
            <summary>
            Optionally specifies the target Cadence domain.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowMethodAttribute.WorkflowId">
            <summary>
            Optionally specifies the workflow ID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowMethodAttribute.WorkflowIdReusePolicy">
            <summary>
            Specifies the workflow ID reuse policy.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowMethodAttribute.CronSchedule">
            <summary>
            Optionally specifies a recurring schedule for the workflow method.  This can be set to a string specifying
            the minute, hour, day of month, month, and day of week scheduling parameters using the standard Linux
            CRON format described here: <a href="https://en.wikipedia.org/wiki/Cron">https://en.wikipedia.org/wiki/Cron</a>
            </summary>
            <remarks>
            <para>
            Cadence accepts a CRON string formatted as a single line of text with 5 parameters separated by
            spaces.  The parameters specified the minute, hour, day of month, month, and day of week values:
            </para>
            <code>
            ┌───────────── minute (0 - 59)
            │ ┌───────────── hour (0 - 23)
            │ │ ┌───────────── day of the month (1 - 31)
            │ │ │ ┌───────────── month (1 - 12)
            │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)
            │ │ │ │ │
            │ │ │ │ │
            * * * * * 
            </code>
            <para>
            Each parameter may be set to one of:
            </para>
            <list type="table">
            <item>
                <term><b>*</b></term>
                <description>
                Matches any value.
                </description>
            </item>
            <item>
                <term><b>value</b></term>
                <description>
                Matches a specific integer value.
                </description>
            </item>
            <item>
                <term><b>value1-value2</b></term>
                <description>
                Matches a range of values to be matched (inclusive).
                </description>
            </item>
            <item>
                <term><b>value1,value2,...</b></term>
                <description>
                Matches a list of values to be matched.
                </description>
            </item>
            <item>
                <term><b>value1/value2</b></term>
                <description>
                Matches values starting at <b>value1</b> and then those incremented by <b>value2</b>.
                </description>
            </item>
            </list>
            <para>
            You can use this handy CRON calculator to see how this works: <a href="https://crontab.guru">https://crontab.guru</a>
            </para>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.WorkflowMethodMap">
            <summary>
            Maps workflow query and signal names to the methods implementing the queries
            and signals for a given workflow interface.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowMethodMap.Create(System.Type)">
            <summary>
            Constructs a query/signal method map for a workflow type.
            </summary>
            <param name="workflowType">The workflow type.</param>
            <returns>The <see cref="T:Neon.Cadence.WorkflowMethodMap"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowMethodMap.#ctor">
            <summary>
            Private constructor.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowMethodMap.GetSignalMethod(System.String)">
            <summary>
            Returns the <see cref="T:System.Reflection.MethodInfo"/> for the handler for a given signal.
            </summary>
            <param name="name">Ths signal name.</param>
            <returns>
            The <see cref="T:System.Reflection.MethodInfo"/> for the handler or <c>null</c> when there
            is no handler for the named signal.
            </returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowMethodMap.GetQueryMethod(System.String)">
            <summary>
            Returns the <see cref="T:System.Reflection.MethodInfo"/> for the handler for a given query.
            </summary>
            <param name="name">Ths query name.</param>
            <returns>
            The <see cref="T:System.Reflection.MethodInfo"/> for the handler or <c>null</c> when there
            is no handler for the named query.
            </returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowMethodMap.GetSignalNames">
            <summary>
            Returns the names of the mapped signals.
            </summary>
            <returns>The signal name list.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowMethodMap.GetQueryTypes">
            <summary>
            Returns the names of the mapped queries.
            </summary>
            <returns>The query name list.</returns>
        </member>
        <member name="P:Neon.Cadence.WorkflowMethodMap.HasSynchronousSignals">
            <summary>
            Returns <c>true</c> if the workflow defines any synchronous signals.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowOptions">
            <summary>
            Specifies the options to use when starting a workflow.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowOptions.Normalize(Neon.Cadence.CadenceClient,Neon.Cadence.WorkflowOptions,System.Type,System.Reflection.MethodInfo)">
            <summary>
            Normalizes the options passed by creating or cloning a new instance as 
            required and filling unset properties using default client settings.
            </summary>
            <param name="client">The associated Cadence client.</param>
            <param name="options">The input options or <c>null</c>.</param>
            <param name="workflowInterface">Optionally specifies the workflow interface definition.</param>
            <param name="method">Optionally specifies the target workflow method.</param>
            <returns>The normalized options.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if a valid task list is not specified.</exception>
        </member>
        <member name="M:Neon.Cadence.WorkflowOptions.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowOptions.WorkflowId">
            <summary>
            Optionally specifies the business ID for a workflow.  This defaults
            to a generated UUID.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowOptions.Domain">
            <summary>
            Optionally specifies the target Cadence domain.  This defaults to the domain
            specified by <see cref="P:Neon.Cadence.WorkflowMethodAttribute.Domain"/>, 
            <see cref="P:Neon.Cadence.WorkflowInterfaceAttribute.Domain"/>, or 
            to the client's <see cref="T:Neon.Cadence.CadenceSettings"/>, in that 
            order of precedence.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowOptions.TaskList">
            <summary>
            Optionally specifies the target Cadence task list.  This defaults to the task list
            specified by <see cref="P:Neon.Cadence.WorkflowMethodAttribute.TaskList"/> or
            <see cref="P:Neon.Cadence.WorkflowInterfaceAttribute.TaskList"/>or 
            to the client's <see cref="T:Neon.Cadence.CadenceSettings"/>, in that 
            order of precedence.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowOptions.ScheduleToStartTimeout">
            <summary>
            Optionally specifies the default maximum time a workflow can wait between being scheduled
            and actually begin executing.  This defaults to <c>24 hours</c>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowOptions.StartToCloseTimeout">
            <summary>
            <para>
            Optionally specifies the maximum time the workflow may execute from start to finish.
            This defaults to 24 hours.
            </para>
            <note>
            This overrides the optional corresponding value specified in the
            <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/> tagging the workflow entry 
            point method.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowOptions.DecisionTaskTimeout">
            <summary>
            Optionally specifies the timeout for processing decision task from the time the worker
            pulled a task.  If a decision task is not completed within this interval, it will be retried 
            as specified by the retry policy.   This defaults to <b>10 seconds</b> when not specified.
            The maximum timeout is <b>60 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowOptions.WorkflowIdReusePolicy">
            <summary>
            Optionally determines how Cadence handles workflows that attempt to reuse workflow IDs.
            This generally defaults to <see cref="F:Neon.Cadence.WorkflowIdReusePolicy.AllowDuplicate"/>
            but the default can be customized via the <see cref="T:Neon.Cadence.WorkflowMethodAttribute"/> tagging
            the workflow entry point method or <see cref="P:Neon.Cadence.CadenceSettings.WorkflowIdReusePolicy"/>
            (which also defaults to <see cref="F:Neon.Cadence.WorkflowIdReusePolicy.AllowDuplicate"/>.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowOptions.RetryOptions">
            <summary>
            Optional retry options for the workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowOptions.CronSchedule">
            <summary>
            Optionally specifies a recurring schedule for the workflow.  This can be set to a string specifying
            the minute, hour, day of month, month, and day of week scheduling parameters using the standard Linux
            CRON format described here: <a href="https://en.wikipedia.org/wiki/Cron">https://en.wikipedia.org/wiki/Cron</a>
            </summary>
            <remarks>
            <para>
            Cadence accepts a CRON string formatted as a single line of text with 5 parameters separated by
            spaces.  The parameters specified the minute, hour, day of month, month, and day of week values:
            </para>
            <code>
            ┌───────────── minute (0 - 59)
            │ ┌───────────── hour (0 - 23)
            │ │ ┌───────────── day of the month (1 - 31)
            │ │ │ ┌───────────── month (1 - 12)
            │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)
            │ │ │ │ │
            │ │ │ │ │
            * * * * * 
            </code>
            <para>
            Each parameter may be set to one of:
            </para>
            <list type="table">
            <item>
                <term><b>*</b></term>
                <description>
                Matches any value.
                </description>
            </item>
            <item>
                <term><b>value</b></term>
                <description>
                Matches a specific integer value.
                </description>
            </item>
            <item>
                <term><b>value1-value2</b></term>
                <description>
                Matches a range of values to be matched (inclusive).
                </description>
            </item>
            <item>
                <term><b>value1,value2,...</b></term>
                <description>
                Matches a list of values to be matched.
                </description>
            </item>
            <item>
                <term><b>value1/value2</b></term>
                <description>
                Matches values starting at <b>value1</b> and then those incremented by <b>value2</b>.
                </description>
            </item>
            </list>
            <para>
            You can use this handy CRON calculator to see how this works: <a href="https://crontab.guru">https://crontab.guru</a>
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Cadence.WorkflowOptions.Memo">
            <summary>
            <para>
            Optionally specifies workflow metadata as a dictionary of named object values.
            </para>
            <note>
            The object values will be serialized into bytes using the the client's
            <see cref="T:Neon.Cadence.IDataConverter"/>.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowOptions.ToInternal">
            <summary>
            Converts the instance into an internal <see cref="T:Neon.Cadence.Internal.InternalStartWorkflowOptions"/>.
            </summary>
            <returns>The corresponding <see cref="T:Neon.Cadence.Internal.InternalStartWorkflowOptions"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowOptions.Clone">
            <summary>
            Returns a shallow clone of the current instance.
            </summary>
            <returns>The cloned <see cref="T:Neon.Cadence.WorkflowOptions"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.WorkflowQueue`1">
            <summary>
            Implements a workflow-safe first-in-first-out (FIFO) queue that can be used by
            workflow signal methods to communicate with the running workflow logic.
            </summary>
            <typeparam name="T">Specifies the type of the queued items.</typeparam>
            <remarks>
            <para>
            You can construct workflow queue instances in your workflows via
            <see cref="M:Neon.Cadence.Workflow.NewQueueAsync``1(System.Int32)"/>, optionally specifying 
            the maximum capacity of the queue.  This defaults to <see cref="F:Neon.Cadence.WorkflowQueue`1.DefaultCapacity"/>
            and may not be less that 2 queued items.
            </para>
            <para>
            Items are added to the queue via <see cref="M:Neon.Cadence.WorkflowQueue`1.EnqueueAsync(`0)"/>.  This
            method will return immediately when the number of items currently in
            the queue is less than the capacity, otherwise the operation will block
            until an item has been dequeued and the queue is no longer full.
            </para>
            <note>
            Serialized item sizes must be less than 64 KiB.
            </note>
            <para>
            Use <see cref="M:Neon.Cadence.WorkflowQueue`1.DequeueAsync(System.TimeSpan)"/> to read from the queue using
            an optional timeout.
            </para>
            <note>
            <para>
            The <see cref="T:Neon.Cadence.WorkflowQueue`1"/> class is intended only for two scenarios
            within an executing workflow:
            </para>
            <list type="number">
                <item>
                <b>Workflow Entry Point:</b> Workflow entry points have full access queues 
                including creating, closing, reading, writing, and fetching the length.
                </item>
                <item>
                <b>Workflow Signal:</b> Workflow signal methods have partial access to
                queues including closing, writing, and fetching the length.  Signals 
                cannot create or read from queues.
                </item>
                </list>
            </note>
            </remarks>
        </member>
        <member name="F:Neon.Cadence.WorkflowQueue`1.DefaultCapacity">
            <summary>
            The default maximum number of items allowed in a queue.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowQueue`1.#ctor(Neon.Cadence.Workflow,System.Int64,System.Int32)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="queueId">The queue ID.</param>
            <param name="capacity">The maximum number of items allowed in the queue.</param>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            <see cref="T:Neon.Cadence.WorkflowQueue`1"/> instances may only be created within 
            workflow entry point methods.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.WorkflowQueue`1.Dispose">
            <summary>
            Closes the queue if it's not already closed.
            </summary>
            <remarks>
            <note>
            Queues may be disposed only from within workflow entrypoint or signal methods.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.WorkflowQueue`1.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Cadence.WorkflowQueue`1.CheckDisposed">
            <summary>
            Ensures that the instance is not disposed.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown if the queue is disposed.</exception>
        </member>
        <member name="P:Neon.Cadence.WorkflowQueue`1.Capacity">
            <summary>
            Returns the maximum number of items allowed in the queue at any given moment.
            This may not be set to a value less than 2.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown if the queue is disposed.</exception>
        </member>
        <member name="M:Neon.Cadence.WorkflowQueue`1.EnqueueAsync(`0)">
            <summary>
            Adds an item to the queue.
            </summary>
            <param name="item">The item.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the queue is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown if the serialized size of <paramref name="item"/> is not less than 64KiB.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated workflow client is disposed.</exception>
            <exception cref="T:Neon.Cadence.WorkflowQueueClosedException">Thrown if the associated queue has been closed.</exception>
            <remarks>
            <para>
            This method returns immediately if the queue is not full, otherwise
            it will block until there's enough space to append the new item.
            </para>
            <note>
            Item data after being serialized must be less than 64 KiB.
            </note>
            </remarks>
            <remarks>
            <note>
            Items may be added to queues only within workflow entrypoint or signal methods.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.WorkflowQueue`1.TryEnqueueAsync(`0)">
            <summary>
            Attempts to add an item to the queue.  Unlike <see cref="M:Neon.Cadence.WorkflowQueue`1.EnqueueAsync(`0)"/>, this method
            does not block when the queue is full and returns <c>false</c> instead.
            </summary>
            <param name="item">The item.</param>
            <returns><c>true</c> if the item was written or <c>false</c> if the queue is full and the item was not written.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the queue is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown if the serialized size of <paramref name="item"/> is not less than 64KiB.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated workflow client is disposed.</exception>
            <exception cref="T:Neon.Cadence.WorkflowQueueClosedException">Thrown if the associated queue has been closed.</exception>
            <remarks>
            <note>
            Item data after being serialized must be less than 64 KiB.
            </note>
            </remarks>
            <remarks>
            <note>
            Items may be added to queues only within workflow entrypoint or signal methods.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.WorkflowQueue`1.DequeueAsync(System.TimeSpan)">
            <summary>
            Attempts to dequeue an item from the queue with an optional timeout.
            </summary>
            <param name="timeout">The optional timeout.</param>
            <returns>The next item from the queue.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated workflow client is disposed.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if the queue is disposed.</exception>
            <exception cref="T:Neon.Cadence.CadenceTimeoutException">Thrown if the timeout was reached before a value could be returned.</exception>
            <exception cref="T:Neon.Cadence.WorkflowQueueClosedException">Thrown if the the queue is closed.</exception>
            <remarks>
            <note>
            Items may be read from queues only from within workflow entrypoint methods.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.WorkflowQueue`1.CloseAsync">
            <summary>
            <para>
            Closes the queue.
            </para>
            <note>
            This does nothing if the queue is already closed.
            </note>
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated workflow client is disposed.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if the queue is disposed.</exception>
            <remarks>
            <note>
            Queues may be closed only from within workflow entrypoint or signal methods.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Cadence.WorkflowStatus">
            <summary>
            Describes the current state of a workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStatus.Execution">
            <summary>
            Describes the workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStatus.TypeName">
            <summary>
            Identifies the workflow implementation.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStatus.StartTime">
            <summary>
            Workflow start time or <c>null</c> if the workflow hasn't started yet.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStatus.CloseTime">
            <summary>
            Workflow close time or <c>null</c> if the workflow hasn't completed yet.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStatus.HasStarted">
            <summary>
            Returns <c>true</c> if the workflow has been started and is still running
            or has already completed.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStatus.IsClosed">
            <summary>
            Returns <c>true</c> if the workflow has been completed.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStatus.IsRunning">
            <summary>
            Returns <c>true</c> if the workflow is currently running.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStatus.WorkflowCloseStatus">
            <summary>
            The status for a closed workflow.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStatus.HistoryLength">
            <summary>
            Workflow history length.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStatus.ParentDomain">
            <summary>
            Identifies the domain where the parent workflow is running
            (or <c>null</c>).
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStatus.ParentExecution">
            <summary>
            Identfies the parent workflow (or <c>null</c>).
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStatus.ExecutionTime">
            <summary>
            The workflow execution time.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStatus.Memo">
            <summary>
            Optional workflow metadata.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowStub">
            <summary>
            Implements an untyped client side stub to a single external workflow instance.  This can 
            be used to invoke, signal, query, and cancel a workflow when the actual workflow 
            interface isn't available.
            </summary>
        </member>
        <member name="T:Neon.Cadence.WorkflowStub.IHelperActivity">
            <summary>
            Defines the helper methods used to perform external stub operations
            as a local activity so they can be replayed from history.
            </summary>
            <remarks>
            <note>
            These methods are going to use byte arrays to receive arguments from
            the caller and also to return results.  These will use the current
            data converter for encoding.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.IHelperActivity.CancelAsync(System.String,System.String)">
            <summary>
            Cancels an external workflow.
            </summary>
            <param name="workflowId">The target workflow ID.</param>
            <param name="runId">The target runID.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.IHelperActivity.GetResultAsync(System.String,System.String)">
            <summary>
            Waits for and returns the result for an external workflow.
            </summary>
            <param name="workflowId">The target workflow ID.</param>
            <param name="runId">The target runID.</param>
            <returns>The encoded workflow result.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.IHelperActivity.QueryAsync(System.String,System.String,System.String,System.Byte[])">
            <summary>
            Queries an external workflow.
            </summary>
            <param name="workflowId">The target workflow ID.</param>
            <param name="runId">The target runID.</param>
            <param name="queryType">Identifies the query.</param>
            <param name="args">The encoded query arguments.</param>
            <returns>The encode query result.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.IHelperActivity.SignalAsync(System.String,System.String,System.String,System.Byte[])">
            <summary>
            Signals an external workflow.
            </summary>
            <param name="workflowId">The target workflow ID.</param>
            <param name="runId">The target runID.</param>
            <param name="signalName">Identifies the signal.</param>
            <param name="args">The encoded signal arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Cadence.WorkflowStub.HelperActivity">
            <summary>
            Implements <see cref="T:Neon.Cadence.WorkflowStub.IHelperActivity"/>.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.FromTypedAsync(System.Object)">
            <summary>
            <para>
            Returns the untyped <see cref="T:Neon.Cadence.WorkflowStub"/> from a typed stub.
            </para>
            <note>
            This works only for external workflow stubs (not child stubs) and only for
            stubs that have already been started.
            </note>
            </summary>
            <param name="stub">The source typed workflow stub.</param>
            <returns>The <see cref="T:Neon.Cadence.WorkflowStub"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.#ctor(Neon.Cadence.CadenceClient,System.Boolean)">
            <summary>
            Default internal constructor.
            </summary>
            <param name="client">The associated client.</param>
            <param name="withinWorkflow">
            Optionally indicates that the stub was created from within a workflow and that 
            operations such as get result, query, signal, and cancel must be performed
            within local activities such that that can be replayed from history correctly.
            </param>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.#ctor(Neon.Cadence.CadenceClient,System.String,Neon.Cadence.WorkflowExecution,Neon.Cadence.WorkflowOptions)">
            <summary>
            Used to construct an untyped workflow stub that can be used to start an external workflow.
            </summary>
            <param name="client">The associated client.</param>
            <param name="workflowTypeName">The workflow type name.</param>
            <param name="execution">The workflow execution.</param>
            <param name="options">The workflow options.</param>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.#ctor(Neon.Cadence.CadenceClient,Neon.Cadence.WorkflowExecution,System.Boolean)">
            <summary>
            Used to construct an untyped workflow stub that can manage an existing external workflow.
            </summary>
            <param name="client">The associated client.</param>
            <param name="execution">The workflow execution.</param>
            <param name="withinWorkflow">
            Optionally indicates that the stub was created from within a workflow and that 
            operations such as get result, query, signal, and cancel must be performed
            within local activities such that that can be replayed from history correctly.
            </param>
        </member>
        <member name="P:Neon.Cadence.WorkflowStub.WorkflowTypeName">
            <summary>
            <para>
            Returns the workflow type name.
            </para>
            <note>
            <para>
            .NET and Java workflows can implement multiple workflow method using attributes
            and annotations to assign unique names to each.  Each workflow method is actually
            registered with Cadence as a distinct workflow type.  Workflow methods with a blank
            or <c>null</c> name will simply be registered using the workflow type name.
            </para>
            <para>
            Workflow methods with a name will be registered using a combination  of the workflow
            type name and the method name, using <b>"::"</b> as the separator, like:
            </para>
            <code>
            WORKFLOW-TYPENAME::METHOD-NAME
            </code>
            </note>
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStub.Execution">
            <summary>
            Returns the workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Cadence.WorkflowStub.Options">
            <summary>
            Returns the workflow options.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.EnsureStarted">
            <summary>
            Ensures that the workflow has been started.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.EnsureNotStarted">
            <summary>
            Ensures that the workflow has not been started.
            </summary>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.CancelAsync">
            <summary>
            Attempts to cancel the associated workflow.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.GetResultAsync">
            <summary>
            Waits for the workflow to complete or throws an error exception.  Use this for 
            workflows that don't return a result.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.GetResultAsync``1">
            <summary>
            Waits for the workflow to complete and then returns the result or throws
            an error exception.  This override accepts the result type as a type parameter.
            </summary>
            <typeparam name="TResult">The result type.</typeparam>
            <returns>The result.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.GetResultAsync(System.Type)">
            <summary>
            Waits for the workflow to complete and then returns the result or throws
            an error exception.  This override accepts the result type as a normal parameter.
            </summary>
            <param name="resultType">Specifies the result type.</param>
            <returns>The result as a <c>dynamic</c>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.QueryAsync``1(System.String,System.Object[])">
            <summary>
            Queries the associated workflow.
            </summary>
            <typeparam name="TResult">The query result type.</typeparam>
            <param name="queryType">Specifies the query type.</param>
            <param name="args">Specifies the query arguments.</param>
            <returns>The query result.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.QueryAsync(System.Type,System.String,System.Object[])">
            <summary>
             Queries the associated workflow specifying the expected result type as
             a parameter.
            </summary>
            <param name="resultType">Specifies the query result type.</param>
            <param name="queryType">Specifies the query type.</param>
            <param name="args">Specifies the query arguments.</param>
            <returns>The query result as a <c>dynamic</c>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.SignalAsync(System.String,System.Object[])">
            <summary>
            Signals the associated workflow.
            </summary>
            <param name="signalName">Specifies the signal name.</param>
            <param name="args">Specifies the signal arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.SignalWithStartAsync(System.String,System.Object[],System.Object[])">
            <summary>
            Signals the associated workflow, starting it if it hasn't already been started.
            </summary>
            <param name="signalName">Specifies the signal name.</param>
            <param name="signalArgs">Specifies the signal arguments.</param>
            <param name="startArgs">Specifies the workflow start arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.StartAsync(System.Object[])">
            <summary>
            Starts the associated workflow.
            </summary>
            <param name="args">The workflow arguments.</param>
            <returns>The <see cref="T:Neon.Cadence.WorkflowExecution"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.StartAsync(System.Byte[])">
            <summary>
            <b>INTERNAL USE ONLY:</b> Used internally for unit tests that need to control
            how the workflow arguments are encoded.
            </summary>
            <param name="argBytes">The encoded workflow arguments.</param>
            <returns>The <see cref="T:Neon.Cadence.WorkflowExecution"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.ExecuteAsync(System.Object[])">
            <summary>
            Executes the associated workflow and waits for it to complete.
            </summary>
            <param name="args">The workflow arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Cadence.WorkflowStub.ExecuteAsync``1(System.Object[])">
            <summary>
            Executes the associated workflow and waits for it to complete,
            returning the workflow result.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
            <param name="args">The workflow arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
    </members>
</doc>
