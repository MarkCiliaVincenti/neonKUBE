<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Neon.Cassandra</name>
    </assembly>
    <members>
        <member name="T:Neon.Cassandra.KeyspaceStatus">
            <summary>
            Holds information about a database's schema as returned by <see cref="M:Neon.Cassandra.SchemaManager.GetStatusAsync"/>.
            </summary>
        </member>
        <member name="M:Neon.Cassandra.KeyspaceStatus.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Cassandra.KeyspaceStatus.SchemaStatus">
            <summary>
            Returns an indication of whether the database exisis and has schema information.
            </summary>
        </member>
        <member name="P:Neon.Cassandra.KeyspaceStatus.Version">
            <summary>
            Returns the database's current schema version or <b>-1</b> when the
            database doesn't exist or have a DBINFO table.
            </summary>
        </member>
        <member name="P:Neon.Cassandra.KeyspaceStatus.MaxVersion">
            <summary>
            Returns the maximum known schema version as determined by the available
            schema scripts.
            </summary>
        </member>
        <member name="P:Neon.Cassandra.KeyspaceStatus.VersionToScript">
            <summary>
            Returns a dictionary that maps a schema version to the script to be used
            to upgrade the database to that version.
            </summary>
        </member>
        <member name="P:Neon.Cassandra.KeyspaceStatus.Updater">
            <summary>
            Identifes the updater claiming to be currently upgrading the database when
            <see cref="M:Neon.Cassandra.SchemaStatus.#ctor"/><c>=</c><see cref="F:Neon.Cassandra.SchemaStatus.Updating"/>.
            </summary>
        </member>
        <member name="P:Neon.Cassandra.KeyspaceStatus.Error">
            <summary>
            Returns the error from a previous upgrade attempt when 
            <see cref="P:Neon.Cassandra.KeyspaceStatus.SchemaStatus"/><c>=</c><see cref="F:Neon.Cassandra.SchemaStatus.UpgradeError"/>.
            </summary>
        </member>
        <member name="P:Neon.Cassandra.KeyspaceStatus.IsCurrent">
            <summary>
            Returns <c>true</c> when the database has schema information and the current version
            is the same as the most recent schema script.
            </summary>
        </member>
        <member name="T:Neon.Cassandra.NamespaceDoc">
            <summary>
            This namespace includes Cassandra related extensions and utilities.
            </summary>
        </member>
        <member name="T:Neon.Cassandra.RowSetExtensions">
            <summary>
            Extends the Cassandra <see cref="T:Cassandra.RowSet"/> class.
            </summary>
        </member>
        <member name="M:Neon.Cassandra.RowSetExtensions.HasRows(Cassandra.RowSet)">
            <summary>
            <para>
            Distructively tests a <see cref="T:Cassandra.RowSet"/> to see if it has any rows.  It does
            this by trying to fetch the first row and returning <c>true</c> when there was
            a row or <c>false</c> when there wasn't.
            </para>
            <para>
            This means that if you enumerate the rows after calling this, that the first 
            row returned by the database won't be included in the enumeration.  This is what
            we mean by <i>distructive</i>.
            </para>
            </summary>
            <param name="rowSet">The row set.</param>
        </member>
        <member name="T:Neon.Cassandra.SchemaManager">
            <summary>
            Manages the initial creation and schema updates for a Cassandra keyspace.
            </summary>
            <remarks>
            <para>
            This class uses some simple conventions to make it easy to upgrade a keyspace
            schema over time as the data model evolves.  This uses the concept of schema
            version numbers.  A schema version is simply an integer value where the version 
            will be <b>0</b> when a keyspace is initially created and then the version is
            incremented by one whenever the keyspace schema is updated.
            </para>
            <para>
            This class uses a reserved table named <see cref="F:Neon.Cassandra.SchemaManager.DbInfoTableName"/> that is used to keep
            track of the current schema version.  This table will have a single row with these
            columns:
            </para>
            <list type="table">
                <item>
                    <term><b>Version:integer</b></term>
                    <description>
                    The integer keyspace schema version.  This will be set to <b>0</b> when
                    the keyspace is first created and will be incremented for each subsequent
                    update.
                    </description>
                </item>
                <item>
                    <term><b>Updater:text</b></term>
                    <description>
                    Used by multiple service instances to coordinate which one actually handles 
                    the update.  This will be `NULL` when the keyspace isn't being updated and
                    will be set to a string identifying the entity currently updating the keyspace.
                    This string can be anything from a GUID, container ID, hostname, or whatever.
                    </description>
                </item>
                <item>
                    <term><b>UpdateStartUtc:timestamp</b></term>
                    <description>
                    Time (UTC) when the most recent update was started.
                    </description>
                </item>
                <item>
                    <term><b>UpdateFinishUtc:timestamp</b></term>
                    <description>
                    Time (UTC) when the most recent update was completed.  This will be `NULL`
                    while an update is in progress.
                    </description>
                </item>
            </list>
            <para>
            You'll be authoring Postgres SQL script files to create the initial keyspace 
            as well as to upgrade the keyspace for each subsequent schema change.  By convention,
            this class assumes that the SQL scripts for each keyspace will be saved to separate
            folders with each script file named like: <b>schema-#.script</b> where <b>#</b> is the
            schema version the script will upgrade the keyspace to, with <b>schema-0.script</b>
            being the script that creates the keyspace as <b>Version 0</b>.  So your script
            folder will look something like:
            </para>
            <code>
            schema-0000.script      &lt;-- keyspace created as v0
            schema-0001.script      &lt;-- upgrades from v0 to v1
            schema-0002.script      &lt;-- upgrades from v1 to v2
            schema-0003.script      &lt;-- upgrades from v2 to v3
            schema-0004.script      &lt;-- upgrades from v3 to v4
            ...
            schema-####.script
            </code>
            <note>
            This method parses the version number in the file names after the dash so it's perfectly
            OK to include leading zero digits there (like we did in the example above).  We actually
            recommend this so that your schema files can be sorted nicely by version when listed by
            the file system.
            </note>
            <para>
            Each script file is responsible for upgrading the keyspace from the previous version
            to the next.  This class will help manage the upgrade process by deciding which scripts
            need to be executed based on the <see cref="F:Neon.Cassandra.SchemaManager.DbInfoTableName"/> table and then executing
            the required scripts.
            </para>
            <para>
            To use, construct an instance via <see cref="T:Neon.Cassandra.SchemaManager"/>, passing a keyspace session
            for the Postgres superuser or a user with the <b>CREATEDB</b> privilege.  You'll also need
            to pass the keyspace name and the path to the file system folder holding the script files.
            </para>
            <para>
            Then call <see cref="M:Neon.Cassandra.SchemaManager.CreateKeyspaceAsync"/> to create the keyspace if it doesn't already
            exist; this uses the session passed to the constructor.  Then call 
            <see cref="M:Neon.Cassandra.SchemaManager.UpgradeKeyspaceAsync(System.String,System.Int32,System.Boolean,System.Action{System.Boolean,System.Int32})"/> to apply
            any necessary updates; this sets the session to default to the target keyspace while
            the upgrade scripts are being executed.
            </para>
            <para>
            You may optionally pass a string to <see cref="M:Neon.Cassandra.SchemaManager.UpgradeKeyspaceAsync(System.String,System.Int32,System.Boolean,System.Action{System.Boolean,System.Int32})"/>
            that identifies the entity performing the upgrade.  This could be an application name,
            the name of the host the updater is running on, the username of the person performing
            the upgrade etc.  This method uses this to try to prevent multiple updgrade from happening
            in parallel on the same keyspace (which would be bad) and the updater string can be used
            to help identify who else is updating the keyspace.  This parameter defaults to a GUID.
            </para>
            <para>
            Most applications will include at least two scripts when they get started with <b>schema-0.script</b>
            creating the keyspace and <b>schema-1.script</b> creating the tables, views, data types, 
            stored procedures, etc.
            </para>
            <para><b>SQL COMMAND BATCHES</b></para>
            <para>
            It's often necessary to execute a sequence of SQL commands that depend on
            each other.  One example is a command that creates a table followed by 
            commands that write rows.  You might think that you could achieve this
            by executing the following as one command:
            </para>
            <code language="sql">
            CREATE TABLE my_table (name text);
            INSERT INTO my_table (name) values ('Jack');
            INSERT INTO my_table (name) values ('Jill');
            </code>
            <para>
            But, this won't actually work because the keyspace generates a query plan
            for the entire command and when it does this and sees the inserts into
            [my_table] but the table doesn't actually exist at the time the query
            plan is being created.  So the command will fail.
            </para>
            <para>
            What you really need to do is create the table first as a separate
            command and then do the inserts as one or more subsequent commands.
            This is not terribly convenient so we've introduced the concept of
            a batch of commands.  Here's what this would look like:
            </para>
            <code language="sql">
            CREATE TABLE my_table (name text);
            go
            INSERT INTO my_table (name) values ('Jack');
            INSERT INTO my_table (name) values ('Jill');
            </code>
            <para>
            See how the <b>go</b> line separates the table creation from the inserts.
            This method will split the script files into separate commands on any <b>go</b> 
            lines and then execute these commands in order.
            </para>
            <note>
            <para>
            <b>go</b> is case insensitive and any leading or trailing space on the
            line will be ignored.
            </para>
            <para>
            Batch commands are implemented by <see cref="M:Neon.Cassandra.SessionExtensions.ExecuteBatch(Cassandra.ISession,System.String)"/>
            and an asynchonous alternative.
            </para>
            </note>
            <para><b>SCRIPT VARIABLES</b></para>
            <para>
            Your schema scripts may include variables of the form <b>${NAME}</b> where <b>NAME</b> is the
            case sensitive variable name.  The variable references will be replaced by the variable's
            value when the variable is defined, otherwise the variable reference will be left in place.
            </para>
            <para>
            The <b>${keyspace}</b> variable is reserved and will be replaced by the name of the Cassandra
            keyspace being managed. You can specify your own variables by passing a dictionary to the constructor.  
            This can be useful for specifying things like password, replication factors, etc.
            </para>
            <para><b>UPGRADE STRATEGIES</b></para>
            <para>
            The current implementation assumes that applications using the database are offline or can
            work properly with both the new and old schema.  Here are some siggestions for managing
            updates:
            </para>
            <list type="bullet">
                <item>
                Use YugaByte snapshots to backup the keyspace.
                </item>
                <item>
                Effectively take the keyspace offline during the upgrade by revoking all rights
                to all users besides the current one and the superuser before upgrading and then
                restoring these rights afterwards.
                </item>
                <item>
                For services and keyspaces deployed to Kubernetes, we recommend that you handle keyspace
                schema updates via a custom Kubernetes operator which would stop any services using the
                keyspace, apply the schema update, and then restart the services, potentially  upgrading 
                them as well.  You could embed the schema scripts in the operator itself so upgrading the
                keyspace (and application) would be as simple as upgrading the operator.
                </item>
            </list>
            <para><b>HANDLING UPGRADE ERRORS</b></para>
            <para>
            It's possible for a database upgrade to fail.  Addressing upgrade failures will generally
            require manual intervention.  You should start out by looking at the <b>version and </b><b>error</b>
            columns in the <see cref="F:Neon.Cassandra.SchemaManager.DbInfoTableName"/> in your database to diagnose what happened.
            <b>version</b> indicates the schema version before the update script was executed but that
            it's possible that the update script was paratially completed which means that the database
            may be in a state between the old and update schema version.
            </para>
            <para>
            Here are the underlying causes for upgrade errors:
            </para>
            <list type="table">
                <item>
                    <term><b>hardware/cluster</b></term>
                    <description>
                    <para>
                    The database cluster or the hardware/platform it's running is having problems
                    that prevent the updates from being applied.
                    </para>
                    <para>
                    The <b>error</b> column will describe the error.
                    </para>
                    </description>
                </item>
                <item>
                    <term><b>script errors</b></term>
                    <description>
                    <para>
                    Your upgrade scripts have syntax errors or are otherwise invalid.
                    </para>
                    <para>
                    The <b>error</b> column will describe the error.
                    </para>
                    </description>
                </item>
                <item>
                    <term><b>updater conflict</b></term>
                    <description>
                    <para>
                    Another updater is currently running or terminated for some reason 
                    before completing the update.
                    </para>
                    <para>
                    The <b>updater</b> column will identify the updater instance that is currently 
                    updating the database or that failed prematurely.
                    </para>
                    </description>
                </item>
            </list>
            <para>
            For <b>updater conflicts</b>, you'll need to determine whether the identified
            updater is still running or whether it has failed.  Simply wait for the other
            updater to finish if it's still running, otherwise you have a failure and will
            need to follow these recomendations to manually mitigate the situation:
            </para>
            <list type="table">
                <item>
                    <term><b>Manual Rollback</b></term>
                    <description>
                    It's possible that some but not all of the commands in your update script have 
                    completed.  Depending on the upgrade details, you may want to manually undo any 
                    of the statements that completed to get the database back to its state before
                    the the update started and then call <see cref="M:Neon.Cassandra.SchemaManager.UpgradeKeyspaceAsync(System.String,System.Int32,System.Boolean,System.Action{System.Boolean,System.Int32})"/>
                    with <c>force: true</c>.
                    </description>
                </item>
                <item>
                    <term><b>Manual Upgrade</b></term>
                    <description>
                    As an alternative to <b>Manual Rollback</b>, you could simply execute the remaining
                    update commands manually and then updating the <see cref="F:Neon.Cassandra.SchemaManager.DbInfoTableName"/> by setting
                    <b>version</b> to the new version number and setting the <b>updater</b> and <b>error</b>
                    fields to <c>NULL</c>.
                    </description>
                </item>
                <item>
                    <term><b>Script Corrections</b></term>
                    <description>
                    Be sure to correct any problems with your upgrade script, even if your are
                    going to manually complete the upgrade so that upgrades will work for new
                    database instances.
                    </description>
                </item>
            </list>
            <para><b>SCRIPTS AS EMBEDDED RESOURCES</b></para>
            <para>
            In addition to reading SQL scripts as standard files, the <see cref="T:Neon.Cassandra.SchemaManager"/> can
            also read scripts from embedded resources.  This is an easy and clean way to include these
            scripts in a program or library.  Here's what you need to do:
            </para>
            <list type="number">
                <item>
                Create a folder in your project to hold your SQL script files.
                </item>
                <item>
                Add your scripts to the new folder, saving them with **UTF-8 encoding**.
                </item>
                <item>
                Select your script files in the <b>Solution Explorer</b> and then left-click
                on them and select **Properties**.  Set **Build Action** to **Embedded resource**.
                </item>
                <item>
                You'll be using the <see cref="M:Neon.Cassandra.SchemaManager.#ctor(Cassandra.ISession,System.String,Neon.IO.IStaticDirectory,System.Collections.Generic.Dictionary{System.String,System.String})"/>
                override constructor and you'll be passing an <see cref="T:Neon.IO.IStaticDirectory"/> that emulates a read-only file system
                constructed from embedded resources.  You'll need to call <see cref="M:System.Reflection.NeonAssemblyExtensions.GetResourceFileSystem(System.Reflection.Assembly,System.String)"/>
                to obtain this directory, passing a string identifying resource name prefix that identifies your virtual folder.
                </item>
            </list>
            </remarks>
        </member>
        <member name="F:Neon.Cassandra.SchemaManager.DbInfoTableName">
            <summary>
            The name of the keyspace information table.
            </summary>
        </member>
        <member name="M:Neon.Cassandra.SchemaManager.#ctor(Cassandra.ISession,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Constructs an instance that loads scripts from files.
            </summary>
            <param name="session">
            The master keyspace session to be used for creating the target keyspace.  This session must have been made 
            for a Postgres superuser or a user with global <b>CREATE</b> permission.
            </param>
            <param name="keyspace">The keyspace name to be used.</param>
            <param name="schemaFolder">The path to the file system folder holding the keyspace schema scripts.</param>
            <param name="variables">Optionally specifies script variables.</param>
            <exception cref="T:System.IO.FileNotFoundException">
            Thrown if there's no directory at <see cref="F:Neon.Cassandra.SchemaManager.scriptFolder"/> or when there's no
            <b>schema-0.script</b> file in the directory.
            </exception>
        </member>
        <member name="M:Neon.Cassandra.SchemaManager.#ctor(Cassandra.ISession,System.String,Neon.IO.IStaticDirectory,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Constructs an instance that loads scripts from embedded resources.
            </summary>
            <param name="session">
            The master keyspace session to be used for creating the target keyspace.  This session must have been made 
            for a Postgres superuser or a user with global <b>CREATE</b> permission.
            </param>
            <param name="keyspace">The keyspace name to be used.</param>
            <param name="schemaDirectory">The embedded resource directory returned by a call to <see cref="M:System.Reflection.NeonAssemblyExtensions.GetResourceFileSystem(System.Reflection.Assembly,System.String)"/>.</param>
            <param name="variables">Optionally specifies script variables.</param>
            <exception cref="T:System.IO.FileNotFoundException">
            Thrown if there's no directory at <see cref="F:Neon.Cassandra.SchemaManager.scriptFolder"/> or when there's no
            <b>schema-0.script</b> file in the directory.
            </exception>
        </member>
        <member name="M:Neon.Cassandra.SchemaManager.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Cassandra.SchemaManager.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Cassandra.SchemaManager.Dispose(System.Boolean)">
            <summary>
            Handles the actual disposal.
            </summary>
            <param name="disposing"><b>true</b> if we're disposing, <c>false</c> for finalizing.</param>
        </member>
        <member name="M:Neon.Cassandra.SchemaManager.LoadScript(System.String)">
            <summary>
            Reads the script text from a file path, replacing any variable references with the
            variable's value.
            </summary>
            <param name="scriptPath">The script file path.</param>
            <returns>The processed script text.</returns>
        </member>
        <member name="M:Neon.Cassandra.SchemaManager.LoadScript(Neon.IO.IStaticFile)">
            <summary>
            Reads the script text from an embedded resource file, replacing any variable references with the
            variable's value.
            </summary>
            <param name="scriptFile">The embedded resurce script file.</param>
            <returns>The processed script text.</returns>
        </member>
        <member name="M:Neon.Cassandra.SchemaManager.CreateKeyspaceAsync">
            <summary>
            Creates the keyspace using the <b>schema-0.script</b> file from the script folder.  This also
            creates the <see cref="F:Neon.Cassandra.SchemaManager.DbInfoTableName"/> table adds a row setting the Version to 0.
            </summary>
            <returns><c>true</c> if the keyspace was created or <c>false</c> if it already exists.</returns>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if the <b>schema-0.script</b> file does not exist in the script folder.</exception>
            <exception cref="T:Neon.Cassandra.SchemaManagerException">
            Thrown if the keyspace already exists but does not include the <see cref="F:Neon.Cassandra.SchemaManager.DbInfoTableName"/>
            table or if that table doesn't have exactly one row or the version there is
            not positive.
            </exception>
        </member>
        <member name="M:Neon.Cassandra.SchemaManager.GetStatusAsync">
            <summary>
            Returns information about the keyspace schema status and schema scripts.
            </summary>
            <returns>The <see cref="T:Neon.Cassandra.KeyspaceStatus"/>.</returns>
            <exception cref="T:Neon.Cassandra.SchemaManagerException">Thrown when the keyspace has an invalid <see cref="F:Neon.Cassandra.SchemaManager.DbInfoTableName"/> table.</exception>
        </member>
        <member name="M:Neon.Cassandra.SchemaManager.UpgradeKeyspaceAsync(System.String,System.Int32,System.Boolean,System.Action{System.Boolean,System.Int32})">
            <summary>
            Upgrades the keyspace by applying any upgrade scripts from the current keyspace
            version to the latest update script found in the script folder or optionally when
            the keyspace version equals <paramref name="stopVersion"/>.
            </summary>
            <param name="updaterIdentity">
            <para>
            Optionally specifies the identity of the entity performing the update.  This may be the
            username of the person doing this or something identifying the service instance for
            more automated scenarios.  This service identity could be a hostname, container ID,
            or something else that makes sense.  This is used to ensure that only a single entity
            can update the keyspace.
            </para>
            <para>
            This defaults to a generated GUID.
            </para>
            </param>
            <param name="stopVersion">Optionally specifies the latest keyspace update to apply.</param>
            <param name="force">
            <para>
            Optionally specifies that any indication that another updater is in the process of
            updating the keyspace will be ignored and that any pewnding updates will proceed.
            This may be necessary after a previous update failed.
            </para>
            <note>
            <b>WARNING:</b> You should take care to ensure that the other potential updater is
            not actually performing an update.  This may also means that the previous update
            was only partially completed which could require manual intervention.
            </note>
            </param>
            <param name="updateAction">
            Optional action that will be called before each update is applied and then afterwards.
            The <c>bool</c> argument will be <c>false</c> before the update is applied and <c>true</c>
            afterwards.  The <c>int</c> argument is the schema version being applied.
            </param>
            <returns>The version of the keyspace after the upgrade.</returns>
            <exception cref="T:Neon.Cassandra.SchemaManagerException">
            Thrown if the keyspace doesn't exist or does not include the
            <see cref="F:Neon.Cassandra.SchemaManager.DbInfoTableName"/> table or if it invalid.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">
            Thrown if the <b>schema-0.script</b> file does not exist or when there are
            any missing script files (e.g. gaps in the sequence of files) or there
            are scripts with unexpected file names.
            </exception>
            <exception cref="T:Neon.Cassandra.SchemaManagerException">
            Thrown when another entity currently is in the process of updating the
            keyspace schema.
            </exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> This method does not perform the schema updates within a transaction
            because that will be impractical for large keyspaces and also due to limitations of
            YugaByte Postgres.  This means that you'll need to take care to ensure that your
            schema scripts are well tested and bulletproof and you should also consider backing
            up your keyspace to be very safe.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Cassandra.SchemaManagerException">
            <summary>
            Thrown by <see cref="T:Neon.Cassandra.SchemaManager"/> when a problem is detected.
            </summary>
        </member>
        <member name="M:Neon.Cassandra.SchemaManagerException.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies the nexception message.</param>
        </member>
        <member name="T:Neon.Cassandra.SchemaStatus">
            <summary>
            Enumerates the possible keyspace states as returned by <see cref="M:Neon.Cassandra.SchemaManager.GetStatusAsync"/>.
            </summary>
        </member>
        <member name="F:Neon.Cassandra.SchemaStatus.NotFound">
            <summary>
            The database doesn't exist.
            </summary>
        </member>
        <member name="F:Neon.Cassandra.SchemaStatus.ExistsNoSchema">
            <summary>
            The database exists but has no <see cref="F:Neon.Cassandra.SchemaManager.DbInfoTableName"/> table 
            with any schema information.
            </summary>
        </member>
        <member name="F:Neon.Cassandra.SchemaStatus.ExistsWithSchema">
            <summary>
            The database exists with schema information.
            </summary>
        </member>
        <member name="F:Neon.Cassandra.SchemaStatus.Updating">
            <summary>
            Another updater is currently updating the database or has failed before
            completing the update.
            </summary>
        </member>
        <member name="F:Neon.Cassandra.SchemaStatus.UpgradeError">
            <summary>
            An error occured during the previous update indicating that the database
            schema may have been partially updated.  It's likely that manual intervention
            may be necessary to rollback to the previous schema version or manually
            apply the remaining updates.
            </summary>
        </member>
        <member name="T:Neon.Cassandra.SessionExtensions">
            <summary>
            Extends <see cref="T:Cassandra.ISession"/> with useful methods.
            </summary>
        </member>
        <member name="M:Neon.Cassandra.SessionExtensions.SplitBatch(System.String)">
            <summary>
            Splits a batch of SQL commands potentially separated by <b>go</b> lines
            into the distinct commands.
            </summary>
            <param name="batchText">The command batch.</param>
            <returns>The list of SQL commands from the batch.</returns>
        </member>
        <member name="M:Neon.Cassandra.SessionExtensions.ExecuteBatch(Cassandra.ISession,System.String)">
            <summary>
            <para>
            Executes a batch of SQL commands saeparated by lines including <b>go</b>
            separators.  This works like Microsoft SQL server related tools.
            </para>
            <note>
            <para>
            The term <i>batch</i> here is different from the usual Cassandra terminology,
            where batch refers an <see cref="T:Cassandra.BatchStatement"/> which may include multiple
            statements that are executed together atomically.  Batch here refers to statements
            extracted from the text passed and then executed <b>individually</b>.
            </para>
            <para>
            Sorry for the confusion here, but we used this to be consistent with the our
            Postgres extensions and frankly, we couldn't think of a better term.
            </para>
            </note>
            </summary>
            <param name="session">The database session.</param>
            <param name="batchText">The SQL commands possibly separated by <b>go</b> lines.</param>
            <remarks>
            <para>
            It's often necessary to execute a sequence of SQL commands that depend on
            each other.  One example is a command that creates a table followed by 
            commands that write rows.  You might think that you could achieve this
            by executing the following as one command:
            </para>
            <code language="sql">
            CREATE TABLE my_table (name text);
            INSERT INTO my_table (name) values ('Jack');
            INSERT INTO my_table (name) values ('Jill');
            </code>
            <para>
            but this won't actually work because the database generates a query plan
            for the entire command and when it does this and sees the inserts into
            [my_table] but the table doesn't actually exist at the time the query
            plan is being created.  So the command will fail.
            </para>
            <para>
            What you really need to do is create the table first as a separate
            command and then do the inserts as one or more subsequent commands.
            This is not terribly convenient so we've introduced the concept of
            a batch of commands via this method.  Here's what this would look like:
            </para>
            <code language="sql">
            CREATE TABLE my_table (name text);
            go
            INSERT INTO my_table (name) values ('Jack');
            INSERT INTO my_table (name) values ('Jill');
            </code>
            <para>
            See how the <b>go</b> line separates the table creation from the inserts.
            This method will split the <paramref name="batchText"/> into separate
            commands on any <b>go</b> lines and then execute these commands in order.
            </para>
            <note>
            <b>go</b> is case insensitive and any leading or trailing space on the
            line will be ignored.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cassandra.SessionExtensions.ExecuteBatchAsync(Cassandra.ISession,System.String)">
            <summary>
            <para>
            Asynchronously a batch of SQL commands saeparated by lines including <b>go</b>
            separators.  This works like Microsoft SQL server related tools.
            </para>
            <note>
            <para>
            The term <i>batch</i> here is different from the usual Cassandra terminology,
            where batch refers an <see cref="T:Cassandra.BatchStatement"/> which may include multiple
            statements that are executed together atomically.  Batch here refers to statements
            extracted from the text passed and then executed <b>individually</b>.
            </para>
            <para>
            Sorry for the confusion here, but we used this to be consistent with the our
            Postgres extensions and frankly, we couldn't think of a better term.
            </para>
            </note>
            </summary>
            <param name="session">The database session.</param>
            <param name="batchText">The SQL commands possibly separated by <b>go</b> lines.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            <note>
            This method doesn't actually execute the statements asynchronously because
            the Cassandra driver doesn't include an <b>ISession.ExecuteAsync(string)</b>
            method.  This method simply calls <see cref="M:Neon.Cassandra.SessionExtensions.ExecuteBatch(Cassandra.ISession,System.String)"/>.
            We're retaining this method for compatibility with our Postgres extensions.
            </note>
            <para>
            It's often necessary to execute a sequence of SQL commands that depend on
            each other.  One example is a command that creates a table followed by 
            commands that write rows.  You might think that you could achieve this
            by executing the following as one command:
            </para>
            <code language="sql">
            CREATE TABLE my_table (name text);
            INSERT INTO my_table (name) values ('Jack');
            INSERT INTO my_table (name) values ('Jill');
            </code>
            <para>
            but this won't actually work because the database generates a query plan
            for the entire command and when it does this and sees the inserts into
            [my_table] but the table doesn't actually exist at the time the query
            plan is being created.  So the command will fail.
            </para>
            <para>
            What you really need to do is create the table first as a separate
            command and then do the inserts as one or more subsequent commands.
            This is not terribly convenient so we've introduced the concept of
            a batch of commands via this method.  Here's what this would look like:
            </para>
            <code language="sql">
            CREATE TABLE my_table (name text);
            go
            INSERT INTO my_table (name) values ('Jack');
            INSERT INTO my_table (name) values ('Jill');
            </code>
            <para>
            See how the <b>go</b> line separates the table creation from the inserts.
            This method will split the <paramref name="batchText"/> into separate
            commands on any <b>go</b> lines and then execute these commands in order.
            </para>
            <note>
            <b>go</b> is case insensitive and any leading or trailing space on the
            line will be ignored.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Cassandra.SessionExtensions.ExecuteAsync(Cassandra.ISession,System.String)">
            <summary>
            Executes a text command asynchronously.
            </summary>
            <param name="session">The database session.</param>
            <param name="cqlText">The command or query text.</param>
            <returns>The resulting <see cref="T:Cassandra.RowSet"/>.</returns>
        </member>
    </members>
</doc>
