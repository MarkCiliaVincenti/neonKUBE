//-----------------------------------------------------------------------------
// This file was generated by the [Neon.ModelGen] library.  Any manual changes
// will be lost when the file is regenerated.

#pragma warning disable 0108     // Disable property overrides without new warnings
#pragma warning disable 0168     // Disable declared but never used warnings
#pragma warning disable 1591     // Disable missing comment warnings

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Dynamic;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

using Neon.ModelGen;
using Neon.Collections;
using Neon.Common;
using Neon.Data;
using Neon.Diagnostics;
using Neon.Net;
using Neon.Retry;
using Neon.Tasks;

using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;

namespace Test.Neon.Models
{
    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.BaseModel

    /// <threadsafety static="true" instance="false"/>
    public partial class BaseModel : IRoundtripData
    {
        //---------------------------------------------------------------------
        // Static members:

        /// <summary>
        /// Static constructor.
        /// </summary>
        static BaseModel()
        {
            // You need to add a reference to the [Neon.Common] assembly if the following line doesn't compile.

            NeonHelper.PackageReferenceToNeonCommonIsRequired();
        }

        /// <summary>
        /// Deserializes an instance from JSON text.
        /// </summary>
        /// <param name="jsonText">The JSON text input.</param>
        /// <returns>The deserialized <see cref="BaseModel"/>.</returns>
        public static BaseModel CreateFrom(string jsonText)
        {
            if (string.IsNullOrEmpty(jsonText))
            {
                throw new ArgumentNullException(nameof(jsonText));
            }

            var model = new BaseModel(RoundtripDataHelper.Deserialize<JObject>(jsonText));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject">The input <see cref="JObject"/>.</param>
        /// <returns>The deserialized <see cref="BaseModel"/>.</returns>
        public static BaseModel CreateFrom(JObject jObject)
        {
            if (jObject == null)
            {
                throw new ArgumentNullException(nameof(jObject));
            }

            var model = new BaseModel(jObject);

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="BaseModel"/>.</returns>
        public static BaseModel CreateFrom(Stream stream, Encoding encoding = null)
        {
            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            BaseModel model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = BaseModel.CreateFrom(reader.ReadToEnd());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a UTF-8 encoded byte array.
        /// </summary>
        /// <param name="bytes">The input byte array.</param>
        /// <returns>The deserialized <see cref="BaseModel"/>.</returns>
        public static BaseModel CreateFrom(byte[] bytes)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            var model = CreateFrom(Encoding.UTF8.GetString(bytes));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Asynchronously deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="BaseModel"/>.</returns>
        public static async Task<object> CreateFromAsync(Stream stream, Encoding encoding = null)
        {
            await SyncContext.ClearAsync;

            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            BaseModel model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = BaseModel.CreateFrom(await reader.ReadToEndAsync());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JsonResponse"/>.
        /// </summary>
        /// <param name="response">The input <see cref="JsonResponse"/>.</param>
        /// <returns>The deserialized <see cref="BaseModel"/>.</returns>
        public static BaseModel CreateFrom(JsonResponse response)
        {
            if (response == null)
            {
                throw new ArgumentNullException(nameof(response));
            }

            return CreateFrom(response.JsonText);
        }

        /// <summary>
        /// Compares two instances for equality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are equal.</returns>
        public static bool operator ==(BaseModel value1, BaseModel value2)
        {
            var value1IsNull = object.ReferenceEquals(value1, null);
            var value2IsNull = object.ReferenceEquals(value2, null);

            if (value1IsNull == value2IsNull)
            {
                if (value1IsNull)
                {
                    return true;
                }
                else
                {
                    return value1.Equals(value2);
                }
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Compares two instances for inequality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are not equal.</returns>
        public static bool operator !=(BaseModel value1, BaseModel value2)
        {
            return !(value1 == value2);
        }

        //---------------------------------------------------------------------
        // Instance members:

        /// <summary>
        /// <b>INTERNAL USE ONLY:</b> This is the <see cref="JObject"/> is used to back
        /// all serialized round-trip.  This was made public for advanced unit testing but
        /// its use should generally be avoided for other purposes.  Use <see cref="ToJObject()"/>.
        /// instead.  "__O" is short for "object".
        /// </summary>
        [JsonIgnore]
        public JObject __O { get; set; }

        /// <summary>
        /// Constructs an uninitialized instance.
        /// </summary>
        public BaseModel()
        {
            __O = new JObject();
        }

        /// <summary>
        /// Protected constructor used internally to initialize derived classes.
        /// </summary>
        /// <param name="jObject">The backing <see cref="JObject"/>.</param>
        protected BaseModel(JObject jObject)
        {
            __O = jObject;
        }

        [JsonProperty(PropertyName = "ParentProperty", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public string ParentProperty { get; set; }

        /// <summary>
        /// Loads the entity properties from the backing <see cref="JObject"/>
        /// or from the optional <see cref="JObject"/> passed.
        /// </summary>
        /// <param name="source">The optional source <see cref="JObject"/>.</param>
        /// <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        public virtual void __Load(JObject source = null, bool isDerived = false)
        {
            JProperty property;

            if (source != null)
            {
                this.__O = source;
            }

            if (this.__O == null)
            {
                this.__O = new JObject();
            }

            property = this.__O.Property("ParentProperty");
            if (property != null)
            {
                this.ParentProperty = (string)property.Value;
            }
        }

        /// <summary>
        /// Persists the properties from this instance to the backing <see cref="JObject"/>.
        /// </summary>
        /// <returns>The backing <see cref="JObject"/>.</returns>
        public virtual JObject __Save()
        {
            JProperty property;

            if (__O == null)
            {
                __O = new JObject();
            }

            this.__O["ParentProperty"] = this.ParentProperty;

            return this.__O;
        }

        /// <summary>
        /// Renders the instance as JSON text.
        /// </summary>
        /// <returns>The serialized JSON string.</returns>
        public override string ToString()
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, Formatting.None);
        }

        /// <summary>
        /// Renders the instance as JSON text, optionally formatting the output.
        /// </summary>
        /// <param name="indented">Optionally pass <c>true</c> to format the output.</param>
        /// <returns>The serialized JSON string.</returns>
        public string ToString(bool indented)
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, indented ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Renders the instance as a new <see cref="JObject"/>.
        /// </summary>
        /// <returns>The rendered <see cref="JObject"/>.</returns>
        public JObject ToJObject()
        {
            __Save();
            return RoundtripDataHelper.DeepClone(__O);
        }

        /// <summary>
        /// Renders the instance as UTF-8 encoded JSON.
        /// </summary>
        /// <returns>The serialized JSON bytes.</returns>
        public virtual byte[] ToBytes()
        {
            __Save();
            return Encoding.UTF8.GetBytes(RoundtripDataHelper.Serialize(__O, Formatting.None));
        }

        /// <summary>
        /// Returns a deep clone of the instance.
        /// </summary>
        /// <returns>The cloned instance.</returns>
        public BaseModel DeepClone()
        {
            __Save();
            return CreateFrom(RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Used to convert a base data model class into a derived class.
        /// </summary>
        /// <typeparam name="T">The desired derived type.</typeparam>
        /// <param name="noClone">
        /// By default, this method will create a deep clone of the underlying <see cref="JObject"/>
        /// and use this new instance when constructing the new object.  This is the safest
        /// approach but will cause a performance hit.  You can pass <paramref name="noClone"/><c>=true</c>
        /// to reuse the existing <see cref="JObject"/> for the new instance if you're sure that the
        /// original instance will no longer be accessed.
        /// </param>
        /// <returns>The converted instance of type <typeparamref name="T"/>.</returns>
        public T ToDerived<T>(bool noClone = false)
           where T : BaseModel, IRoundtripData
        {
            __Save();
            return RoundtripDataFactory.CreateFrom<T>(noClone ? __O : RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Determines whether the current instance equals another object.
        /// </summary>
        /// <param name="obj">The other object instance or <c>null</c>.</param>
        /// <returns><c>true</c> if the object reference equals the current instance.</returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as BaseModel;

            if (object.ReferenceEquals(other, null))
            {
                return false;
            }

            this.__Save();
            other.__Save();
            return JObject.DeepEquals(this.__O, other.__O);
        }

        /// <summary>
        /// Calculates the hash code for the instance.
        /// <note>
        /// At least one of the class properties must be tagged with a <b>[HashSource]</b>
        /// for this to work.
        /// </note>
        /// </summary>
        /// <returns>The calculated hash code.</returns>
        /// <exception cref="InvalidOperationException">Thrown when no class properties are tagged with a <c>[HashSourceAttribute]</c>.</exception>
        public override int GetHashCode()
        {
            var hashCode = 0;

            if (this.ParentProperty != null) { hashCode ^= this.ParentProperty.GetHashCode(); }

            return hashCode;
        }

        /// <summary>
        /// Writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        public virtual void WriteJsonTo(Stream stream)
        {
            __Save();

            using (var writer = new JsonTextWriter(new StreamWriter(stream)))
            {
                __O.WriteTo(writer);
            }
        }

        /// <summary>
        /// Asynchronously writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        /// <returns>The tracking <see cref="Task"/>.</returns>
        public virtual async Task WriteJsonToAsync(Stream stream)
        {
            await SyncContext.ClearAsync;
            __Save();

            await stream.WriteAsync(Encoding.UTF8.GetBytes(__O.ToString()));
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.City

    /// <threadsafety static="true" instance="false"/>
    public partial class City : IRoundtripData, IPersistableType<City>
    {
        //---------------------------------------------------------------------
        // Private types:

        /// <summary>
        /// Used to tag the <see cref="City"/> entity such that Linq2Couchbase will
        /// be able to transparently add a <c>where</c> clause that filters by entity type
        /// to all queries for this entity type.
        /// </summary>
        private class CityFilter : global::Couchbase.Linq.Filters.IDocumentFilter<City>
        {
            //-----------------------------------------------------------------
            // Static members:

            private static Expression<Func<City, bool>> whereExpression;

            static CityFilter()
            {
                var parameter = Expression.Parameter(typeof(City), "p");

                whereExpression = Expression.Lambda<Func<City, bool>>(Expression.Equal(Expression.PropertyOrField(parameter, "__T"), Expression.Constant(City.PersistedType)), parameter);
            }

            //-----------------------------------------------------------------
            // Instance members:

            public int Priority { get; set; }

            public IQueryable<City> ApplyFilter(IQueryable<City> source)
            {
                return source.Where(whereExpression);
            }
        }

        //---------------------------------------------------------------------
        // Static members:

        public const string PersistedType = "Test.Neon.Models.Definitions.City";

        /// <summary>
        /// Static constructor.
        /// </summary>
        static City()
        {
            // You need to add a reference to the [Neon.Common] assembly if the following line doesn't compile.

            NeonHelper.PackageReferenceToNeonCommonIsRequired();
        }

        /// <summary>
        /// Performs any persistence related initialization including registering the Linq2Couchbase type
        /// filter.  This is typically called via <see cref="RoundtripDataHelper.PersistableInitialize()"/>.
        /// </summary>
        public static void PersistableInitialize()
        {
            // Register the document filter with Linq2Couchbase.

            global::Couchbase.Linq.Filters.DocumentFilterManager.SetFilter<City>(new CityFilter());
        }

        /// <summary>
        /// Deserializes an instance from JSON text.
        /// </summary>
        /// <param name="jsonText">The JSON text input.</param>
        /// <returns>The deserialized <see cref="City"/>.</returns>
        public static City CreateFrom(string jsonText)
        {
            if (string.IsNullOrEmpty(jsonText))
            {
                throw new ArgumentNullException(nameof(jsonText));
            }

            var model = new City(RoundtripDataHelper.Deserialize<JObject>(jsonText));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject">The input <see cref="JObject"/>.</param>
        /// <returns>The deserialized <see cref="City"/>.</returns>
        public static City CreateFrom(JObject jObject)
        {
            if (jObject == null)
            {
                throw new ArgumentNullException(nameof(jObject));
            }

            var model = new City(jObject);

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="City"/>.</returns>
        public static City CreateFrom(Stream stream, Encoding encoding = null)
        {
            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            City model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = City.CreateFrom(reader.ReadToEnd());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a UTF-8 encoded byte array.
        /// </summary>
        /// <param name="bytes">The input byte array.</param>
        /// <returns>The deserialized <see cref="City"/>.</returns>
        public static City CreateFrom(byte[] bytes)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            var model = CreateFrom(Encoding.UTF8.GetString(bytes));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Asynchronously deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="City"/>.</returns>
        public static async Task<object> CreateFromAsync(Stream stream, Encoding encoding = null)
        {
            await SyncContext.ClearAsync;

            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            City model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = City.CreateFrom(await reader.ReadToEndAsync());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JsonResponse"/>.
        /// </summary>
        /// <param name="response">The input <see cref="JsonResponse"/>.</param>
        /// <returns>The deserialized <see cref="City"/>.</returns>
        public static City CreateFrom(JsonResponse response)
        {
            if (response == null)
            {
                throw new ArgumentNullException(nameof(response));
            }

            return CreateFrom(response.JsonText);
        }

        /// <summary>
        /// Determines whether another entity instance has the same underlying type as this class.
        /// </summary>
        /// <param name="instance">The instance to be tested or <c>null</c>.</param>
        /// <returns>
        /// <c>true</c> if the <paramref name="instance"/> is not <c>null</c> and it has
        /// the same type as the current class.
        /// </returns>
        public static bool SameTypeAs(IPersistableType instance)
        {
            if (instance == null)
            {
                return false;
            }

            return instance.__T == City.PersistedType;
        }

        /// <summary>
        /// Creates a persistence key.
        /// </summary>
        /// <param name="args">Arguments identifying the item.</param>
        public static string CreateKey(params object[] args)
        {
            return RoundtripDataHelper.GetPersistedKey("Test.Neon.Models.Definitions.City", args);
        }

        /// <summary>
        /// Compares two instances for equality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are equal.</returns>
        public static bool operator ==(City value1, City value2)
        {
            var value1IsNull = object.ReferenceEquals(value1, null);
            var value2IsNull = object.ReferenceEquals(value2, null);

            if (value1IsNull == value2IsNull)
            {
                if (value1IsNull)
                {
                    return true;
                }
                else
                {
                    return value1.Equals(value2);
                }
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Compares two instances for inequality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are not equal.</returns>
        public static bool operator !=(City value1, City value2)
        {
            return !(value1 == value2);
        }

        //---------------------------------------------------------------------
        // Instance members:

        private string cachedT;

        /// <summary>
        /// <b>INTERNAL USE ONLY:</b> This is the <see cref="JObject"/> is used to back
        /// all serialized round-trip.  This was made public for advanced unit testing but
        /// its use should generally be avoided for other purposes.  Use <see cref="ToJObject()"/>.
        /// instead.  "__O" is short for "object".
        /// </summary>
        [JsonIgnore]
        public JObject __O { get; set; }

        /// <summary>
        /// Constructs an uninitialized instance.
        /// </summary>
        public City()
        {
            __T = PersistedType;
            __O = new JObject();
        }

        /// <summary>
        /// Protected constructor used internally to initialize derived classes.
        /// </summary>
        /// <param name="jObject">The backing <see cref="JObject"/>.</param>
        protected City(JObject jObject)
        {
            __T = PersistedType;
            __O = jObject;
        }

        [JsonProperty(PropertyName = "Name", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public string Name { get; set; }

        [JsonProperty(PropertyName = "Population", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public int Population { get; set; }

        /// <summary>
        /// Loads the entity properties from the backing <see cref="JObject"/>
        /// or from the optional <see cref="JObject"/> passed.
        /// </summary>
        /// <param name="source">The optional source <see cref="JObject"/>.</param>
        /// <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        public virtual void __Load(JObject source = null, bool isDerived = false)
        {
            JProperty property;

            if (source != null)
            {
                this.__O = source;
            }

            if (this.__O == null)
            {
                this.__O = new JObject();
            }

            property = this.__O.Property("Name");
            if (property != null)
            {
                this.Name = (string)property.Value;
            }

            property = this.__O.Property("Population");
            if (property != null)
            {
                this.Population = (int)property.Value;
            }

            if (!isDerived)
            {
                property = this.__O.Property("T$$");
                if (property == null)
                {
                    throw new ArgumentNullException("[City.T$$] property is required when deserializing.");
                }
                else
                {
                    this.__T = (string)property.Value;
                }
            }
        }

        /// <summary>
        /// Persists the properties from this instance to the backing <see cref="JObject"/>.
        /// </summary>
        /// <returns>The backing <see cref="JObject"/>.</returns>
        public virtual JObject __Save()
        {
            JProperty property;

            if (__O == null)
            {
                __O = new JObject();
            }

            this.__O["Name"] = this.Name;
            this.__O["Population"] = this.Population;
            this.__O["T$$"] = PersistedType;

            return this.__O;
        }

        /// <summary>
        /// Renders the instance as JSON text.
        /// </summary>
        /// <returns>The serialized JSON string.</returns>
        public override string ToString()
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, Formatting.None);
        }

        /// <summary>
        /// Renders the instance as JSON text, optionally formatting the output.
        /// </summary>
        /// <param name="indented">Optionally pass <c>true</c> to format the output.</param>
        /// <returns>The serialized JSON string.</returns>
        public string ToString(bool indented)
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, indented ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Renders the instance as a new <see cref="JObject"/>.
        /// </summary>
        /// <returns>The rendered <see cref="JObject"/>.</returns>
        public JObject ToJObject()
        {
            __Save();
            return RoundtripDataHelper.DeepClone(__O);
        }

        /// <summary>
        /// Renders the instance as UTF-8 encoded JSON.
        /// </summary>
        /// <returns>The serialized JSON bytes.</returns>
        public virtual byte[] ToBytes()
        {
            __Save();
            return Encoding.UTF8.GetBytes(RoundtripDataHelper.Serialize(__O, Formatting.None));
        }

        /// <summary>
        /// Returns a deep clone of the instance.
        /// </summary>
        /// <returns>The cloned instance.</returns>
        public City DeepClone()
        {
            __Save();
            return CreateFrom(RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Used to convert a base data model class into a derived class.
        /// </summary>
        /// <typeparam name="T">The desired derived type.</typeparam>
        /// <param name="noClone">
        /// By default, this method will create a deep clone of the underlying <see cref="JObject"/>
        /// and use this new instance when constructing the new object.  This is the safest
        /// approach but will cause a performance hit.  You can pass <paramref name="noClone"/><c>=true</c>
        /// to reuse the existing <see cref="JObject"/> for the new instance if you're sure that the
        /// original instance will no longer be accessed.
        /// </param>
        /// <returns>The converted instance of type <typeparamref name="T"/>.</returns>
        public T ToDerived<T>(bool noClone = false)
           where T : City, IRoundtripData
        {
            __Save();
            return RoundtripDataFactory.CreateFrom<T>(noClone ? __O : RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Determines whether the current instance equals another object.
        /// </summary>
        /// <param name="obj">The other object instance or <c>null</c>.</param>
        /// <returns><c>true</c> if the object reference equals the current instance.</returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as City;

            if (object.ReferenceEquals(other, null))
            {
                return false;
            }

            this.__Save();
            other.__Save();
            return JObject.DeepEquals(this.__O, other.__O);
        }

        /// <summary>
        /// Calculates the hash code for the instance.
        /// <note>
        /// At least one of the class properties must be tagged with a <b>[HashSource]</b>
        /// for this to work.
        /// </note>
        /// </summary>
        /// <returns>The calculated hash code.</returns>
        /// <exception cref="InvalidOperationException">Thrown when no class properties are tagged with a <c>[HashSourceAttribute]</c>.</exception>
        public override int GetHashCode()
        {
            throw new InvalidOperationException(RoundtripDataHelper.NoHashPropertiesError);
        }

        /// <summary>
        /// Identifies the persisted object type.  "__T" is short for "type".  This is persisted as "T$$".
        /// </summary>
        [JsonProperty(PropertyName = "T$$", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        [DefaultValue(null)]
        public string __T
        {
            get
            {
                 if (cachedT != null)
                 {
                     return cachedT;
                 }

                 cachedT = (string)__O["T$$"];

                 if (cachedT != null)
                 {
                     return cachedT;
                 }

                 return PersistedType;
            }

            set => cachedT = value;
        }

        /// <summary>
        /// Returns the object's persistence key.
        /// </summary>
        public string GetKey()
        {
            if (Name == null)
            {
                throw new NotSupportedException("Persistence key property [Name] cannot be NULL.");
            }

            return RoundtripDataHelper.GetPersistedKey(PersistedType, Name);
        }

        /// <summary>
        /// Writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        public virtual void WriteJsonTo(Stream stream)
        {
            __Save();

            using (var writer = new JsonTextWriter(new StreamWriter(stream)))
            {
                __O.WriteTo(writer);
            }
        }

        /// <summary>
        /// Asynchronously writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        /// <returns>The tracking <see cref="Task"/>.</returns>
        public virtual async Task WriteJsonToAsync(Stream stream)
        {
            await SyncContext.ClearAsync;
            __Save();

            await stream.WriteAsync(Encoding.UTF8.GetBytes(__O.ToString()));
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.Country

    /// <threadsafety static="true" instance="false"/>
    public partial class Country : IRoundtripData, IPersistableType<Country>
    {
        //---------------------------------------------------------------------
        // Private types:

        /// <summary>
        /// Used to tag the <see cref="Country"/> entity such that Linq2Couchbase will
        /// be able to transparently add a <c>where</c> clause that filters by entity type
        /// to all queries for this entity type.
        /// </summary>
        private class CountryFilter : global::Couchbase.Linq.Filters.IDocumentFilter<Country>
        {
            //-----------------------------------------------------------------
            // Static members:

            private static Expression<Func<Country, bool>> whereExpression;

            static CountryFilter()
            {
                var parameter = Expression.Parameter(typeof(Country), "p");

                whereExpression = Expression.Lambda<Func<Country, bool>>(Expression.Equal(Expression.PropertyOrField(parameter, "__T"), Expression.Constant(Country.PersistedType)), parameter);
            }

            //-----------------------------------------------------------------
            // Instance members:

            public int Priority { get; set; }

            public IQueryable<Country> ApplyFilter(IQueryable<Country> source)
            {
                return source.Where(whereExpression);
            }
        }

        //---------------------------------------------------------------------
        // Static members:

        public const string PersistedType = "Test.Neon.Models.Definitions.Country";

        /// <summary>
        /// Static constructor.
        /// </summary>
        static Country()
        {
            // You need to add a reference to the [Neon.Common] assembly if the following line doesn't compile.

            NeonHelper.PackageReferenceToNeonCommonIsRequired();
        }

        /// <summary>
        /// Performs any persistence related initialization including registering the Linq2Couchbase type
        /// filter.  This is typically called via <see cref="RoundtripDataHelper.PersistableInitialize()"/>.
        /// </summary>
        public static void PersistableInitialize()
        {
            // Register the document filter with Linq2Couchbase.

            global::Couchbase.Linq.Filters.DocumentFilterManager.SetFilter<Country>(new CountryFilter());
        }

        /// <summary>
        /// Deserializes an instance from JSON text.
        /// </summary>
        /// <param name="jsonText">The JSON text input.</param>
        /// <returns>The deserialized <see cref="Country"/>.</returns>
        public static Country CreateFrom(string jsonText)
        {
            if (string.IsNullOrEmpty(jsonText))
            {
                throw new ArgumentNullException(nameof(jsonText));
            }

            var model = new Country(RoundtripDataHelper.Deserialize<JObject>(jsonText));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject">The input <see cref="JObject"/>.</param>
        /// <returns>The deserialized <see cref="Country"/>.</returns>
        public static Country CreateFrom(JObject jObject)
        {
            if (jObject == null)
            {
                throw new ArgumentNullException(nameof(jObject));
            }

            var model = new Country(jObject);

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="Country"/>.</returns>
        public static Country CreateFrom(Stream stream, Encoding encoding = null)
        {
            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            Country model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = Country.CreateFrom(reader.ReadToEnd());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a UTF-8 encoded byte array.
        /// </summary>
        /// <param name="bytes">The input byte array.</param>
        /// <returns>The deserialized <see cref="Country"/>.</returns>
        public static Country CreateFrom(byte[] bytes)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            var model = CreateFrom(Encoding.UTF8.GetString(bytes));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Asynchronously deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="Country"/>.</returns>
        public static async Task<object> CreateFromAsync(Stream stream, Encoding encoding = null)
        {
            await SyncContext.ClearAsync;

            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            Country model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = Country.CreateFrom(await reader.ReadToEndAsync());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JsonResponse"/>.
        /// </summary>
        /// <param name="response">The input <see cref="JsonResponse"/>.</param>
        /// <returns>The deserialized <see cref="Country"/>.</returns>
        public static Country CreateFrom(JsonResponse response)
        {
            if (response == null)
            {
                throw new ArgumentNullException(nameof(response));
            }

            return CreateFrom(response.JsonText);
        }

        /// <summary>
        /// Determines whether another entity instance has the same underlying type as this class.
        /// </summary>
        /// <param name="instance">The instance to be tested or <c>null</c>.</param>
        /// <returns>
        /// <c>true</c> if the <paramref name="instance"/> is not <c>null</c> and it has
        /// the same type as the current class.
        /// </returns>
        public static bool SameTypeAs(IPersistableType instance)
        {
            if (instance == null)
            {
                return false;
            }

            return instance.__T == Country.PersistedType;
        }

        /// <summary>
        /// Creates a persistence key.
        /// </summary>
        /// <param name="args">Arguments identifying the item.</param>
        public static string CreateKey(params object[] args)
        {
            return RoundtripDataHelper.GetPersistedKey("Test.Neon.Models.Definitions.Country", args);
        }

        /// <summary>
        /// Compares two instances for equality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are equal.</returns>
        public static bool operator ==(Country value1, Country value2)
        {
            var value1IsNull = object.ReferenceEquals(value1, null);
            var value2IsNull = object.ReferenceEquals(value2, null);

            if (value1IsNull == value2IsNull)
            {
                if (value1IsNull)
                {
                    return true;
                }
                else
                {
                    return value1.Equals(value2);
                }
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Compares two instances for inequality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are not equal.</returns>
        public static bool operator !=(Country value1, Country value2)
        {
            return !(value1 == value2);
        }

        //---------------------------------------------------------------------
        // Instance members:

        private string cachedT;

        /// <summary>
        /// <b>INTERNAL USE ONLY:</b> This is the <see cref="JObject"/> is used to back
        /// all serialized round-trip.  This was made public for advanced unit testing but
        /// its use should generally be avoided for other purposes.  Use <see cref="ToJObject()"/>.
        /// instead.  "__O" is short for "object".
        /// </summary>
        [JsonIgnore]
        public JObject __O { get; set; }

        /// <summary>
        /// Constructs an uninitialized instance.
        /// </summary>
        public Country()
        {
            __T = PersistedType;
            __O = new JObject();
        }

        /// <summary>
        /// Protected constructor used internally to initialize derived classes.
        /// </summary>
        /// <param name="jObject">The backing <see cref="JObject"/>.</param>
        protected Country(JObject jObject)
        {
            __T = PersistedType;
            __O = jObject;
        }

        [JsonProperty(PropertyName = "Name", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public string Name { get; set; }

        [JsonProperty(PropertyName = "Population", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public int Population { get; set; }

        /// <summary>
        /// Loads the entity properties from the backing <see cref="JObject"/>
        /// or from the optional <see cref="JObject"/> passed.
        /// </summary>
        /// <param name="source">The optional source <see cref="JObject"/>.</param>
        /// <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        public virtual void __Load(JObject source = null, bool isDerived = false)
        {
            JProperty property;

            if (source != null)
            {
                this.__O = source;
            }

            if (this.__O == null)
            {
                this.__O = new JObject();
            }

            property = this.__O.Property("Name");
            if (property != null)
            {
                this.Name = (string)property.Value;
            }

            property = this.__O.Property("Population");
            if (property != null)
            {
                this.Population = (int)property.Value;
            }

            if (!isDerived)
            {
                property = this.__O.Property("T$$");
                if (property == null)
                {
                    throw new ArgumentNullException("[Country.T$$] property is required when deserializing.");
                }
                else
                {
                    this.__T = (string)property.Value;
                }
            }
        }

        /// <summary>
        /// Persists the properties from this instance to the backing <see cref="JObject"/>.
        /// </summary>
        /// <returns>The backing <see cref="JObject"/>.</returns>
        public virtual JObject __Save()
        {
            JProperty property;

            if (__O == null)
            {
                __O = new JObject();
            }

            this.__O["Name"] = this.Name;
            this.__O["Population"] = this.Population;
            this.__O["T$$"] = PersistedType;

            return this.__O;
        }

        /// <summary>
        /// Renders the instance as JSON text.
        /// </summary>
        /// <returns>The serialized JSON string.</returns>
        public override string ToString()
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, Formatting.None);
        }

        /// <summary>
        /// Renders the instance as JSON text, optionally formatting the output.
        /// </summary>
        /// <param name="indented">Optionally pass <c>true</c> to format the output.</param>
        /// <returns>The serialized JSON string.</returns>
        public string ToString(bool indented)
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, indented ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Renders the instance as a new <see cref="JObject"/>.
        /// </summary>
        /// <returns>The rendered <see cref="JObject"/>.</returns>
        public JObject ToJObject()
        {
            __Save();
            return RoundtripDataHelper.DeepClone(__O);
        }

        /// <summary>
        /// Renders the instance as UTF-8 encoded JSON.
        /// </summary>
        /// <returns>The serialized JSON bytes.</returns>
        public virtual byte[] ToBytes()
        {
            __Save();
            return Encoding.UTF8.GetBytes(RoundtripDataHelper.Serialize(__O, Formatting.None));
        }

        /// <summary>
        /// Returns a deep clone of the instance.
        /// </summary>
        /// <returns>The cloned instance.</returns>
        public Country DeepClone()
        {
            __Save();
            return CreateFrom(RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Used to convert a base data model class into a derived class.
        /// </summary>
        /// <typeparam name="T">The desired derived type.</typeparam>
        /// <param name="noClone">
        /// By default, this method will create a deep clone of the underlying <see cref="JObject"/>
        /// and use this new instance when constructing the new object.  This is the safest
        /// approach but will cause a performance hit.  You can pass <paramref name="noClone"/><c>=true</c>
        /// to reuse the existing <see cref="JObject"/> for the new instance if you're sure that the
        /// original instance will no longer be accessed.
        /// </param>
        /// <returns>The converted instance of type <typeparamref name="T"/>.</returns>
        public T ToDerived<T>(bool noClone = false)
           where T : Country, IRoundtripData
        {
            __Save();
            return RoundtripDataFactory.CreateFrom<T>(noClone ? __O : RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Determines whether the current instance equals another object.
        /// </summary>
        /// <param name="obj">The other object instance or <c>null</c>.</param>
        /// <returns><c>true</c> if the object reference equals the current instance.</returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as Country;

            if (object.ReferenceEquals(other, null))
            {
                return false;
            }

            this.__Save();
            other.__Save();
            return JObject.DeepEquals(this.__O, other.__O);
        }

        /// <summary>
        /// Calculates the hash code for the instance.
        /// <note>
        /// At least one of the class properties must be tagged with a <b>[HashSource]</b>
        /// for this to work.
        /// </note>
        /// </summary>
        /// <returns>The calculated hash code.</returns>
        /// <exception cref="InvalidOperationException">Thrown when no class properties are tagged with a <c>[HashSourceAttribute]</c>.</exception>
        public override int GetHashCode()
        {
            throw new InvalidOperationException(RoundtripDataHelper.NoHashPropertiesError);
        }

        /// <summary>
        /// Identifies the persisted object type.  "__T" is short for "type".  This is persisted as "T$$".
        /// </summary>
        [JsonProperty(PropertyName = "T$$", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        [DefaultValue(null)]
        public string __T
        {
            get
            {
                 if (cachedT != null)
                 {
                     return cachedT;
                 }

                 cachedT = (string)__O["T$$"];

                 if (cachedT != null)
                 {
                     return cachedT;
                 }

                 return PersistedType;
            }

            set => cachedT = value;
        }

        /// <summary>
        /// Returns the object's persistence key.
        /// </summary>
        public string GetKey()
        {
            if (Name == null)
            {
                throw new NotSupportedException("Persistence key property [Name] cannot be NULL.");
            }

            return RoundtripDataHelper.GetPersistedKey(PersistedType, Name);
        }

        /// <summary>
        /// Writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        public virtual void WriteJsonTo(Stream stream)
        {
            __Save();

            using (var writer = new JsonTextWriter(new StreamWriter(stream)))
            {
                __O.WriteTo(writer);
            }
        }

        /// <summary>
        /// Asynchronously writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        /// <returns>The tracking <see cref="Task"/>.</returns>
        public virtual async Task WriteJsonToAsync(Stream stream)
        {
            await SyncContext.ClearAsync;
            __Save();

            await stream.WriteAsync(Encoding.UTF8.GetBytes(__O.ToString()));
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.CustomPerson

    /// <threadsafety static="true" instance="false"/>
    public partial class CustomPerson : IRoundtripData, IPersistableType<CustomPerson>
    {
        //---------------------------------------------------------------------
        // Private types:

        /// <summary>
        /// Used to tag the <see cref="CustomPerson"/> entity such that Linq2Couchbase will
        /// be able to transparently add a <c>where</c> clause that filters by entity type
        /// to all queries for this entity type.
        /// </summary>
        private class CustomPersonFilter : global::Couchbase.Linq.Filters.IDocumentFilter<CustomPerson>
        {
            //-----------------------------------------------------------------
            // Static members:

            private static Expression<Func<CustomPerson, bool>> whereExpression;

            static CustomPersonFilter()
            {
                var parameter = Expression.Parameter(typeof(CustomPerson), "p");

                whereExpression = Expression.Lambda<Func<CustomPerson, bool>>(Expression.Equal(Expression.PropertyOrField(parameter, "__T"), Expression.Constant(CustomPerson.PersistedType)), parameter);
            }

            //-----------------------------------------------------------------
            // Instance members:

            public int Priority { get; set; }

            public IQueryable<CustomPerson> ApplyFilter(IQueryable<CustomPerson> source)
            {
                return source.Where(whereExpression);
            }
        }

        //---------------------------------------------------------------------
        // Static members:

        public const string PersistedType = "custom-person";

        /// <summary>
        /// Static constructor.
        /// </summary>
        static CustomPerson()
        {
            // You need to add a reference to the [Neon.Common] assembly if the following line doesn't compile.

            NeonHelper.PackageReferenceToNeonCommonIsRequired();
        }

        /// <summary>
        /// Performs any persistence related initialization including registering the Linq2Couchbase type
        /// filter.  This is typically called via <see cref="RoundtripDataHelper.PersistableInitialize()"/>.
        /// </summary>
        public static void PersistableInitialize()
        {
            // Register the document filter with Linq2Couchbase.

            global::Couchbase.Linq.Filters.DocumentFilterManager.SetFilter<CustomPerson>(new CustomPersonFilter());
        }

        /// <summary>
        /// Deserializes an instance from JSON text.
        /// </summary>
        /// <param name="jsonText">The JSON text input.</param>
        /// <returns>The deserialized <see cref="CustomPerson"/>.</returns>
        public static CustomPerson CreateFrom(string jsonText)
        {
            if (string.IsNullOrEmpty(jsonText))
            {
                throw new ArgumentNullException(nameof(jsonText));
            }

            var model = new CustomPerson(RoundtripDataHelper.Deserialize<JObject>(jsonText));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject">The input <see cref="JObject"/>.</param>
        /// <returns>The deserialized <see cref="CustomPerson"/>.</returns>
        public static CustomPerson CreateFrom(JObject jObject)
        {
            if (jObject == null)
            {
                throw new ArgumentNullException(nameof(jObject));
            }

            var model = new CustomPerson(jObject);

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="CustomPerson"/>.</returns>
        public static CustomPerson CreateFrom(Stream stream, Encoding encoding = null)
        {
            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            CustomPerson model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = CustomPerson.CreateFrom(reader.ReadToEnd());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a UTF-8 encoded byte array.
        /// </summary>
        /// <param name="bytes">The input byte array.</param>
        /// <returns>The deserialized <see cref="CustomPerson"/>.</returns>
        public static CustomPerson CreateFrom(byte[] bytes)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            var model = CreateFrom(Encoding.UTF8.GetString(bytes));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Asynchronously deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="CustomPerson"/>.</returns>
        public static async Task<object> CreateFromAsync(Stream stream, Encoding encoding = null)
        {
            await SyncContext.ClearAsync;

            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            CustomPerson model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = CustomPerson.CreateFrom(await reader.ReadToEndAsync());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JsonResponse"/>.
        /// </summary>
        /// <param name="response">The input <see cref="JsonResponse"/>.</param>
        /// <returns>The deserialized <see cref="CustomPerson"/>.</returns>
        public static CustomPerson CreateFrom(JsonResponse response)
        {
            if (response == null)
            {
                throw new ArgumentNullException(nameof(response));
            }

            return CreateFrom(response.JsonText);
        }

        /// <summary>
        /// Determines whether another entity instance has the same underlying type as this class.
        /// </summary>
        /// <param name="instance">The instance to be tested or <c>null</c>.</param>
        /// <returns>
        /// <c>true</c> if the <paramref name="instance"/> is not <c>null</c> and it has
        /// the same type as the current class.
        /// </returns>
        public static bool SameTypeAs(IPersistableType instance)
        {
            if (instance == null)
            {
                return false;
            }

            return instance.__T == CustomPerson.PersistedType;
        }

        /// <summary>
        /// Creates a persistence key.
        /// </summary>
        /// <param name="args">Arguments identifying the item.</param>
        public static string CreateKey(params object[] args)
        {
            return RoundtripDataHelper.GetPersistedKey("custom-person", args);
        }

        /// <summary>
        /// Compares two instances for equality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are equal.</returns>
        public static bool operator ==(CustomPerson value1, CustomPerson value2)
        {
            var value1IsNull = object.ReferenceEquals(value1, null);
            var value2IsNull = object.ReferenceEquals(value2, null);

            if (value1IsNull == value2IsNull)
            {
                if (value1IsNull)
                {
                    return true;
                }
                else
                {
                    return value1.Equals(value2);
                }
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Compares two instances for inequality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are not equal.</returns>
        public static bool operator !=(CustomPerson value1, CustomPerson value2)
        {
            return !(value1 == value2);
        }

        //---------------------------------------------------------------------
        // Instance members:

        private string cachedT;

        /// <summary>
        /// <b>INTERNAL USE ONLY:</b> This is the <see cref="JObject"/> is used to back
        /// all serialized round-trip.  This was made public for advanced unit testing but
        /// its use should generally be avoided for other purposes.  Use <see cref="ToJObject()"/>.
        /// instead.  "__O" is short for "object".
        /// </summary>
        [JsonIgnore]
        public JObject __O { get; set; }

        /// <summary>
        /// Constructs an uninitialized instance.
        /// </summary>
        public CustomPerson()
        {
            __T = PersistedType;
            __O = new JObject();
        }

        /// <summary>
        /// Protected constructor used internally to initialize derived classes.
        /// </summary>
        /// <param name="jObject">The backing <see cref="JObject"/>.</param>
        protected CustomPerson(JObject jObject)
        {
            __T = PersistedType;
            __O = jObject;
        }

        [JsonProperty(PropertyName = "my-id", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public int Id { get; set; }

        [JsonProperty(PropertyName = "my-name", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public string Name { get; set; }

        [JsonProperty(PropertyName = "my-age", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public int Age { get; set; }

        [JsonProperty(PropertyName = "my-gender", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public Gender Gender { get; set; }

        [JsonProperty(PropertyName = "my-data", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public byte[] Data { get; set; }

        /// <summary>
        /// Loads the entity properties from the backing <see cref="JObject"/>
        /// or from the optional <see cref="JObject"/> passed.
        /// </summary>
        /// <param name="source">The optional source <see cref="JObject"/>.</param>
        /// <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        public virtual void __Load(JObject source = null, bool isDerived = false)
        {
            JProperty property;

            if (source != null)
            {
                this.__O = source;
            }

            if (this.__O == null)
            {
                this.__O = new JObject();
            }

            property = this.__O.Property("my-id");
            if (property != null)
            {
                this.Id = (int)property.Value;
            }

            property = this.__O.Property("my-name");
            if (property != null)
            {
                this.Name = (string)property.Value;
            }

            property = this.__O.Property("my-age");
            if (property != null)
            {
                this.Age = (int)property.Value;
            }

            property = this.__O.Property("my-gender");
            if (property != null)
            {
                this.Gender = property.Value.ToObject<Gender>(RoundtripDataHelper.Serializer);
            }

            property = this.__O.Property("my-data");
            if (property != null)
            {
                this.Data = property.Value.ToObject<byte[]>(RoundtripDataHelper.Serializer);
            }

            if (!isDerived)
            {
                property = this.__O.Property("T$$");
                if (property == null)
                {
                    throw new ArgumentNullException("[CustomPerson.T$$] property is required when deserializing.");
                }
                else
                {
                    this.__T = (string)property.Value;
                }
            }
        }

        /// <summary>
        /// Persists the properties from this instance to the backing <see cref="JObject"/>.
        /// </summary>
        /// <returns>The backing <see cref="JObject"/>.</returns>
        public virtual JObject __Save()
        {
            JProperty property;

            if (__O == null)
            {
                __O = new JObject();
            }

            this.__O["my-id"] = this.Id;
            this.__O["my-name"] = this.Name;
            this.__O["my-age"] = this.Age;
            this.__O["my-gender"] = RoundtripDataHelper.FromObject(this.Gender, typeof(CustomPerson), nameof(Gender));
            this.__O["my-data"] = RoundtripDataHelper.FromObject(this.Data, typeof(CustomPerson), nameof(Data));
            this.__O["T$$"] = PersistedType;

            return this.__O;
        }

        /// <summary>
        /// Renders the instance as JSON text.
        /// </summary>
        /// <returns>The serialized JSON string.</returns>
        public override string ToString()
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, Formatting.None);
        }

        /// <summary>
        /// Renders the instance as JSON text, optionally formatting the output.
        /// </summary>
        /// <param name="indented">Optionally pass <c>true</c> to format the output.</param>
        /// <returns>The serialized JSON string.</returns>
        public string ToString(bool indented)
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, indented ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Renders the instance as a new <see cref="JObject"/>.
        /// </summary>
        /// <returns>The rendered <see cref="JObject"/>.</returns>
        public JObject ToJObject()
        {
            __Save();
            return RoundtripDataHelper.DeepClone(__O);
        }

        /// <summary>
        /// Renders the instance as UTF-8 encoded JSON.
        /// </summary>
        /// <returns>The serialized JSON bytes.</returns>
        public virtual byte[] ToBytes()
        {
            __Save();
            return Encoding.UTF8.GetBytes(RoundtripDataHelper.Serialize(__O, Formatting.None));
        }

        /// <summary>
        /// Returns a deep clone of the instance.
        /// </summary>
        /// <returns>The cloned instance.</returns>
        public CustomPerson DeepClone()
        {
            __Save();
            return CreateFrom(RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Used to convert a base data model class into a derived class.
        /// </summary>
        /// <typeparam name="T">The desired derived type.</typeparam>
        /// <param name="noClone">
        /// By default, this method will create a deep clone of the underlying <see cref="JObject"/>
        /// and use this new instance when constructing the new object.  This is the safest
        /// approach but will cause a performance hit.  You can pass <paramref name="noClone"/><c>=true</c>
        /// to reuse the existing <see cref="JObject"/> for the new instance if you're sure that the
        /// original instance will no longer be accessed.
        /// </param>
        /// <returns>The converted instance of type <typeparamref name="T"/>.</returns>
        public T ToDerived<T>(bool noClone = false)
           where T : CustomPerson, IRoundtripData
        {
            __Save();
            return RoundtripDataFactory.CreateFrom<T>(noClone ? __O : RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Determines whether the current instance equals another object.
        /// </summary>
        /// <param name="obj">The other object instance or <c>null</c>.</param>
        /// <returns><c>true</c> if the object reference equals the current instance.</returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as CustomPerson;

            if (object.ReferenceEquals(other, null))
            {
                return false;
            }

            this.__Save();
            other.__Save();
            return JObject.DeepEquals(this.__O, other.__O);
        }

        /// <summary>
        /// Calculates the hash code for the instance.
        /// <note>
        /// At least one of the class properties must be tagged with a <b>[HashSource]</b>
        /// for this to work.
        /// </note>
        /// </summary>
        /// <returns>The calculated hash code.</returns>
        /// <exception cref="InvalidOperationException">Thrown when no class properties are tagged with a <c>[HashSourceAttribute]</c>.</exception>
        public override int GetHashCode()
        {
            throw new InvalidOperationException(RoundtripDataHelper.NoHashPropertiesError);
        }

        /// <summary>
        /// Identifies the persisted object type.  "__T" is short for "type".  This is persisted as "T$$".
        /// </summary>
        [JsonProperty(PropertyName = "T$$", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        [DefaultValue(null)]
        public string __T
        {
            get
            {
                 if (cachedT != null)
                 {
                     return cachedT;
                 }

                 cachedT = (string)__O["T$$"];

                 if (cachedT != null)
                 {
                     return cachedT;
                 }

                 return PersistedType;
            }

            set => cachedT = value;
        }

        /// <summary>
        /// Returns the object's persistence key.
        /// </summary>
        public string GetKey()
        {
            return RoundtripDataHelper.GetPersistedKey(PersistedType, Id.ToString());
        }

        /// <summary>
        /// Writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        public virtual void WriteJsonTo(Stream stream)
        {
            __Save();

            using (var writer = new JsonTextWriter(new StreamWriter(stream)))
            {
                __O.WriteTo(writer);
            }
        }

        /// <summary>
        /// Asynchronously writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        /// <returns>The tracking <see cref="Task"/>.</returns>
        public virtual async Task WriteJsonToAsync(Stream stream)
        {
            await SyncContext.ClearAsync;
            __Save();

            await stream.WriteAsync(Encoding.UTF8.GetBytes(__O.ToString()));
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.DateTimeEntity

    /// <threadsafety static="true" instance="false"/>
    public partial class DateTimeEntity : IRoundtripData
    {
        //---------------------------------------------------------------------
        // Static members:

        /// <summary>
        /// Static constructor.
        /// </summary>
        static DateTimeEntity()
        {
            // You need to add a reference to the [Neon.Common] assembly if the following line doesn't compile.

            NeonHelper.PackageReferenceToNeonCommonIsRequired();
        }

        /// <summary>
        /// Deserializes an instance from JSON text.
        /// </summary>
        /// <param name="jsonText">The JSON text input.</param>
        /// <returns>The deserialized <see cref="DateTimeEntity"/>.</returns>
        public static DateTimeEntity CreateFrom(string jsonText)
        {
            if (string.IsNullOrEmpty(jsonText))
            {
                throw new ArgumentNullException(nameof(jsonText));
            }

            var model = new DateTimeEntity(RoundtripDataHelper.Deserialize<JObject>(jsonText));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject">The input <see cref="JObject"/>.</param>
        /// <returns>The deserialized <see cref="DateTimeEntity"/>.</returns>
        public static DateTimeEntity CreateFrom(JObject jObject)
        {
            if (jObject == null)
            {
                throw new ArgumentNullException(nameof(jObject));
            }

            var model = new DateTimeEntity(jObject);

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="DateTimeEntity"/>.</returns>
        public static DateTimeEntity CreateFrom(Stream stream, Encoding encoding = null)
        {
            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            DateTimeEntity model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = DateTimeEntity.CreateFrom(reader.ReadToEnd());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a UTF-8 encoded byte array.
        /// </summary>
        /// <param name="bytes">The input byte array.</param>
        /// <returns>The deserialized <see cref="DateTimeEntity"/>.</returns>
        public static DateTimeEntity CreateFrom(byte[] bytes)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            var model = CreateFrom(Encoding.UTF8.GetString(bytes));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Asynchronously deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="DateTimeEntity"/>.</returns>
        public static async Task<object> CreateFromAsync(Stream stream, Encoding encoding = null)
        {
            await SyncContext.ClearAsync;

            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            DateTimeEntity model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = DateTimeEntity.CreateFrom(await reader.ReadToEndAsync());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JsonResponse"/>.
        /// </summary>
        /// <param name="response">The input <see cref="JsonResponse"/>.</param>
        /// <returns>The deserialized <see cref="DateTimeEntity"/>.</returns>
        public static DateTimeEntity CreateFrom(JsonResponse response)
        {
            if (response == null)
            {
                throw new ArgumentNullException(nameof(response));
            }

            return CreateFrom(response.JsonText);
        }

        /// <summary>
        /// Compares two instances for equality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are equal.</returns>
        public static bool operator ==(DateTimeEntity value1, DateTimeEntity value2)
        {
            var value1IsNull = object.ReferenceEquals(value1, null);
            var value2IsNull = object.ReferenceEquals(value2, null);

            if (value1IsNull == value2IsNull)
            {
                if (value1IsNull)
                {
                    return true;
                }
                else
                {
                    return value1.Equals(value2);
                }
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Compares two instances for inequality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are not equal.</returns>
        public static bool operator !=(DateTimeEntity value1, DateTimeEntity value2)
        {
            return !(value1 == value2);
        }

        //---------------------------------------------------------------------
        // Instance members:

        /// <summary>
        /// <b>INTERNAL USE ONLY:</b> This is the <see cref="JObject"/> is used to back
        /// all serialized round-trip.  This was made public for advanced unit testing but
        /// its use should generally be avoided for other purposes.  Use <see cref="ToJObject()"/>.
        /// instead.  "__O" is short for "object".
        /// </summary>
        [JsonIgnore]
        public JObject __O { get; set; }

        /// <summary>
        /// Constructs an uninitialized instance.
        /// </summary>
        public DateTimeEntity()
        {
            __O = new JObject();
        }

        /// <summary>
        /// Protected constructor used internally to initialize derived classes.
        /// </summary>
        /// <param name="jObject">The backing <see cref="JObject"/>.</param>
        protected DateTimeEntity(JObject jObject)
        {
            __O = jObject;
        }

        [JsonProperty(PropertyName = "Timestamp", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public global::System.DateTime Timestamp { get; set; }

        /// <summary>
        /// Loads the entity properties from the backing <see cref="JObject"/>
        /// or from the optional <see cref="JObject"/> passed.
        /// </summary>
        /// <param name="source">The optional source <see cref="JObject"/>.</param>
        /// <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        public virtual void __Load(JObject source = null, bool isDerived = false)
        {
            JProperty property;

            if (source != null)
            {
                this.__O = source;
            }

            if (this.__O == null)
            {
                this.__O = new JObject();
            }

            property = this.__O.Property("Timestamp");
            if (property != null)
            {
                this.Timestamp = property.Value.ToObject<global::System.DateTime>(RoundtripDataHelper.Serializer);
            }
        }

        /// <summary>
        /// Persists the properties from this instance to the backing <see cref="JObject"/>.
        /// </summary>
        /// <returns>The backing <see cref="JObject"/>.</returns>
        public virtual JObject __Save()
        {
            JProperty property;

            if (__O == null)
            {
                __O = new JObject();
            }

            this.__O["Timestamp"] = RoundtripDataHelper.FromObject(this.Timestamp, typeof(DateTimeEntity), nameof(Timestamp));

            return this.__O;
        }

        /// <summary>
        /// Renders the instance as JSON text.
        /// </summary>
        /// <returns>The serialized JSON string.</returns>
        public override string ToString()
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, Formatting.None);
        }

        /// <summary>
        /// Renders the instance as JSON text, optionally formatting the output.
        /// </summary>
        /// <param name="indented">Optionally pass <c>true</c> to format the output.</param>
        /// <returns>The serialized JSON string.</returns>
        public string ToString(bool indented)
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, indented ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Renders the instance as a new <see cref="JObject"/>.
        /// </summary>
        /// <returns>The rendered <see cref="JObject"/>.</returns>
        public JObject ToJObject()
        {
            __Save();
            return RoundtripDataHelper.DeepClone(__O);
        }

        /// <summary>
        /// Renders the instance as UTF-8 encoded JSON.
        /// </summary>
        /// <returns>The serialized JSON bytes.</returns>
        public virtual byte[] ToBytes()
        {
            __Save();
            return Encoding.UTF8.GetBytes(RoundtripDataHelper.Serialize(__O, Formatting.None));
        }

        /// <summary>
        /// Returns a deep clone of the instance.
        /// </summary>
        /// <returns>The cloned instance.</returns>
        public DateTimeEntity DeepClone()
        {
            __Save();
            return CreateFrom(RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Used to convert a base data model class into a derived class.
        /// </summary>
        /// <typeparam name="T">The desired derived type.</typeparam>
        /// <param name="noClone">
        /// By default, this method will create a deep clone of the underlying <see cref="JObject"/>
        /// and use this new instance when constructing the new object.  This is the safest
        /// approach but will cause a performance hit.  You can pass <paramref name="noClone"/><c>=true</c>
        /// to reuse the existing <see cref="JObject"/> for the new instance if you're sure that the
        /// original instance will no longer be accessed.
        /// </param>
        /// <returns>The converted instance of type <typeparamref name="T"/>.</returns>
        public T ToDerived<T>(bool noClone = false)
           where T : DateTimeEntity, IRoundtripData
        {
            __Save();
            return RoundtripDataFactory.CreateFrom<T>(noClone ? __O : RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Determines whether the current instance equals another object.
        /// </summary>
        /// <param name="obj">The other object instance or <c>null</c>.</param>
        /// <returns><c>true</c> if the object reference equals the current instance.</returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as DateTimeEntity;

            if (object.ReferenceEquals(other, null))
            {
                return false;
            }

            this.__Save();
            other.__Save();
            return JObject.DeepEquals(this.__O, other.__O);
        }

        /// <summary>
        /// Calculates the hash code for the instance.
        /// <note>
        /// At least one of the class properties must be tagged with a <b>[HashSource]</b>
        /// for this to work.
        /// </note>
        /// </summary>
        /// <returns>The calculated hash code.</returns>
        /// <exception cref="InvalidOperationException">Thrown when no class properties are tagged with a <c>[HashSourceAttribute]</c>.</exception>
        public override int GetHashCode()
        {
            throw new InvalidOperationException(RoundtripDataHelper.NoHashPropertiesError);
        }

        /// <summary>
        /// Writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        public virtual void WriteJsonTo(Stream stream)
        {
            __Save();

            using (var writer = new JsonTextWriter(new StreamWriter(stream)))
            {
                __O.WriteTo(writer);
            }
        }

        /// <summary>
        /// Asynchronously writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        /// <returns>The tracking <see cref="Task"/>.</returns>
        public virtual async Task WriteJsonToAsync(Stream stream)
        {
            await SyncContext.ClearAsync;
            __Save();

            await stream.WriteAsync(Encoding.UTF8.GetBytes(__O.ToString()));
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.DerivedModel

    /// <threadsafety static="true" instance="false"/>
    public partial class DerivedModel : BaseModel
    {
        //---------------------------------------------------------------------
        // Static members:

        /// <summary>
        /// Static constructor.
        /// </summary>
        static DerivedModel()
        {
            // You need to add a reference to the [Neon.Common] assembly if the following line doesn't compile.

            NeonHelper.PackageReferenceToNeonCommonIsRequired();
        }

        /// <summary>
        /// Deserializes an instance from JSON text.
        /// </summary>
        /// <param name="jsonText">The JSON text input.</param>
        /// <returns>The deserialized <see cref="DerivedModel"/>.</returns>
        public static DerivedModel CreateFrom(string jsonText)
        {
            if (string.IsNullOrEmpty(jsonText))
            {
                throw new ArgumentNullException(nameof(jsonText));
            }

            var model = new DerivedModel(RoundtripDataHelper.Deserialize<JObject>(jsonText));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject">The input <see cref="JObject"/>.</param>
        /// <returns>The deserialized <see cref="DerivedModel"/>.</returns>
        public static DerivedModel CreateFrom(JObject jObject)
        {
            if (jObject == null)
            {
                throw new ArgumentNullException(nameof(jObject));
            }

            var model = new DerivedModel(jObject);

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="DerivedModel"/>.</returns>
        public static DerivedModel CreateFrom(Stream stream, Encoding encoding = null)
        {
            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            DerivedModel model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = DerivedModel.CreateFrom(reader.ReadToEnd());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a UTF-8 encoded byte array.
        /// </summary>
        /// <param name="bytes">The input byte array.</param>
        /// <returns>The deserialized <see cref="DerivedModel"/>.</returns>
        public static DerivedModel CreateFrom(byte[] bytes)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            var model = CreateFrom(Encoding.UTF8.GetString(bytes));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Asynchronously deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="DerivedModel"/>.</returns>
        public static async Task<object> CreateFromAsync(Stream stream, Encoding encoding = null)
        {
            await SyncContext.ClearAsync;

            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            DerivedModel model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = DerivedModel.CreateFrom(await reader.ReadToEndAsync());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JsonResponse"/>.
        /// </summary>
        /// <param name="response">The input <see cref="JsonResponse"/>.</param>
        /// <returns>The deserialized <see cref="DerivedModel"/>.</returns>
        public static DerivedModel CreateFrom(JsonResponse response)
        {
            if (response == null)
            {
                throw new ArgumentNullException(nameof(response));
            }

            return CreateFrom(response.JsonText);
        }

        /// <summary>
        /// Compares two instances for equality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are equal.</returns>
        public static bool operator ==(DerivedModel value1, DerivedModel value2)
        {
            var value1IsNull = object.ReferenceEquals(value1, null);
            var value2IsNull = object.ReferenceEquals(value2, null);

            if (value1IsNull == value2IsNull)
            {
                if (value1IsNull)
                {
                    return true;
                }
                else
                {
                    return value1.Equals(value2);
                }
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Compares two instances for inequality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are not equal.</returns>
        public static bool operator !=(DerivedModel value1, DerivedModel value2)
        {
            return !(value1 == value2);
        }

        //---------------------------------------------------------------------
        // Instance members:

        /// <summary>
        /// Constructs an uninitialized instance.
        /// </summary>
        public DerivedModel() : base()
        {
        }

        /// <summary>
        /// Protected constructor.
        /// </summary>
        /// <param name="jObject">The backing <see cref="JObject"/>.</param>
        protected DerivedModel(JObject jObject) : base(jObject)
        {
        }

        [JsonProperty(PropertyName = "ChildProperty", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public string ChildProperty { get; set; }

        /// <summary>
        /// Loads the entity properties from the backing <see cref="JObject"/>
        /// or from the optional <see cref="JObject"/> passed.
        /// </summary>
        /// <param name="source">The optional source <see cref="JObject"/>.</param>
        /// <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        public override void __Load(JObject source = null, bool isDerived = false)
        {
            JProperty property;

            if (source != null)
            {
                this.__O = source;
            }

            if (this.__O == null)
            {
                this.__O = new JObject();
            }

            base.__Load(isDerived: true);

            property = this.__O.Property("ChildProperty");
            if (property != null)
            {
                this.ChildProperty = (string)property.Value;
            }
        }

        /// <summary>
        /// Persists the properties from this instance to the backing <see cref="JObject"/>.
        /// </summary>
        /// <returns>The backing <see cref="JObject"/>.</returns>
        public override JObject __Save()
        {
            JProperty property;

            if (__O == null)
            {
                __O = new JObject();
            }

            base.__Save();

            this.__O["ChildProperty"] = this.ChildProperty;

            return this.__O;
        }

        /// <summary>
        /// Renders the instance as JSON text.
        /// </summary>
        /// <returns>The serialized JSON string.</returns>
        public override string ToString()
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, Formatting.None);
        }

        /// <summary>
        /// Renders the instance as JSON text, optionally formatting the output.
        /// </summary>
        /// <param name="indented">Optionally pass <c>true</c> to format the output.</param>
        /// <returns>The serialized JSON string.</returns>
        public string ToString(bool indented)
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, indented ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Renders the instance as UTF-8 encoded JSON.
        /// </summary>
        /// <returns>The serialized JSON bytes.</returns>
        public override byte[] ToBytes()
        {
            __Save();
            return Encoding.UTF8.GetBytes(RoundtripDataHelper.Serialize(__O, Formatting.None));
        }

        /// <summary>
        /// Returns a deep clone of the instance.
        /// </summary>
        /// <returns>The cloned instance.</returns>
        public DerivedModel DeepClone()
        {
            __Save();
            return CreateFrom(RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Used to convert a base data model class into a derived class.
        /// </summary>
        /// <typeparam name="T">The desired derived type.</typeparam>
        /// <param name="noClone">
        /// By default, this method will create a deep clone of the underlying <see cref="JObject"/>
        /// and use this new instance when constructing the new object.  This is the safest
        /// approach but will cause a performance hit.  You can pass <paramref name="noClone"/><c>=true</c>
        /// to reuse the existing <see cref="JObject"/> for the new instance if you're sure that the
        /// original instance will no longer be accessed.
        /// </param>
        /// <returns>The converted instance of type <typeparamref name="T"/>.</returns>
        public T ToDerived<T>(bool noClone = false)
           where T : DerivedModel, IRoundtripData
        {
            __Save();
            return RoundtripDataFactory.CreateFrom<T>(noClone ? __O : RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Determines whether the current instance equals another object.
        /// </summary>
        /// <param name="obj">The other object instance or <c>null</c>.</param>
        /// <returns><c>true</c> if the object reference equals the current instance.</returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as DerivedModel;

            if (object.ReferenceEquals(other, null))
            {
                return false;
            }

            this.__Save();
            other.__Save();
            return JObject.DeepEquals(this.__O, other.__O);
        }

        /// <summary>
        /// Calculates the hash code for the instance.
        /// <note>
        /// At least one of the class properties must be tagged with a <b>[HashSource]</b>
        /// for this to work.
        /// </note>
        /// </summary>
        /// <returns>The calculated hash code.</returns>
        /// <exception cref="InvalidOperationException">Thrown when no class properties are tagged with a <c>[HashSourceAttribute]</c>.</exception>
        public override int GetHashCode()
        {
            var hashCode = 0;

            if (this.ChildProperty != null) { hashCode ^= this.ChildProperty.GetHashCode(); }
            if (this.ParentProperty != null) { hashCode ^= this.ParentProperty.GetHashCode(); }

            return hashCode;
        }

        /// <summary>
        /// Writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        public override void WriteJsonTo(Stream stream)
        {
            __Save();

            using (var writer = new JsonTextWriter(new StreamWriter(stream)))
            {
                __O.WriteTo(writer);
            }
        }

        /// <summary>
        /// Asynchronously writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        /// <returns>The tracking <see cref="Task"/>.</returns>
        public override async Task WriteJsonToAsync(Stream stream)
        {
            await SyncContext.ClearAsync;
            __Save();

            await stream.WriteAsync(Encoding.UTF8.GetBytes(__O.ToString()));
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.EnumEntity

    /// <threadsafety static="true" instance="false"/>
    public partial class EnumEntity : IRoundtripData
    {
        //---------------------------------------------------------------------
        // Static members:

        /// <summary>
        /// Static constructor.
        /// </summary>
        static EnumEntity()
        {
            // You need to add a reference to the [Neon.Common] assembly if the following line doesn't compile.

            NeonHelper.PackageReferenceToNeonCommonIsRequired();
        }

        /// <summary>
        /// Deserializes an instance from JSON text.
        /// </summary>
        /// <param name="jsonText">The JSON text input.</param>
        /// <returns>The deserialized <see cref="EnumEntity"/>.</returns>
        public static EnumEntity CreateFrom(string jsonText)
        {
            if (string.IsNullOrEmpty(jsonText))
            {
                throw new ArgumentNullException(nameof(jsonText));
            }

            var model = new EnumEntity(RoundtripDataHelper.Deserialize<JObject>(jsonText));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject">The input <see cref="JObject"/>.</param>
        /// <returns>The deserialized <see cref="EnumEntity"/>.</returns>
        public static EnumEntity CreateFrom(JObject jObject)
        {
            if (jObject == null)
            {
                throw new ArgumentNullException(nameof(jObject));
            }

            var model = new EnumEntity(jObject);

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="EnumEntity"/>.</returns>
        public static EnumEntity CreateFrom(Stream stream, Encoding encoding = null)
        {
            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            EnumEntity model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = EnumEntity.CreateFrom(reader.ReadToEnd());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a UTF-8 encoded byte array.
        /// </summary>
        /// <param name="bytes">The input byte array.</param>
        /// <returns>The deserialized <see cref="EnumEntity"/>.</returns>
        public static EnumEntity CreateFrom(byte[] bytes)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            var model = CreateFrom(Encoding.UTF8.GetString(bytes));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Asynchronously deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="EnumEntity"/>.</returns>
        public static async Task<object> CreateFromAsync(Stream stream, Encoding encoding = null)
        {
            await SyncContext.ClearAsync;

            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            EnumEntity model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = EnumEntity.CreateFrom(await reader.ReadToEndAsync());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JsonResponse"/>.
        /// </summary>
        /// <param name="response">The input <see cref="JsonResponse"/>.</param>
        /// <returns>The deserialized <see cref="EnumEntity"/>.</returns>
        public static EnumEntity CreateFrom(JsonResponse response)
        {
            if (response == null)
            {
                throw new ArgumentNullException(nameof(response));
            }

            return CreateFrom(response.JsonText);
        }

        /// <summary>
        /// Compares two instances for equality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are equal.</returns>
        public static bool operator ==(EnumEntity value1, EnumEntity value2)
        {
            var value1IsNull = object.ReferenceEquals(value1, null);
            var value2IsNull = object.ReferenceEquals(value2, null);

            if (value1IsNull == value2IsNull)
            {
                if (value1IsNull)
                {
                    return true;
                }
                else
                {
                    return value1.Equals(value2);
                }
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Compares two instances for inequality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are not equal.</returns>
        public static bool operator !=(EnumEntity value1, EnumEntity value2)
        {
            return !(value1 == value2);
        }

        //---------------------------------------------------------------------
        // Instance members:

        /// <summary>
        /// <b>INTERNAL USE ONLY:</b> This is the <see cref="JObject"/> is used to back
        /// all serialized round-trip.  This was made public for advanced unit testing but
        /// its use should generally be avoided for other purposes.  Use <see cref="ToJObject()"/>.
        /// instead.  "__O" is short for "object".
        /// </summary>
        [JsonIgnore]
        public JObject __O { get; set; }

        /// <summary>
        /// Constructs an uninitialized instance.
        /// </summary>
        public EnumEntity()
        {
            __O = new JObject();
        }

        /// <summary>
        /// Protected constructor used internally to initialize derived classes.
        /// </summary>
        /// <param name="jObject">The backing <see cref="JObject"/>.</param>
        protected EnumEntity(JObject jObject)
        {
            __O = jObject;
        }

        [JsonProperty(PropertyName = "Gender", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public Gender Gender { get; set; }

        /// <summary>
        /// Loads the entity properties from the backing <see cref="JObject"/>
        /// or from the optional <see cref="JObject"/> passed.
        /// </summary>
        /// <param name="source">The optional source <see cref="JObject"/>.</param>
        /// <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        public virtual void __Load(JObject source = null, bool isDerived = false)
        {
            JProperty property;

            if (source != null)
            {
                this.__O = source;
            }

            if (this.__O == null)
            {
                this.__O = new JObject();
            }

            property = this.__O.Property("Gender");
            if (property != null)
            {
                this.Gender = property.Value.ToObject<Gender>(RoundtripDataHelper.Serializer);
            }
        }

        /// <summary>
        /// Persists the properties from this instance to the backing <see cref="JObject"/>.
        /// </summary>
        /// <returns>The backing <see cref="JObject"/>.</returns>
        public virtual JObject __Save()
        {
            JProperty property;

            if (__O == null)
            {
                __O = new JObject();
            }

            this.__O["Gender"] = RoundtripDataHelper.FromObject(this.Gender, typeof(EnumEntity), nameof(Gender));

            return this.__O;
        }

        /// <summary>
        /// Renders the instance as JSON text.
        /// </summary>
        /// <returns>The serialized JSON string.</returns>
        public override string ToString()
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, Formatting.None);
        }

        /// <summary>
        /// Renders the instance as JSON text, optionally formatting the output.
        /// </summary>
        /// <param name="indented">Optionally pass <c>true</c> to format the output.</param>
        /// <returns>The serialized JSON string.</returns>
        public string ToString(bool indented)
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, indented ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Renders the instance as a new <see cref="JObject"/>.
        /// </summary>
        /// <returns>The rendered <see cref="JObject"/>.</returns>
        public JObject ToJObject()
        {
            __Save();
            return RoundtripDataHelper.DeepClone(__O);
        }

        /// <summary>
        /// Renders the instance as UTF-8 encoded JSON.
        /// </summary>
        /// <returns>The serialized JSON bytes.</returns>
        public virtual byte[] ToBytes()
        {
            __Save();
            return Encoding.UTF8.GetBytes(RoundtripDataHelper.Serialize(__O, Formatting.None));
        }

        /// <summary>
        /// Returns a deep clone of the instance.
        /// </summary>
        /// <returns>The cloned instance.</returns>
        public EnumEntity DeepClone()
        {
            __Save();
            return CreateFrom(RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Used to convert a base data model class into a derived class.
        /// </summary>
        /// <typeparam name="T">The desired derived type.</typeparam>
        /// <param name="noClone">
        /// By default, this method will create a deep clone of the underlying <see cref="JObject"/>
        /// and use this new instance when constructing the new object.  This is the safest
        /// approach but will cause a performance hit.  You can pass <paramref name="noClone"/><c>=true</c>
        /// to reuse the existing <see cref="JObject"/> for the new instance if you're sure that the
        /// original instance will no longer be accessed.
        /// </param>
        /// <returns>The converted instance of type <typeparamref name="T"/>.</returns>
        public T ToDerived<T>(bool noClone = false)
           where T : EnumEntity, IRoundtripData
        {
            __Save();
            return RoundtripDataFactory.CreateFrom<T>(noClone ? __O : RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Determines whether the current instance equals another object.
        /// </summary>
        /// <param name="obj">The other object instance or <c>null</c>.</param>
        /// <returns><c>true</c> if the object reference equals the current instance.</returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as EnumEntity;

            if (object.ReferenceEquals(other, null))
            {
                return false;
            }

            this.__Save();
            other.__Save();
            return JObject.DeepEquals(this.__O, other.__O);
        }

        /// <summary>
        /// Calculates the hash code for the instance.
        /// <note>
        /// At least one of the class properties must be tagged with a <b>[HashSource]</b>
        /// for this to work.
        /// </note>
        /// </summary>
        /// <returns>The calculated hash code.</returns>
        /// <exception cref="InvalidOperationException">Thrown when no class properties are tagged with a <c>[HashSourceAttribute]</c>.</exception>
        public override int GetHashCode()
        {
            throw new InvalidOperationException(RoundtripDataHelper.NoHashPropertiesError);
        }

        /// <summary>
        /// Writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        public virtual void WriteJsonTo(Stream stream)
        {
            __Save();

            using (var writer = new JsonTextWriter(new StreamWriter(stream)))
            {
                __O.WriteTo(writer);
            }
        }

        /// <summary>
        /// Asynchronously writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        /// <returns>The tracking <see cref="Task"/>.</returns>
        public virtual async Task WriteJsonToAsync(Stream stream)
        {
            await SyncContext.ClearAsync;
            __Save();

            await stream.WriteAsync(Encoding.UTF8.GetBytes(__O.ToString()));
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.EnumFlagsEntity

    /// <threadsafety static="true" instance="false"/>
    public partial class EnumFlagsEntity : IRoundtripData
    {
        //---------------------------------------------------------------------
        // Static members:

        /// <summary>
        /// Static constructor.
        /// </summary>
        static EnumFlagsEntity()
        {
            // You need to add a reference to the [Neon.Common] assembly if the following line doesn't compile.

            NeonHelper.PackageReferenceToNeonCommonIsRequired();
        }

        /// <summary>
        /// Deserializes an instance from JSON text.
        /// </summary>
        /// <param name="jsonText">The JSON text input.</param>
        /// <returns>The deserialized <see cref="EnumFlagsEntity"/>.</returns>
        public static EnumFlagsEntity CreateFrom(string jsonText)
        {
            if (string.IsNullOrEmpty(jsonText))
            {
                throw new ArgumentNullException(nameof(jsonText));
            }

            var model = new EnumFlagsEntity(RoundtripDataHelper.Deserialize<JObject>(jsonText));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject">The input <see cref="JObject"/>.</param>
        /// <returns>The deserialized <see cref="EnumFlagsEntity"/>.</returns>
        public static EnumFlagsEntity CreateFrom(JObject jObject)
        {
            if (jObject == null)
            {
                throw new ArgumentNullException(nameof(jObject));
            }

            var model = new EnumFlagsEntity(jObject);

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="EnumFlagsEntity"/>.</returns>
        public static EnumFlagsEntity CreateFrom(Stream stream, Encoding encoding = null)
        {
            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            EnumFlagsEntity model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = EnumFlagsEntity.CreateFrom(reader.ReadToEnd());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a UTF-8 encoded byte array.
        /// </summary>
        /// <param name="bytes">The input byte array.</param>
        /// <returns>The deserialized <see cref="EnumFlagsEntity"/>.</returns>
        public static EnumFlagsEntity CreateFrom(byte[] bytes)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            var model = CreateFrom(Encoding.UTF8.GetString(bytes));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Asynchronously deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="EnumFlagsEntity"/>.</returns>
        public static async Task<object> CreateFromAsync(Stream stream, Encoding encoding = null)
        {
            await SyncContext.ClearAsync;

            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            EnumFlagsEntity model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = EnumFlagsEntity.CreateFrom(await reader.ReadToEndAsync());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JsonResponse"/>.
        /// </summary>
        /// <param name="response">The input <see cref="JsonResponse"/>.</param>
        /// <returns>The deserialized <see cref="EnumFlagsEntity"/>.</returns>
        public static EnumFlagsEntity CreateFrom(JsonResponse response)
        {
            if (response == null)
            {
                throw new ArgumentNullException(nameof(response));
            }

            return CreateFrom(response.JsonText);
        }

        /// <summary>
        /// Compares two instances for equality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are equal.</returns>
        public static bool operator ==(EnumFlagsEntity value1, EnumFlagsEntity value2)
        {
            var value1IsNull = object.ReferenceEquals(value1, null);
            var value2IsNull = object.ReferenceEquals(value2, null);

            if (value1IsNull == value2IsNull)
            {
                if (value1IsNull)
                {
                    return true;
                }
                else
                {
                    return value1.Equals(value2);
                }
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Compares two instances for inequality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are not equal.</returns>
        public static bool operator !=(EnumFlagsEntity value1, EnumFlagsEntity value2)
        {
            return !(value1 == value2);
        }

        //---------------------------------------------------------------------
        // Instance members:

        /// <summary>
        /// <b>INTERNAL USE ONLY:</b> This is the <see cref="JObject"/> is used to back
        /// all serialized round-trip.  This was made public for advanced unit testing but
        /// its use should generally be avoided for other purposes.  Use <see cref="ToJObject()"/>.
        /// instead.  "__O" is short for "object".
        /// </summary>
        [JsonIgnore]
        public JObject __O { get; set; }

        /// <summary>
        /// Constructs an uninitialized instance.
        /// </summary>
        public EnumFlagsEntity()
        {
            __O = new JObject();
        }

        /// <summary>
        /// Protected constructor used internally to initialize derived classes.
        /// </summary>
        /// <param name="jObject">The backing <see cref="JObject"/>.</param>
        protected EnumFlagsEntity(JObject jObject)
        {
            __O = jObject;
        }

        [JsonProperty(PropertyName = "Gender", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public GenderFlags Gender { get; set; }

        /// <summary>
        /// Loads the entity properties from the backing <see cref="JObject"/>
        /// or from the optional <see cref="JObject"/> passed.
        /// </summary>
        /// <param name="source">The optional source <see cref="JObject"/>.</param>
        /// <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        public virtual void __Load(JObject source = null, bool isDerived = false)
        {
            JProperty property;

            if (source != null)
            {
                this.__O = source;
            }

            if (this.__O == null)
            {
                this.__O = new JObject();
            }

            property = this.__O.Property("Gender");
            if (property != null)
            {
                this.Gender = property.Value.ToObject<GenderFlags>(RoundtripDataHelper.Serializer);
            }
        }

        /// <summary>
        /// Persists the properties from this instance to the backing <see cref="JObject"/>.
        /// </summary>
        /// <returns>The backing <see cref="JObject"/>.</returns>
        public virtual JObject __Save()
        {
            JProperty property;

            if (__O == null)
            {
                __O = new JObject();
            }

            this.__O["Gender"] = RoundtripDataHelper.FromObject(this.Gender, typeof(EnumFlagsEntity), nameof(Gender));

            return this.__O;
        }

        /// <summary>
        /// Renders the instance as JSON text.
        /// </summary>
        /// <returns>The serialized JSON string.</returns>
        public override string ToString()
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, Formatting.None);
        }

        /// <summary>
        /// Renders the instance as JSON text, optionally formatting the output.
        /// </summary>
        /// <param name="indented">Optionally pass <c>true</c> to format the output.</param>
        /// <returns>The serialized JSON string.</returns>
        public string ToString(bool indented)
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, indented ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Renders the instance as a new <see cref="JObject"/>.
        /// </summary>
        /// <returns>The rendered <see cref="JObject"/>.</returns>
        public JObject ToJObject()
        {
            __Save();
            return RoundtripDataHelper.DeepClone(__O);
        }

        /// <summary>
        /// Renders the instance as UTF-8 encoded JSON.
        /// </summary>
        /// <returns>The serialized JSON bytes.</returns>
        public virtual byte[] ToBytes()
        {
            __Save();
            return Encoding.UTF8.GetBytes(RoundtripDataHelper.Serialize(__O, Formatting.None));
        }

        /// <summary>
        /// Returns a deep clone of the instance.
        /// </summary>
        /// <returns>The cloned instance.</returns>
        public EnumFlagsEntity DeepClone()
        {
            __Save();
            return CreateFrom(RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Used to convert a base data model class into a derived class.
        /// </summary>
        /// <typeparam name="T">The desired derived type.</typeparam>
        /// <param name="noClone">
        /// By default, this method will create a deep clone of the underlying <see cref="JObject"/>
        /// and use this new instance when constructing the new object.  This is the safest
        /// approach but will cause a performance hit.  You can pass <paramref name="noClone"/><c>=true</c>
        /// to reuse the existing <see cref="JObject"/> for the new instance if you're sure that the
        /// original instance will no longer be accessed.
        /// </param>
        /// <returns>The converted instance of type <typeparamref name="T"/>.</returns>
        public T ToDerived<T>(bool noClone = false)
           where T : EnumFlagsEntity, IRoundtripData
        {
            __Save();
            return RoundtripDataFactory.CreateFrom<T>(noClone ? __O : RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Determines whether the current instance equals another object.
        /// </summary>
        /// <param name="obj">The other object instance or <c>null</c>.</param>
        /// <returns><c>true</c> if the object reference equals the current instance.</returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as EnumFlagsEntity;

            if (object.ReferenceEquals(other, null))
            {
                return false;
            }

            this.__Save();
            other.__Save();
            return JObject.DeepEquals(this.__O, other.__O);
        }

        /// <summary>
        /// Calculates the hash code for the instance.
        /// <note>
        /// At least one of the class properties must be tagged with a <b>[HashSource]</b>
        /// for this to work.
        /// </note>
        /// </summary>
        /// <returns>The calculated hash code.</returns>
        /// <exception cref="InvalidOperationException">Thrown when no class properties are tagged with a <c>[HashSourceAttribute]</c>.</exception>
        public override int GetHashCode()
        {
            throw new InvalidOperationException(RoundtripDataHelper.NoHashPropertiesError);
        }

        /// <summary>
        /// Writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        public virtual void WriteJsonTo(Stream stream)
        {
            __Save();

            using (var writer = new JsonTextWriter(new StreamWriter(stream)))
            {
                __O.WriteTo(writer);
            }
        }

        /// <summary>
        /// Asynchronously writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        /// <returns>The tracking <see cref="Task"/>.</returns>
        public virtual async Task WriteJsonToAsync(Stream stream)
        {
            await SyncContext.ClearAsync;
            __Save();

            await stream.WriteAsync(Encoding.UTF8.GetBytes(__O.ToString()));
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.EnumNotCustomEntity

    /// <threadsafety static="true" instance="false"/>
    public partial class EnumNotCustomEntity : IRoundtripData
    {
        //---------------------------------------------------------------------
        // Static members:

        /// <summary>
        /// Static constructor.
        /// </summary>
        static EnumNotCustomEntity()
        {
            // You need to add a reference to the [Neon.Common] assembly if the following line doesn't compile.

            NeonHelper.PackageReferenceToNeonCommonIsRequired();
        }

        /// <summary>
        /// Deserializes an instance from JSON text.
        /// </summary>
        /// <param name="jsonText">The JSON text input.</param>
        /// <returns>The deserialized <see cref="EnumNotCustomEntity"/>.</returns>
        public static EnumNotCustomEntity CreateFrom(string jsonText)
        {
            if (string.IsNullOrEmpty(jsonText))
            {
                throw new ArgumentNullException(nameof(jsonText));
            }

            var model = new EnumNotCustomEntity(RoundtripDataHelper.Deserialize<JObject>(jsonText));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject">The input <see cref="JObject"/>.</param>
        /// <returns>The deserialized <see cref="EnumNotCustomEntity"/>.</returns>
        public static EnumNotCustomEntity CreateFrom(JObject jObject)
        {
            if (jObject == null)
            {
                throw new ArgumentNullException(nameof(jObject));
            }

            var model = new EnumNotCustomEntity(jObject);

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="EnumNotCustomEntity"/>.</returns>
        public static EnumNotCustomEntity CreateFrom(Stream stream, Encoding encoding = null)
        {
            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            EnumNotCustomEntity model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = EnumNotCustomEntity.CreateFrom(reader.ReadToEnd());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a UTF-8 encoded byte array.
        /// </summary>
        /// <param name="bytes">The input byte array.</param>
        /// <returns>The deserialized <see cref="EnumNotCustomEntity"/>.</returns>
        public static EnumNotCustomEntity CreateFrom(byte[] bytes)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            var model = CreateFrom(Encoding.UTF8.GetString(bytes));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Asynchronously deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="EnumNotCustomEntity"/>.</returns>
        public static async Task<object> CreateFromAsync(Stream stream, Encoding encoding = null)
        {
            await SyncContext.ClearAsync;

            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            EnumNotCustomEntity model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = EnumNotCustomEntity.CreateFrom(await reader.ReadToEndAsync());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JsonResponse"/>.
        /// </summary>
        /// <param name="response">The input <see cref="JsonResponse"/>.</param>
        /// <returns>The deserialized <see cref="EnumNotCustomEntity"/>.</returns>
        public static EnumNotCustomEntity CreateFrom(JsonResponse response)
        {
            if (response == null)
            {
                throw new ArgumentNullException(nameof(response));
            }

            return CreateFrom(response.JsonText);
        }

        /// <summary>
        /// Compares two instances for equality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are equal.</returns>
        public static bool operator ==(EnumNotCustomEntity value1, EnumNotCustomEntity value2)
        {
            var value1IsNull = object.ReferenceEquals(value1, null);
            var value2IsNull = object.ReferenceEquals(value2, null);

            if (value1IsNull == value2IsNull)
            {
                if (value1IsNull)
                {
                    return true;
                }
                else
                {
                    return value1.Equals(value2);
                }
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Compares two instances for inequality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are not equal.</returns>
        public static bool operator !=(EnumNotCustomEntity value1, EnumNotCustomEntity value2)
        {
            return !(value1 == value2);
        }

        //---------------------------------------------------------------------
        // Instance members:

        /// <summary>
        /// <b>INTERNAL USE ONLY:</b> This is the <see cref="JObject"/> is used to back
        /// all serialized round-trip.  This was made public for advanced unit testing but
        /// its use should generally be avoided for other purposes.  Use <see cref="ToJObject()"/>.
        /// instead.  "__O" is short for "object".
        /// </summary>
        [JsonIgnore]
        public JObject __O { get; set; }

        /// <summary>
        /// Constructs an uninitialized instance.
        /// </summary>
        public EnumNotCustomEntity()
        {
            __O = new JObject();
        }

        /// <summary>
        /// Protected constructor used internally to initialize derived classes.
        /// </summary>
        /// <param name="jObject">The backing <see cref="JObject"/>.</param>
        protected EnumNotCustomEntity(JObject jObject)
        {
            __O = jObject;
        }

        [JsonProperty(PropertyName = "Gender", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public GenderNotCustom Gender { get; set; }

        /// <summary>
        /// Loads the entity properties from the backing <see cref="JObject"/>
        /// or from the optional <see cref="JObject"/> passed.
        /// </summary>
        /// <param name="source">The optional source <see cref="JObject"/>.</param>
        /// <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        public virtual void __Load(JObject source = null, bool isDerived = false)
        {
            JProperty property;

            if (source != null)
            {
                this.__O = source;
            }

            if (this.__O == null)
            {
                this.__O = new JObject();
            }

            property = this.__O.Property("Gender");
            if (property != null)
            {
                this.Gender = property.Value.ToObject<GenderNotCustom>(RoundtripDataHelper.Serializer);
            }
        }

        /// <summary>
        /// Persists the properties from this instance to the backing <see cref="JObject"/>.
        /// </summary>
        /// <returns>The backing <see cref="JObject"/>.</returns>
        public virtual JObject __Save()
        {
            JProperty property;

            if (__O == null)
            {
                __O = new JObject();
            }

            this.__O["Gender"] = RoundtripDataHelper.FromObject(this.Gender, typeof(EnumNotCustomEntity), nameof(Gender));

            return this.__O;
        }

        /// <summary>
        /// Renders the instance as JSON text.
        /// </summary>
        /// <returns>The serialized JSON string.</returns>
        public override string ToString()
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, Formatting.None);
        }

        /// <summary>
        /// Renders the instance as JSON text, optionally formatting the output.
        /// </summary>
        /// <param name="indented">Optionally pass <c>true</c> to format the output.</param>
        /// <returns>The serialized JSON string.</returns>
        public string ToString(bool indented)
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, indented ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Renders the instance as a new <see cref="JObject"/>.
        /// </summary>
        /// <returns>The rendered <see cref="JObject"/>.</returns>
        public JObject ToJObject()
        {
            __Save();
            return RoundtripDataHelper.DeepClone(__O);
        }

        /// <summary>
        /// Renders the instance as UTF-8 encoded JSON.
        /// </summary>
        /// <returns>The serialized JSON bytes.</returns>
        public virtual byte[] ToBytes()
        {
            __Save();
            return Encoding.UTF8.GetBytes(RoundtripDataHelper.Serialize(__O, Formatting.None));
        }

        /// <summary>
        /// Returns a deep clone of the instance.
        /// </summary>
        /// <returns>The cloned instance.</returns>
        public EnumNotCustomEntity DeepClone()
        {
            __Save();
            return CreateFrom(RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Used to convert a base data model class into a derived class.
        /// </summary>
        /// <typeparam name="T">The desired derived type.</typeparam>
        /// <param name="noClone">
        /// By default, this method will create a deep clone of the underlying <see cref="JObject"/>
        /// and use this new instance when constructing the new object.  This is the safest
        /// approach but will cause a performance hit.  You can pass <paramref name="noClone"/><c>=true</c>
        /// to reuse the existing <see cref="JObject"/> for the new instance if you're sure that the
        /// original instance will no longer be accessed.
        /// </param>
        /// <returns>The converted instance of type <typeparamref name="T"/>.</returns>
        public T ToDerived<T>(bool noClone = false)
           where T : EnumNotCustomEntity, IRoundtripData
        {
            __Save();
            return RoundtripDataFactory.CreateFrom<T>(noClone ? __O : RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Determines whether the current instance equals another object.
        /// </summary>
        /// <param name="obj">The other object instance or <c>null</c>.</param>
        /// <returns><c>true</c> if the object reference equals the current instance.</returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as EnumNotCustomEntity;

            if (object.ReferenceEquals(other, null))
            {
                return false;
            }

            this.__Save();
            other.__Save();
            return JObject.DeepEquals(this.__O, other.__O);
        }

        /// <summary>
        /// Calculates the hash code for the instance.
        /// <note>
        /// At least one of the class properties must be tagged with a <b>[HashSource]</b>
        /// for this to work.
        /// </note>
        /// </summary>
        /// <returns>The calculated hash code.</returns>
        /// <exception cref="InvalidOperationException">Thrown when no class properties are tagged with a <c>[HashSourceAttribute]</c>.</exception>
        public override int GetHashCode()
        {
            throw new InvalidOperationException(RoundtripDataHelper.NoHashPropertiesError);
        }

        /// <summary>
        /// Writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        public virtual void WriteJsonTo(Stream stream)
        {
            __Save();

            using (var writer = new JsonTextWriter(new StreamWriter(stream)))
            {
                __O.WriteTo(writer);
            }
        }

        /// <summary>
        /// Asynchronously writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        /// <returns>The tracking <see cref="Task"/>.</returns>
        public virtual async Task WriteJsonToAsync(Stream stream)
        {
            await SyncContext.ClearAsync;
            __Save();

            await stream.WriteAsync(Encoding.UTF8.GetBytes(__O.ToString()));
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.Family

    /// <threadsafety static="true" instance="false"/>
    public partial class Family : IRoundtripData, IPersistableType<Family>
    {
        //---------------------------------------------------------------------
        // Private types:

        /// <summary>
        /// Used to tag the <see cref="Family"/> entity such that Linq2Couchbase will
        /// be able to transparently add a <c>where</c> clause that filters by entity type
        /// to all queries for this entity type.
        /// </summary>
        private class FamilyFilter : global::Couchbase.Linq.Filters.IDocumentFilter<Family>
        {
            //-----------------------------------------------------------------
            // Static members:

            private static Expression<Func<Family, bool>> whereExpression;

            static FamilyFilter()
            {
                var parameter = Expression.Parameter(typeof(Family), "p");

                whereExpression = Expression.Lambda<Func<Family, bool>>(Expression.Equal(Expression.PropertyOrField(parameter, "__T"), Expression.Constant(Family.PersistedType)), parameter);
            }

            //-----------------------------------------------------------------
            // Instance members:

            public int Priority { get; set; }

            public IQueryable<Family> ApplyFilter(IQueryable<Family> source)
            {
                return source.Where(whereExpression);
            }
        }

        //---------------------------------------------------------------------
        // Static members:

        public const string PersistedType = "Family";

        /// <summary>
        /// Static constructor.
        /// </summary>
        static Family()
        {
            // You need to add a reference to the [Neon.Common] assembly if the following line doesn't compile.

            NeonHelper.PackageReferenceToNeonCommonIsRequired();
        }

        /// <summary>
        /// Performs any persistence related initialization including registering the Linq2Couchbase type
        /// filter.  This is typically called via <see cref="RoundtripDataHelper.PersistableInitialize()"/>.
        /// </summary>
        public static void PersistableInitialize()
        {
            // Register the document filter with Linq2Couchbase.

            global::Couchbase.Linq.Filters.DocumentFilterManager.SetFilter<Family>(new FamilyFilter());
        }

        /// <summary>
        /// Deserializes an instance from JSON text.
        /// </summary>
        /// <param name="jsonText">The JSON text input.</param>
        /// <returns>The deserialized <see cref="Family"/>.</returns>
        public static Family CreateFrom(string jsonText)
        {
            if (string.IsNullOrEmpty(jsonText))
            {
                throw new ArgumentNullException(nameof(jsonText));
            }

            var model = new Family(RoundtripDataHelper.Deserialize<JObject>(jsonText));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject">The input <see cref="JObject"/>.</param>
        /// <returns>The deserialized <see cref="Family"/>.</returns>
        public static Family CreateFrom(JObject jObject)
        {
            if (jObject == null)
            {
                throw new ArgumentNullException(nameof(jObject));
            }

            var model = new Family(jObject);

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="Family"/>.</returns>
        public static Family CreateFrom(Stream stream, Encoding encoding = null)
        {
            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            Family model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = Family.CreateFrom(reader.ReadToEnd());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a UTF-8 encoded byte array.
        /// </summary>
        /// <param name="bytes">The input byte array.</param>
        /// <returns>The deserialized <see cref="Family"/>.</returns>
        public static Family CreateFrom(byte[] bytes)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            var model = CreateFrom(Encoding.UTF8.GetString(bytes));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Asynchronously deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="Family"/>.</returns>
        public static async Task<object> CreateFromAsync(Stream stream, Encoding encoding = null)
        {
            await SyncContext.ClearAsync;

            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            Family model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = Family.CreateFrom(await reader.ReadToEndAsync());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JsonResponse"/>.
        /// </summary>
        /// <param name="response">The input <see cref="JsonResponse"/>.</param>
        /// <returns>The deserialized <see cref="Family"/>.</returns>
        public static Family CreateFrom(JsonResponse response)
        {
            if (response == null)
            {
                throw new ArgumentNullException(nameof(response));
            }

            return CreateFrom(response.JsonText);
        }

        /// <summary>
        /// Determines whether another entity instance has the same underlying type as this class.
        /// </summary>
        /// <param name="instance">The instance to be tested or <c>null</c>.</param>
        /// <returns>
        /// <c>true</c> if the <paramref name="instance"/> is not <c>null</c> and it has
        /// the same type as the current class.
        /// </returns>
        public static bool SameTypeAs(IPersistableType instance)
        {
            if (instance == null)
            {
                return false;
            }

            return instance.__T == Family.PersistedType;
        }

        /// <summary>
        /// Creates a persistence key.
        /// </summary>
        /// <param name="args">Arguments identifying the item.</param>
        public static string CreateKey(params object[] args)
        {
            return RoundtripDataHelper.GetPersistedKey("Family", args);
        }

        /// <summary>
        /// Compares two instances for equality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are equal.</returns>
        public static bool operator ==(Family value1, Family value2)
        {
            var value1IsNull = object.ReferenceEquals(value1, null);
            var value2IsNull = object.ReferenceEquals(value2, null);

            if (value1IsNull == value2IsNull)
            {
                if (value1IsNull)
                {
                    return true;
                }
                else
                {
                    return value1.Equals(value2);
                }
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Compares two instances for inequality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are not equal.</returns>
        public static bool operator !=(Family value1, Family value2)
        {
            return !(value1 == value2);
        }

        //---------------------------------------------------------------------
        // Instance members:

        private string cachedT;

        /// <summary>
        /// <b>INTERNAL USE ONLY:</b> This is the <see cref="JObject"/> is used to back
        /// all serialized round-trip.  This was made public for advanced unit testing but
        /// its use should generally be avoided for other purposes.  Use <see cref="ToJObject()"/>.
        /// instead.  "__O" is short for "object".
        /// </summary>
        [JsonIgnore]
        public JObject __O { get; set; }

        /// <summary>
        /// Constructs an uninitialized instance.
        /// </summary>
        public Family()
        {
            __T = PersistedType;
            __O = new JObject();
        }

        /// <summary>
        /// Protected constructor used internally to initialize derived classes.
        /// </summary>
        /// <param name="jObject">The backing <see cref="JObject"/>.</param>
        protected Family(JObject jObject)
        {
            __T = PersistedType;
            __O = jObject;
        }

        [JsonProperty(PropertyName = "id", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public int Id { get; set; }

        [JsonProperty(PropertyName = "mother", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public Person Mother { get; set; }

        [JsonProperty(PropertyName = "father", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public Person Father { get; set; }

        [JsonProperty(PropertyName = "baby", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public Person Baby { get; set; }

        /// <summary>
        /// Loads the entity properties from the backing <see cref="JObject"/>
        /// or from the optional <see cref="JObject"/> passed.
        /// </summary>
        /// <param name="source">The optional source <see cref="JObject"/>.</param>
        /// <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        public virtual void __Load(JObject source = null, bool isDerived = false)
        {
            JProperty property;

            if (source != null)
            {
                this.__O = source;
            }

            if (this.__O == null)
            {
                this.__O = new JObject();
            }

            property = this.__O.Property("id");
            if (property != null)
            {
                this.Id = (int)property.Value;
            }

            property = this.__O.Property("mother");
            if (property != null)
            {
                this.Mother = property.Value.ToObject<Person>(RoundtripDataHelper.Serializer);
            }

            property = this.__O.Property("father");
            if (property != null)
            {
                this.Father = property.Value.ToObject<Person>(RoundtripDataHelper.Serializer);
            }

            property = this.__O.Property("baby");
            if (property != null)
            {
                this.Baby = property.Value.ToObject<Person>(RoundtripDataHelper.Serializer);
            }

            if (!isDerived)
            {
                property = this.__O.Property("T$$");
                if (property == null)
                {
                    throw new ArgumentNullException("[Family.T$$] property is required when deserializing.");
                }
                else
                {
                    this.__T = (string)property.Value;
                }
            }
        }

        /// <summary>
        /// Persists the properties from this instance to the backing <see cref="JObject"/>.
        /// </summary>
        /// <returns>The backing <see cref="JObject"/>.</returns>
        public virtual JObject __Save()
        {
            JProperty property;

            if (__O == null)
            {
                __O = new JObject();
            }

            this.__O["id"] = this.Id;
            this.__O["mother"] = RoundtripDataHelper.FromObject(this.Mother, typeof(Family), nameof(Mother));
            this.__O["father"] = RoundtripDataHelper.FromObject(this.Father, typeof(Family), nameof(Father));
            this.__O["baby"] = RoundtripDataHelper.FromObject(this.Baby, typeof(Family), nameof(Baby));
            this.__O["T$$"] = PersistedType;

            return this.__O;
        }

        /// <summary>
        /// Renders the instance as JSON text.
        /// </summary>
        /// <returns>The serialized JSON string.</returns>
        public override string ToString()
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, Formatting.None);
        }

        /// <summary>
        /// Renders the instance as JSON text, optionally formatting the output.
        /// </summary>
        /// <param name="indented">Optionally pass <c>true</c> to format the output.</param>
        /// <returns>The serialized JSON string.</returns>
        public string ToString(bool indented)
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, indented ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Renders the instance as a new <see cref="JObject"/>.
        /// </summary>
        /// <returns>The rendered <see cref="JObject"/>.</returns>
        public JObject ToJObject()
        {
            __Save();
            return RoundtripDataHelper.DeepClone(__O);
        }

        /// <summary>
        /// Renders the instance as UTF-8 encoded JSON.
        /// </summary>
        /// <returns>The serialized JSON bytes.</returns>
        public virtual byte[] ToBytes()
        {
            __Save();
            return Encoding.UTF8.GetBytes(RoundtripDataHelper.Serialize(__O, Formatting.None));
        }

        /// <summary>
        /// Returns a deep clone of the instance.
        /// </summary>
        /// <returns>The cloned instance.</returns>
        public Family DeepClone()
        {
            __Save();
            return CreateFrom(RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Used to convert a base data model class into a derived class.
        /// </summary>
        /// <typeparam name="T">The desired derived type.</typeparam>
        /// <param name="noClone">
        /// By default, this method will create a deep clone of the underlying <see cref="JObject"/>
        /// and use this new instance when constructing the new object.  This is the safest
        /// approach but will cause a performance hit.  You can pass <paramref name="noClone"/><c>=true</c>
        /// to reuse the existing <see cref="JObject"/> for the new instance if you're sure that the
        /// original instance will no longer be accessed.
        /// </param>
        /// <returns>The converted instance of type <typeparamref name="T"/>.</returns>
        public T ToDerived<T>(bool noClone = false)
           where T : Family, IRoundtripData
        {
            __Save();
            return RoundtripDataFactory.CreateFrom<T>(noClone ? __O : RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Determines whether the current instance equals another object.
        /// </summary>
        /// <param name="obj">The other object instance or <c>null</c>.</param>
        /// <returns><c>true</c> if the object reference equals the current instance.</returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as Family;

            if (object.ReferenceEquals(other, null))
            {
                return false;
            }

            this.__Save();
            other.__Save();
            return JObject.DeepEquals(this.__O, other.__O);
        }

        /// <summary>
        /// Calculates the hash code for the instance.
        /// <note>
        /// At least one of the class properties must be tagged with a <b>[HashSource]</b>
        /// for this to work.
        /// </note>
        /// </summary>
        /// <returns>The calculated hash code.</returns>
        /// <exception cref="InvalidOperationException">Thrown when no class properties are tagged with a <c>[HashSourceAttribute]</c>.</exception>
        public override int GetHashCode()
        {
            throw new InvalidOperationException(RoundtripDataHelper.NoHashPropertiesError);
        }

        /// <summary>
        /// Identifies the persisted object type.  "__T" is short for "type".  This is persisted as "T$$".
        /// </summary>
        [JsonProperty(PropertyName = "T$$", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        [DefaultValue(null)]
        public string __T
        {
            get
            {
                 if (cachedT != null)
                 {
                     return cachedT;
                 }

                 cachedT = (string)__O["T$$"];

                 if (cachedT != null)
                 {
                     return cachedT;
                 }

                 return PersistedType;
            }

            set => cachedT = value;
        }

        /// <summary>
        /// Returns the object's persistence key.
        /// </summary>
        public string GetKey()
        {
            return RoundtripDataHelper.GetPersistedKey(PersistedType, Id.ToString());
        }

        /// <summary>
        /// Writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        public virtual void WriteJsonTo(Stream stream)
        {
            __Save();

            using (var writer = new JsonTextWriter(new StreamWriter(stream)))
            {
                __O.WriteTo(writer);
            }
        }

        /// <summary>
        /// Asynchronously writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        /// <returns>The tracking <see cref="Task"/>.</returns>
        public virtual async Task WriteJsonToAsync(Stream stream)
        {
            await SyncContext.ClearAsync;
            __Save();

            await stream.WriteAsync(Encoding.UTF8.GetBytes(__O.ToString()));
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.Gender

    public enum Gender : int
    {
        [EnumMember(Value = "unspecified")]
        Unspecified = 0,
        [EnumMember(Value = "male")]
        Male = 1,
        [EnumMember(Value = "female")]
        Female = 2,
        [EnumMember(Value = "other")]
        Other = 3,
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.GenderFlags

    [Flags]
    public enum GenderFlags : int
    {
        [EnumMember(Value = "unspecified")]
        Unspecified = 0,
        [EnumMember(Value = "male")]
        Male = 1,
        [EnumMember(Value = "female")]
        Female = 2,
        [EnumMember(Value = "other")]
        Other = 4,
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.GenderNotCustom

    public enum GenderNotCustom : int
    {
        [EnumMember(Value = "Unspecified")]
        Unspecified = 0,
        [EnumMember(Value = "Male")]
        Male = 1,
        [EnumMember(Value = "Female")]
        Female = 2,
        [EnumMember(Value = "Other")]
        Other = 3,
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.MyEnum

    public enum MyEnum : int
    {
        [EnumMember(Value = "Zero")]
        Zero = 0,
        [EnumMember(Value = "One")]
        One = 1,
        [EnumMember(Value = "Two")]
        Two = 2,
        [EnumMember(Value = "Three")]
        Three = 3,
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.NonPersistablePerson

    /// <threadsafety static="true" instance="false"/>
    public partial class NonPersistablePerson : IRoundtripData
    {
        //---------------------------------------------------------------------
        // Static members:

        /// <summary>
        /// Static constructor.
        /// </summary>
        static NonPersistablePerson()
        {
            // You need to add a reference to the [Neon.Common] assembly if the following line doesn't compile.

            NeonHelper.PackageReferenceToNeonCommonIsRequired();
        }

        /// <summary>
        /// Deserializes an instance from JSON text.
        /// </summary>
        /// <param name="jsonText">The JSON text input.</param>
        /// <returns>The deserialized <see cref="NonPersistablePerson"/>.</returns>
        public static NonPersistablePerson CreateFrom(string jsonText)
        {
            if (string.IsNullOrEmpty(jsonText))
            {
                throw new ArgumentNullException(nameof(jsonText));
            }

            var model = new NonPersistablePerson(RoundtripDataHelper.Deserialize<JObject>(jsonText));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject">The input <see cref="JObject"/>.</param>
        /// <returns>The deserialized <see cref="NonPersistablePerson"/>.</returns>
        public static NonPersistablePerson CreateFrom(JObject jObject)
        {
            if (jObject == null)
            {
                throw new ArgumentNullException(nameof(jObject));
            }

            var model = new NonPersistablePerson(jObject);

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="NonPersistablePerson"/>.</returns>
        public static NonPersistablePerson CreateFrom(Stream stream, Encoding encoding = null)
        {
            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            NonPersistablePerson model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = NonPersistablePerson.CreateFrom(reader.ReadToEnd());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a UTF-8 encoded byte array.
        /// </summary>
        /// <param name="bytes">The input byte array.</param>
        /// <returns>The deserialized <see cref="NonPersistablePerson"/>.</returns>
        public static NonPersistablePerson CreateFrom(byte[] bytes)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            var model = CreateFrom(Encoding.UTF8.GetString(bytes));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Asynchronously deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="NonPersistablePerson"/>.</returns>
        public static async Task<object> CreateFromAsync(Stream stream, Encoding encoding = null)
        {
            await SyncContext.ClearAsync;

            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            NonPersistablePerson model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = NonPersistablePerson.CreateFrom(await reader.ReadToEndAsync());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JsonResponse"/>.
        /// </summary>
        /// <param name="response">The input <see cref="JsonResponse"/>.</param>
        /// <returns>The deserialized <see cref="NonPersistablePerson"/>.</returns>
        public static NonPersistablePerson CreateFrom(JsonResponse response)
        {
            if (response == null)
            {
                throw new ArgumentNullException(nameof(response));
            }

            return CreateFrom(response.JsonText);
        }

        /// <summary>
        /// Compares two instances for equality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are equal.</returns>
        public static bool operator ==(NonPersistablePerson value1, NonPersistablePerson value2)
        {
            var value1IsNull = object.ReferenceEquals(value1, null);
            var value2IsNull = object.ReferenceEquals(value2, null);

            if (value1IsNull == value2IsNull)
            {
                if (value1IsNull)
                {
                    return true;
                }
                else
                {
                    return value1.Equals(value2);
                }
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Compares two instances for inequality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are not equal.</returns>
        public static bool operator !=(NonPersistablePerson value1, NonPersistablePerson value2)
        {
            return !(value1 == value2);
        }

        //---------------------------------------------------------------------
        // Instance members:

        /// <summary>
        /// <b>INTERNAL USE ONLY:</b> This is the <see cref="JObject"/> is used to back
        /// all serialized round-trip.  This was made public for advanced unit testing but
        /// its use should generally be avoided for other purposes.  Use <see cref="ToJObject()"/>.
        /// instead.  "__O" is short for "object".
        /// </summary>
        [JsonIgnore]
        public JObject __O { get; set; }

        /// <summary>
        /// Constructs an uninitialized instance.
        /// </summary>
        public NonPersistablePerson()
        {
            __O = new JObject();
        }

        /// <summary>
        /// Protected constructor used internally to initialize derived classes.
        /// </summary>
        /// <param name="jObject">The backing <see cref="JObject"/>.</param>
        protected NonPersistablePerson(JObject jObject)
        {
            __O = jObject;
        }

        [JsonProperty(PropertyName = "my-id", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public int Id { get; set; }

        [JsonProperty(PropertyName = "my-name", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public string Name { get; set; }

        [JsonProperty(PropertyName = "my-age", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public int Age { get; set; }

        [JsonProperty(PropertyName = "my-gender", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public Gender Gender { get; set; }

        [JsonProperty(PropertyName = "my-data", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public byte[] Data { get; set; }

        /// <summary>
        /// Loads the entity properties from the backing <see cref="JObject"/>
        /// or from the optional <see cref="JObject"/> passed.
        /// </summary>
        /// <param name="source">The optional source <see cref="JObject"/>.</param>
        /// <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        public virtual void __Load(JObject source = null, bool isDerived = false)
        {
            JProperty property;

            if (source != null)
            {
                this.__O = source;
            }

            if (this.__O == null)
            {
                this.__O = new JObject();
            }

            property = this.__O.Property("my-id");
            if (property != null)
            {
                this.Id = (int)property.Value;
            }

            property = this.__O.Property("my-name");
            if (property != null)
            {
                this.Name = (string)property.Value;
            }

            property = this.__O.Property("my-age");
            if (property != null)
            {
                this.Age = (int)property.Value;
            }

            property = this.__O.Property("my-gender");
            if (property != null)
            {
                this.Gender = property.Value.ToObject<Gender>(RoundtripDataHelper.Serializer);
            }

            property = this.__O.Property("my-data");
            if (property != null)
            {
                this.Data = property.Value.ToObject<byte[]>(RoundtripDataHelper.Serializer);
            }
        }

        /// <summary>
        /// Persists the properties from this instance to the backing <see cref="JObject"/>.
        /// </summary>
        /// <returns>The backing <see cref="JObject"/>.</returns>
        public virtual JObject __Save()
        {
            JProperty property;

            if (__O == null)
            {
                __O = new JObject();
            }

            this.__O["my-id"] = this.Id;
            this.__O["my-name"] = this.Name;
            this.__O["my-age"] = this.Age;
            this.__O["my-gender"] = RoundtripDataHelper.FromObject(this.Gender, typeof(NonPersistablePerson), nameof(Gender));
            this.__O["my-data"] = RoundtripDataHelper.FromObject(this.Data, typeof(NonPersistablePerson), nameof(Data));

            return this.__O;
        }

        /// <summary>
        /// Renders the instance as JSON text.
        /// </summary>
        /// <returns>The serialized JSON string.</returns>
        public override string ToString()
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, Formatting.None);
        }

        /// <summary>
        /// Renders the instance as JSON text, optionally formatting the output.
        /// </summary>
        /// <param name="indented">Optionally pass <c>true</c> to format the output.</param>
        /// <returns>The serialized JSON string.</returns>
        public string ToString(bool indented)
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, indented ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Renders the instance as a new <see cref="JObject"/>.
        /// </summary>
        /// <returns>The rendered <see cref="JObject"/>.</returns>
        public JObject ToJObject()
        {
            __Save();
            return RoundtripDataHelper.DeepClone(__O);
        }

        /// <summary>
        /// Renders the instance as UTF-8 encoded JSON.
        /// </summary>
        /// <returns>The serialized JSON bytes.</returns>
        public virtual byte[] ToBytes()
        {
            __Save();
            return Encoding.UTF8.GetBytes(RoundtripDataHelper.Serialize(__O, Formatting.None));
        }

        /// <summary>
        /// Returns a deep clone of the instance.
        /// </summary>
        /// <returns>The cloned instance.</returns>
        public NonPersistablePerson DeepClone()
        {
            __Save();
            return CreateFrom(RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Used to convert a base data model class into a derived class.
        /// </summary>
        /// <typeparam name="T">The desired derived type.</typeparam>
        /// <param name="noClone">
        /// By default, this method will create a deep clone of the underlying <see cref="JObject"/>
        /// and use this new instance when constructing the new object.  This is the safest
        /// approach but will cause a performance hit.  You can pass <paramref name="noClone"/><c>=true</c>
        /// to reuse the existing <see cref="JObject"/> for the new instance if you're sure that the
        /// original instance will no longer be accessed.
        /// </param>
        /// <returns>The converted instance of type <typeparamref name="T"/>.</returns>
        public T ToDerived<T>(bool noClone = false)
           where T : NonPersistablePerson, IRoundtripData
        {
            __Save();
            return RoundtripDataFactory.CreateFrom<T>(noClone ? __O : RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Determines whether the current instance equals another object.
        /// </summary>
        /// <param name="obj">The other object instance or <c>null</c>.</param>
        /// <returns><c>true</c> if the object reference equals the current instance.</returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as NonPersistablePerson;

            if (object.ReferenceEquals(other, null))
            {
                return false;
            }

            this.__Save();
            other.__Save();
            return JObject.DeepEquals(this.__O, other.__O);
        }

        /// <summary>
        /// Calculates the hash code for the instance.
        /// <note>
        /// At least one of the class properties must be tagged with a <b>[HashSource]</b>
        /// for this to work.
        /// </note>
        /// </summary>
        /// <returns>The calculated hash code.</returns>
        /// <exception cref="InvalidOperationException">Thrown when no class properties are tagged with a <c>[HashSourceAttribute]</c>.</exception>
        public override int GetHashCode()
        {
            throw new InvalidOperationException(RoundtripDataHelper.NoHashPropertiesError);
        }

        /// <summary>
        /// Writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        public virtual void WriteJsonTo(Stream stream)
        {
            __Save();

            using (var writer = new JsonTextWriter(new StreamWriter(stream)))
            {
                __O.WriteTo(writer);
            }
        }

        /// <summary>
        /// Asynchronously writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        /// <returns>The tracking <see cref="Task"/>.</returns>
        public virtual async Task WriteJsonToAsync(Stream stream)
        {
            await SyncContext.ClearAsync;
            __Save();

            await stream.WriteAsync(Encoding.UTF8.GetBytes(__O.ToString()));
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.Person

    /// <threadsafety static="true" instance="false"/>
    public partial class Person : IRoundtripData, IPersistableType<Person>
    {
        //---------------------------------------------------------------------
        // Private types:

        /// <summary>
        /// Used to tag the <see cref="Person"/> entity such that Linq2Couchbase will
        /// be able to transparently add a <c>where</c> clause that filters by entity type
        /// to all queries for this entity type.
        /// </summary>
        private class PersonFilter : global::Couchbase.Linq.Filters.IDocumentFilter<Person>
        {
            //-----------------------------------------------------------------
            // Static members:

            private static Expression<Func<Person, bool>> whereExpression;

            static PersonFilter()
            {
                var parameter = Expression.Parameter(typeof(Person), "p");

                whereExpression = Expression.Lambda<Func<Person, bool>>(Expression.Equal(Expression.PropertyOrField(parameter, "__T"), Expression.Constant(Person.PersistedType)), parameter);
            }

            //-----------------------------------------------------------------
            // Instance members:

            public int Priority { get; set; }

            public IQueryable<Person> ApplyFilter(IQueryable<Person> source)
            {
                return source.Where(whereExpression);
            }
        }

        //---------------------------------------------------------------------
        // Static members:

        public const string PersistedType = "Test.Neon.Models.Definitions.Person";

        /// <summary>
        /// Static constructor.
        /// </summary>
        static Person()
        {
            // You need to add a reference to the [Neon.Common] assembly if the following line doesn't compile.

            NeonHelper.PackageReferenceToNeonCommonIsRequired();
        }

        /// <summary>
        /// Performs any persistence related initialization including registering the Linq2Couchbase type
        /// filter.  This is typically called via <see cref="RoundtripDataHelper.PersistableInitialize()"/>.
        /// </summary>
        public static void PersistableInitialize()
        {
            // Register the document filter with Linq2Couchbase.

            global::Couchbase.Linq.Filters.DocumentFilterManager.SetFilter<Person>(new PersonFilter());
        }

        /// <summary>
        /// Deserializes an instance from JSON text.
        /// </summary>
        /// <param name="jsonText">The JSON text input.</param>
        /// <returns>The deserialized <see cref="Person"/>.</returns>
        public static Person CreateFrom(string jsonText)
        {
            if (string.IsNullOrEmpty(jsonText))
            {
                throw new ArgumentNullException(nameof(jsonText));
            }

            var model = new Person(RoundtripDataHelper.Deserialize<JObject>(jsonText));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject">The input <see cref="JObject"/>.</param>
        /// <returns>The deserialized <see cref="Person"/>.</returns>
        public static Person CreateFrom(JObject jObject)
        {
            if (jObject == null)
            {
                throw new ArgumentNullException(nameof(jObject));
            }

            var model = new Person(jObject);

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="Person"/>.</returns>
        public static Person CreateFrom(Stream stream, Encoding encoding = null)
        {
            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            Person model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = Person.CreateFrom(reader.ReadToEnd());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a UTF-8 encoded byte array.
        /// </summary>
        /// <param name="bytes">The input byte array.</param>
        /// <returns>The deserialized <see cref="Person"/>.</returns>
        public static Person CreateFrom(byte[] bytes)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            var model = CreateFrom(Encoding.UTF8.GetString(bytes));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Asynchronously deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="Person"/>.</returns>
        public static async Task<object> CreateFromAsync(Stream stream, Encoding encoding = null)
        {
            await SyncContext.ClearAsync;

            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            Person model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = Person.CreateFrom(await reader.ReadToEndAsync());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JsonResponse"/>.
        /// </summary>
        /// <param name="response">The input <see cref="JsonResponse"/>.</param>
        /// <returns>The deserialized <see cref="Person"/>.</returns>
        public static Person CreateFrom(JsonResponse response)
        {
            if (response == null)
            {
                throw new ArgumentNullException(nameof(response));
            }

            return CreateFrom(response.JsonText);
        }

        /// <summary>
        /// Determines whether another entity instance has the same underlying type as this class.
        /// </summary>
        /// <param name="instance">The instance to be tested or <c>null</c>.</param>
        /// <returns>
        /// <c>true</c> if the <paramref name="instance"/> is not <c>null</c> and it has
        /// the same type as the current class.
        /// </returns>
        public static bool SameTypeAs(IPersistableType instance)
        {
            if (instance == null)
            {
                return false;
            }

            return instance.__T == Person.PersistedType;
        }

        /// <summary>
        /// Creates a persistence key.
        /// </summary>
        /// <param name="args">Arguments identifying the item.</param>
        public static string CreateKey(params object[] args)
        {
            return RoundtripDataHelper.GetPersistedKey("Test.Neon.Models.Definitions.Person", args);
        }

        /// <summary>
        /// Compares two instances for equality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are equal.</returns>
        public static bool operator ==(Person value1, Person value2)
        {
            var value1IsNull = object.ReferenceEquals(value1, null);
            var value2IsNull = object.ReferenceEquals(value2, null);

            if (value1IsNull == value2IsNull)
            {
                if (value1IsNull)
                {
                    return true;
                }
                else
                {
                    return value1.Equals(value2);
                }
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Compares two instances for inequality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are not equal.</returns>
        public static bool operator !=(Person value1, Person value2)
        {
            return !(value1 == value2);
        }

        //---------------------------------------------------------------------
        // Instance members:

        private string cachedT;

        /// <summary>
        /// <b>INTERNAL USE ONLY:</b> This is the <see cref="JObject"/> is used to back
        /// all serialized round-trip.  This was made public for advanced unit testing but
        /// its use should generally be avoided for other purposes.  Use <see cref="ToJObject()"/>.
        /// instead.  "__O" is short for "object".
        /// </summary>
        [JsonIgnore]
        public JObject __O { get; set; }

        /// <summary>
        /// Constructs an uninitialized instance.
        /// </summary>
        public Person()
        {
            __T = PersistedType;
            __O = new JObject();
        }

        /// <summary>
        /// Protected constructor used internally to initialize derived classes.
        /// </summary>
        /// <param name="jObject">The backing <see cref="JObject"/>.</param>
        protected Person(JObject jObject)
        {
            __T = PersistedType;
            __O = jObject;
        }

        [JsonProperty(PropertyName = "Id", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public int Id { get; set; }

        [JsonProperty(PropertyName = "Name", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public string Name { get; set; }

        [JsonProperty(PropertyName = "Age", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public int Age { get; set; }

        [JsonProperty(PropertyName = "Gender", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public Gender Gender { get; set; }

        [JsonProperty(PropertyName = "Data", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public byte[] Data { get; set; }

        /// <summary>
        /// Loads the entity properties from the backing <see cref="JObject"/>
        /// or from the optional <see cref="JObject"/> passed.
        /// </summary>
        /// <param name="source">The optional source <see cref="JObject"/>.</param>
        /// <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        public virtual void __Load(JObject source = null, bool isDerived = false)
        {
            JProperty property;

            if (source != null)
            {
                this.__O = source;
            }

            if (this.__O == null)
            {
                this.__O = new JObject();
            }

            property = this.__O.Property("Id");
            if (property != null)
            {
                this.Id = (int)property.Value;
            }

            property = this.__O.Property("Name");
            if (property != null)
            {
                this.Name = (string)property.Value;
            }

            property = this.__O.Property("Age");
            if (property != null)
            {
                this.Age = (int)property.Value;
            }

            property = this.__O.Property("Gender");
            if (property != null)
            {
                this.Gender = property.Value.ToObject<Gender>(RoundtripDataHelper.Serializer);
            }

            property = this.__O.Property("Data");
            if (property != null)
            {
                this.Data = property.Value.ToObject<byte[]>(RoundtripDataHelper.Serializer);
            }

            if (!isDerived)
            {
                property = this.__O.Property("T$$");
                if (property == null)
                {
                    throw new ArgumentNullException("[Person.T$$] property is required when deserializing.");
                }
                else
                {
                    this.__T = (string)property.Value;
                }
            }
        }

        /// <summary>
        /// Persists the properties from this instance to the backing <see cref="JObject"/>.
        /// </summary>
        /// <returns>The backing <see cref="JObject"/>.</returns>
        public virtual JObject __Save()
        {
            JProperty property;

            if (__O == null)
            {
                __O = new JObject();
            }

            this.__O["Id"] = this.Id;
            this.__O["Name"] = this.Name;
            this.__O["Age"] = this.Age;
            this.__O["Gender"] = RoundtripDataHelper.FromObject(this.Gender, typeof(Person), nameof(Gender));
            this.__O["Data"] = RoundtripDataHelper.FromObject(this.Data, typeof(Person), nameof(Data));
            this.__O["T$$"] = PersistedType;

            return this.__O;
        }

        /// <summary>
        /// Renders the instance as JSON text.
        /// </summary>
        /// <returns>The serialized JSON string.</returns>
        public override string ToString()
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, Formatting.None);
        }

        /// <summary>
        /// Renders the instance as JSON text, optionally formatting the output.
        /// </summary>
        /// <param name="indented">Optionally pass <c>true</c> to format the output.</param>
        /// <returns>The serialized JSON string.</returns>
        public string ToString(bool indented)
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, indented ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Renders the instance as a new <see cref="JObject"/>.
        /// </summary>
        /// <returns>The rendered <see cref="JObject"/>.</returns>
        public JObject ToJObject()
        {
            __Save();
            return RoundtripDataHelper.DeepClone(__O);
        }

        /// <summary>
        /// Renders the instance as UTF-8 encoded JSON.
        /// </summary>
        /// <returns>The serialized JSON bytes.</returns>
        public virtual byte[] ToBytes()
        {
            __Save();
            return Encoding.UTF8.GetBytes(RoundtripDataHelper.Serialize(__O, Formatting.None));
        }

        /// <summary>
        /// Returns a deep clone of the instance.
        /// </summary>
        /// <returns>The cloned instance.</returns>
        public Person DeepClone()
        {
            __Save();
            return CreateFrom(RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Used to convert a base data model class into a derived class.
        /// </summary>
        /// <typeparam name="T">The desired derived type.</typeparam>
        /// <param name="noClone">
        /// By default, this method will create a deep clone of the underlying <see cref="JObject"/>
        /// and use this new instance when constructing the new object.  This is the safest
        /// approach but will cause a performance hit.  You can pass <paramref name="noClone"/><c>=true</c>
        /// to reuse the existing <see cref="JObject"/> for the new instance if you're sure that the
        /// original instance will no longer be accessed.
        /// </param>
        /// <returns>The converted instance of type <typeparamref name="T"/>.</returns>
        public T ToDerived<T>(bool noClone = false)
           where T : Person, IRoundtripData
        {
            __Save();
            return RoundtripDataFactory.CreateFrom<T>(noClone ? __O : RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Determines whether the current instance equals another object.
        /// </summary>
        /// <param name="obj">The other object instance or <c>null</c>.</param>
        /// <returns><c>true</c> if the object reference equals the current instance.</returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as Person;

            if (object.ReferenceEquals(other, null))
            {
                return false;
            }

            this.__Save();
            other.__Save();
            return JObject.DeepEquals(this.__O, other.__O);
        }

        /// <summary>
        /// Calculates the hash code for the instance.
        /// <note>
        /// At least one of the class properties must be tagged with a <b>[HashSource]</b>
        /// for this to work.
        /// </note>
        /// </summary>
        /// <returns>The calculated hash code.</returns>
        /// <exception cref="InvalidOperationException">Thrown when no class properties are tagged with a <c>[HashSourceAttribute]</c>.</exception>
        public override int GetHashCode()
        {
            throw new InvalidOperationException(RoundtripDataHelper.NoHashPropertiesError);
        }

        /// <summary>
        /// Identifies the persisted object type.  "__T" is short for "type".  This is persisted as "T$$".
        /// </summary>
        [JsonProperty(PropertyName = "T$$", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        [DefaultValue(null)]
        public string __T
        {
            get
            {
                 if (cachedT != null)
                 {
                     return cachedT;
                 }

                 cachedT = (string)__O["T$$"];

                 if (cachedT != null)
                 {
                     return cachedT;
                 }

                 return PersistedType;
            }

            set => cachedT = value;
        }

        /// <summary>
        /// Returns the object's persistence key.
        /// </summary>
        public string GetKey()
        {
            return RoundtripDataHelper.GetPersistedKey(PersistedType, Id.ToString());
        }

        /// <summary>
        /// Writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        public virtual void WriteJsonTo(Stream stream)
        {
            __Save();

            using (var writer = new JsonTextWriter(new StreamWriter(stream)))
            {
                __O.WriteTo(writer);
            }
        }

        /// <summary>
        /// Asynchronously writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        /// <returns>The tracking <see cref="Task"/>.</returns>
        public virtual async Task WriteJsonToAsync(Stream stream)
        {
            await SyncContext.ClearAsync;
            __Save();

            await stream.WriteAsync(Encoding.UTF8.GetBytes(__O.ToString()));
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.TagColor

    /// <threadsafety static="true" instance="false"/>
    public partial class TagColor : IRoundtripData, IPersistableType<TagColor>
    {
        //---------------------------------------------------------------------
        // Private types:

        /// <summary>
        /// Used to tag the <see cref="TagColor"/> entity such that Linq2Couchbase will
        /// be able to transparently add a <c>where</c> clause that filters by entity type
        /// to all queries for this entity type.
        /// </summary>
        private class TagColorFilter : global::Couchbase.Linq.Filters.IDocumentFilter<TagColor>
        {
            //-----------------------------------------------------------------
            // Static members:

            private static Expression<Func<TagColor, bool>> whereExpression;

            static TagColorFilter()
            {
                var parameter = Expression.Parameter(typeof(TagColor), "p");

                whereExpression = Expression.Lambda<Func<TagColor, bool>>(Expression.Equal(Expression.PropertyOrField(parameter, "__T"), Expression.Constant(TagColor.PersistedType)), parameter);
            }

            //-----------------------------------------------------------------
            // Instance members:

            public int Priority { get; set; }

            public IQueryable<TagColor> ApplyFilter(IQueryable<TagColor> source)
            {
                return source.Where(whereExpression);
            }
        }

        //---------------------------------------------------------------------
        // Static members:

        public const string PersistedType = "TagColor";

        /// <summary>
        /// Static constructor.
        /// </summary>
        static TagColor()
        {
            // You need to add a reference to the [Neon.Common] assembly if the following line doesn't compile.

            NeonHelper.PackageReferenceToNeonCommonIsRequired();
        }

        /// <summary>
        /// Performs any persistence related initialization including registering the Linq2Couchbase type
        /// filter.  This is typically called via <see cref="RoundtripDataHelper.PersistableInitialize()"/>.
        /// </summary>
        public static void PersistableInitialize()
        {
            // Register the document filter with Linq2Couchbase.

            global::Couchbase.Linq.Filters.DocumentFilterManager.SetFilter<TagColor>(new TagColorFilter());
        }

        /// <summary>
        /// Deserializes an instance from JSON text.
        /// </summary>
        /// <param name="jsonText">The JSON text input.</param>
        /// <returns>The deserialized <see cref="TagColor"/>.</returns>
        public static TagColor CreateFrom(string jsonText)
        {
            if (string.IsNullOrEmpty(jsonText))
            {
                throw new ArgumentNullException(nameof(jsonText));
            }

            var model = new TagColor(RoundtripDataHelper.Deserialize<JObject>(jsonText));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject">The input <see cref="JObject"/>.</param>
        /// <returns>The deserialized <see cref="TagColor"/>.</returns>
        public static TagColor CreateFrom(JObject jObject)
        {
            if (jObject == null)
            {
                throw new ArgumentNullException(nameof(jObject));
            }

            var model = new TagColor(jObject);

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="TagColor"/>.</returns>
        public static TagColor CreateFrom(Stream stream, Encoding encoding = null)
        {
            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            TagColor model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = TagColor.CreateFrom(reader.ReadToEnd());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a UTF-8 encoded byte array.
        /// </summary>
        /// <param name="bytes">The input byte array.</param>
        /// <returns>The deserialized <see cref="TagColor"/>.</returns>
        public static TagColor CreateFrom(byte[] bytes)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            var model = CreateFrom(Encoding.UTF8.GetString(bytes));

            model.__Load();
            return model;
        }

        /// <summary>
        /// Asynchronously deserializes an instance from a <see cref="Stream"/>.
        /// </summary>
        /// <param name="stream">The input <see cref="Stream"/>.</param>
        /// <param name="encoding">Optionally specifies the inout encoding.  This defaults to <see cref="Encoding.UTF8"/>.</param>
        /// <returns>The deserialized <see cref="TagColor"/>.</returns>
        public static async Task<object> CreateFromAsync(Stream stream, Encoding encoding = null)
        {
            await SyncContext.ClearAsync;

            encoding = encoding ?? Encoding.UTF8;

            if (stream == null)
            {
                throw new ArgumentNullException(nameof(stream));
            }

            TagColor model;

            using (var reader = new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: false, bufferSize: 8192, leaveOpen: true))
            {
                model = TagColor.CreateFrom(await reader.ReadToEndAsync());
            }

            model.__Load();
            return model;
        }

        /// <summary>
        /// Deserializes an instance from a <see cref="JsonResponse"/>.
        /// </summary>
        /// <param name="response">The input <see cref="JsonResponse"/>.</param>
        /// <returns>The deserialized <see cref="TagColor"/>.</returns>
        public static TagColor CreateFrom(JsonResponse response)
        {
            if (response == null)
            {
                throw new ArgumentNullException(nameof(response));
            }

            return CreateFrom(response.JsonText);
        }

        /// <summary>
        /// Determines whether another entity instance has the same underlying type as this class.
        /// </summary>
        /// <param name="instance">The instance to be tested or <c>null</c>.</param>
        /// <returns>
        /// <c>true</c> if the <paramref name="instance"/> is not <c>null</c> and it has
        /// the same type as the current class.
        /// </returns>
        public static bool SameTypeAs(IPersistableType instance)
        {
            if (instance == null)
            {
                return false;
            }

            return instance.__T == TagColor.PersistedType;
        }

        /// <summary>
        /// Creates a persistence key.
        /// </summary>
        /// <param name="args">Arguments identifying the item.</param>
        public static string CreateKey(params object[] args)
        {
            return RoundtripDataHelper.GetPersistedKey("TagColor", args);
        }

        /// <summary>
        /// Compares two instances for equality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are equal.</returns>
        public static bool operator ==(TagColor value1, TagColor value2)
        {
            var value1IsNull = object.ReferenceEquals(value1, null);
            var value2IsNull = object.ReferenceEquals(value2, null);

            if (value1IsNull == value2IsNull)
            {
                if (value1IsNull)
                {
                    return true;
                }
                else
                {
                    return value1.Equals(value2);
                }
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Compares two instances for inequality by performing a deep comparision of all object
        /// properties including any hidden properties.  Note that you may pass <c>null</c>.
        /// </summary>
        /// <param name="value1">The first value or <c>null</c>.</param>
        /// <param name="value2">The second value or <c>null</c>.</param>
        /// <returns><c>true</c> if the values are not equal.</returns>
        public static bool operator !=(TagColor value1, TagColor value2)
        {
            return !(value1 == value2);
        }

        //---------------------------------------------------------------------
        // Instance members:

        private string cachedT;

        /// <summary>
        /// <b>INTERNAL USE ONLY:</b> This is the <see cref="JObject"/> is used to back
        /// all serialized round-trip.  This was made public for advanced unit testing but
        /// its use should generally be avoided for other purposes.  Use <see cref="ToJObject()"/>.
        /// instead.  "__O" is short for "object".
        /// </summary>
        [JsonIgnore]
        public JObject __O { get; set; }

        /// <summary>
        /// Constructs an uninitialized instance.
        /// </summary>
        public TagColor()
        {
            __T = PersistedType;
            __O = new JObject();
        }

        /// <summary>
        /// Protected constructor used internally to initialize derived classes.
        /// </summary>
        /// <param name="jObject">The backing <see cref="JObject"/>.</param>
        protected TagColor(JObject jObject)
        {
            __T = PersistedType;
            __O = jObject;
        }

        [JsonProperty(PropertyName = "Id", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public string Id { get; set; }

        [JsonProperty(PropertyName = "Name", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        public string Name { get; set; }

        /// <summary>
        /// Loads the entity properties from the backing <see cref="JObject"/>
        /// or from the optional <see cref="JObject"/> passed.
        /// </summary>
        /// <param name="source">The optional source <see cref="JObject"/>.</param>
        /// <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        public virtual void __Load(JObject source = null, bool isDerived = false)
        {
            JProperty property;

            if (source != null)
            {
                this.__O = source;
            }

            if (this.__O == null)
            {
                this.__O = new JObject();
            }

            property = this.__O.Property("Id");
            if (property != null)
            {
                this.Id = (string)property.Value;
            }

            property = this.__O.Property("Name");
            if (property != null)
            {
                this.Name = (string)property.Value;
            }

            if (!isDerived)
            {
                property = this.__O.Property("T$$");
                if (property == null)
                {
                    throw new ArgumentNullException("[TagColor.T$$] property is required when deserializing.");
                }
                else
                {
                    this.__T = (string)property.Value;
                }
            }
        }

        /// <summary>
        /// Persists the properties from this instance to the backing <see cref="JObject"/>.
        /// </summary>
        /// <returns>The backing <see cref="JObject"/>.</returns>
        public virtual JObject __Save()
        {
            JProperty property;

            if (__O == null)
            {
                __O = new JObject();
            }

            this.__O["Id"] = this.Id;
            this.__O["Name"] = this.Name;
            this.__O["T$$"] = PersistedType;

            return this.__O;
        }

        /// <summary>
        /// Renders the instance as JSON text.
        /// </summary>
        /// <returns>The serialized JSON string.</returns>
        public override string ToString()
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, Formatting.None);
        }

        /// <summary>
        /// Renders the instance as JSON text, optionally formatting the output.
        /// </summary>
        /// <param name="indented">Optionally pass <c>true</c> to format the output.</param>
        /// <returns>The serialized JSON string.</returns>
        public string ToString(bool indented)
        {
            __Save();
            return RoundtripDataHelper.Serialize(__O, indented ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Renders the instance as a new <see cref="JObject"/>.
        /// </summary>
        /// <returns>The rendered <see cref="JObject"/>.</returns>
        public JObject ToJObject()
        {
            __Save();
            return RoundtripDataHelper.DeepClone(__O);
        }

        /// <summary>
        /// Renders the instance as UTF-8 encoded JSON.
        /// </summary>
        /// <returns>The serialized JSON bytes.</returns>
        public virtual byte[] ToBytes()
        {
            __Save();
            return Encoding.UTF8.GetBytes(RoundtripDataHelper.Serialize(__O, Formatting.None));
        }

        /// <summary>
        /// Returns a deep clone of the instance.
        /// </summary>
        /// <returns>The cloned instance.</returns>
        public TagColor DeepClone()
        {
            __Save();
            return CreateFrom(RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Used to convert a base data model class into a derived class.
        /// </summary>
        /// <typeparam name="T">The desired derived type.</typeparam>
        /// <param name="noClone">
        /// By default, this method will create a deep clone of the underlying <see cref="JObject"/>
        /// and use this new instance when constructing the new object.  This is the safest
        /// approach but will cause a performance hit.  You can pass <paramref name="noClone"/><c>=true</c>
        /// to reuse the existing <see cref="JObject"/> for the new instance if you're sure that the
        /// original instance will no longer be accessed.
        /// </param>
        /// <returns>The converted instance of type <typeparamref name="T"/>.</returns>
        public T ToDerived<T>(bool noClone = false)
           where T : TagColor, IRoundtripData
        {
            __Save();
            return RoundtripDataFactory.CreateFrom<T>(noClone ? __O : RoundtripDataHelper.DeepClone(__O));
        }

        /// <summary>
        /// Determines whether the current instance equals another object.
        /// </summary>
        /// <param name="obj">The other object instance or <c>null</c>.</param>
        /// <returns><c>true</c> if the object reference equals the current instance.</returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = obj as TagColor;

            if (object.ReferenceEquals(other, null))
            {
                return false;
            }

            this.__Save();
            other.__Save();
            return JObject.DeepEquals(this.__O, other.__O);
        }

        /// <summary>
        /// Calculates the hash code for the instance.
        /// <note>
        /// At least one of the class properties must be tagged with a <b>[HashSource]</b>
        /// for this to work.
        /// </note>
        /// </summary>
        /// <returns>The calculated hash code.</returns>
        /// <exception cref="InvalidOperationException">Thrown when no class properties are tagged with a <c>[HashSourceAttribute]</c>.</exception>
        public override int GetHashCode()
        {
            throw new InvalidOperationException(RoundtripDataHelper.NoHashPropertiesError);
        }

        /// <summary>
        /// Identifies the persisted object type.  "__T" is short for "type".  This is persisted as "T$$".
        /// </summary>
        [JsonProperty(PropertyName = "T$$", DefaultValueHandling = DefaultValueHandling.Include, Required = Required.Default, Order = 0)]
        [DefaultValue(null)]
        public string __T
        {
            get
            {
                 if (cachedT != null)
                 {
                     return cachedT;
                 }

                 cachedT = (string)__O["T$$"];

                 if (cachedT != null)
                 {
                     return cachedT;
                 }

                 return PersistedType;
            }

            set => cachedT = value;
        }

        /// <summary>
        /// Returns the object's persistence key.
        /// </summary>
        public string GetKey()
        {
            if (Id == null)
            {
                throw new NotSupportedException("Persistence key property [Id] cannot be NULL.");
            }

            return RoundtripDataHelper.GetPersistedKey(PersistedType, Id);
        }

        /// <summary>
        /// Writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        public virtual void WriteJsonTo(Stream stream)
        {
            __Save();

            using (var writer = new JsonTextWriter(new StreamWriter(stream)))
            {
                __O.WriteTo(writer);
            }
        }

        /// <summary>
        /// Asynchronously writes the instance as JSON to a <see cref="Stream"/>.
        /// </summary>
        /// <returns>The tracking <see cref="Task"/>.</returns>
        public virtual async Task WriteJsonToAsync(Stream stream)
        {
            await SyncContext.ClearAsync;
            __Save();

            await stream.WriteAsync(Encoding.UTF8.GetBytes(__O.ToString()));
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.global::Test.Neon.Models.Definitions.TestAspNetFixtureController

    [GeneratedClient("/TestAspNetFixture")]
    public partial class TestAspNetFixtureClient : IDisposable, IGeneratedServiceClient
    {
        /// <inheritdoc/>
        public string GeneratorVersion => "2.14.0:1";

        private JsonClient       client;
        private bool             isDisposed = false;
        private IRetryPolicy     retryPolicy;

        /// <summary>
        /// Used to construct a client for most situations, optionally specifying a custom <see cref="HttpMessageHandler"/> and/or
        /// <see cref="IRetryPolicy"/>.
        /// </summary>
        /// <param name="handler">An optional message handler.  This defaults to a reasonable handler with compression enabled.</param>
        /// <param name="disposeHandler">Indicates whether the handler passed will be disposed automatically (defaults to <c>false</c>).</param>
        /// <param name="retryPolicy">Optionally specifies a default retry policy (defaults to <see cref="NoRetryPolicy"/>).</param>
        public TestAspNetFixtureClient(HttpMessageHandler handler = null, bool disposeHandler = false, IRetryPolicy retryPolicy = null)
        {
            this.client = new JsonClient(handler, disposeHandler);
            this.retryPolicy = retryPolicy ?? NoRetryPolicy.Instance;
        }

        /// <summary>
        /// Used in special situations (like ASP.NET Blazor) where a special <see cref="HttpClient"/> needs
        /// to be created and provided.
        /// </summary>
        /// <param name="httpClient">The special <see cref="HttpClient"/> instance to be wrapped.</param>
        /// <param name="retryPolicy">Optionally specifies a default retry policy (defaults to <see cref="NoRetryPolicy"/>).</param>
        public TestAspNetFixtureClient(HttpClient httpClient, IRetryPolicy retryPolicy = null)
        {
            Covenant.Requires<ArgumentNullException>(httpClient != null, nameof(httpClient));

            this.client = new JsonClient(httpClient);
            this.retryPolicy = retryPolicy ?? NoRetryPolicy.Instance;
        }

        /// <summary>
        /// Finalizer.
        /// </summary>
        ~TestAspNetFixtureClient()
        {
             Dispose(false);
        }

        /// <inheritdoc/>
        public void Dispose()
        {
        }

        /// <summary>
        /// Releases any important resources associated with the instance.
        /// </summary>
        /// <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        protected void Dispose(bool disposing)
        {
            if (isDisposed)
            {
                return;
            }

            client.Dispose();

            if (disposing)
            {
                GC.SuppressFinalize(this);
            }

            isDisposed = true;
        }

        /// <summary>
        /// Returns the underlying <see cref="JsonClient"/>.
        /// </summary>
        public JsonClient JsonClient => client;

        /// <summary>
        /// Returns the underlying <see cref="HttpClient"/>.
        /// </summary>
        public HttpClient HttpClient => client.HttpClient;

        /// <summary>
        /// Accesses the underlying <see cref="HttpClient.Timeout"/>.
        /// </summary>
        public TimeSpan Timeout
        {
            get => client.Timeout;
            set => client.Timeout = value;
        }

        /// <summary>
        /// Accesses the underlying <see cref="HttpClient.BaseAddress"/>.
        /// </summary>
        public Uri BaseAddress
        {
            get => client.BaseAddress;
            set => client.BaseAddress = value;
        }

        /// <summary>
        /// Returns the underlying <see cref="HttpClient.DefaultRequestHeaders"/>.
        /// </summary>
        public HttpRequestHeaders DefaultRequestHeaders => client.DefaultRequestHeaders;

        /// <summary>
        /// Returns the underlying <see cref="HttpClient.DefaultRequestHeaders"/>.
        /// </summary>
        public IRetryPolicy RetryPolicy
        {
            get => this.retryPolicy;
            set => this.retryPolicy = value ?? global::Neon.Retry.NoRetryPolicy.Instance;
        }

        [GeneratedMethod(DefinedAs = "GetString", Returns = typeof(string), RouteTemplate = "GetString", HttpMethod = "GET")]
        public async Task<string> GetStringAsync([GeneratedParam(PassAs.Query, Name = "input")] string input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetString", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeGetStringAsync([GeneratedParam(PassAs.Query, Name = "input")] string input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetString", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetBool", Returns = typeof(bool), RouteTemplate = "GetBool", HttpMethod = "GET")]
        public async Task<bool> GetBoolAsync([GeneratedParam(PassAs.Query, Name = "input")] bool input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetBool", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<bool>();
        }

        public async Task<JsonResponse> UnsafeGetBoolAsync([GeneratedParam(PassAs.Query, Name = "input")] bool input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetBool", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetInt", Returns = typeof(int), RouteTemplate = "GetInt", HttpMethod = "GET")]
        public async Task<int> GetIntAsync([GeneratedParam(PassAs.Query, Name = "input")] int input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetInt", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<int>();
        }

        public async Task<JsonResponse> UnsafeGetIntAsync([GeneratedParam(PassAs.Query, Name = "input")] int input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetInt", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetDouble", Returns = typeof(double), RouteTemplate = "GetDouble", HttpMethod = "GET")]
        public async Task<double> GetDoubleAsync([GeneratedParam(PassAs.Query, Name = "input")] double input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetDouble", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<double>();
        }

        public async Task<JsonResponse> UnsafeGetDoubleAsync([GeneratedParam(PassAs.Query, Name = "input")] double input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetDouble", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetTimeSpan", Returns = typeof(global::System.TimeSpan), RouteTemplate = "GetTimeSpan", HttpMethod = "GET")]
        public async Task<global::System.TimeSpan> GetTimeSpanAsync([GeneratedParam(PassAs.Query, Name = "timespan")] global::System.TimeSpan timespan, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "timespan", timespan },
            };

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetTimeSpan", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<global::System.TimeSpan>();
        }

        public async Task<JsonResponse> UnsafeGetTimeSpanAsync([GeneratedParam(PassAs.Query, Name = "timespan")] global::System.TimeSpan timespan, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "timespan", timespan },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetTimeSpan", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetVersion", Returns = typeof(global::System.Version), RouteTemplate = "GetVersion", HttpMethod = "GET")]
        public async Task<global::System.Version> GetVersionAsync([GeneratedParam(PassAs.Query, Name = "version")] global::System.Version version, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "version", version },
            };

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetVersion", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<global::System.Version>();
        }

        public async Task<JsonResponse> UnsafeGetVersionAsync([GeneratedParam(PassAs.Query, Name = "version")] global::System.Version version, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "version", version },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetVersion", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "CreatePerson", Returns = typeof(Person), RouteTemplate = "person/{id}/{name}/{age}", HttpMethod = "GET")]
        public async Task<Person> CreatePersonAsync([GeneratedParam(PassAs.Query, Name = "id")] int id, [GeneratedParam(PassAs.Query, Name = "name")] string name, [GeneratedParam(PassAs.Query, Name = "age")] int age, [GeneratedParam(PassAs.Query, Name = "gender")] Gender gender, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "gender", gender },
            };

            return Person.CreateFrom(await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/person/{Uri.EscapeUriString(id.ToString())}/{Uri.EscapeUriString(name)}/{Uri.EscapeUriString(age.ToString())}", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity));
        }

        public async Task<JsonResponse> UnsafeCreatePersonAsync([GeneratedParam(PassAs.Query, Name = "id")] int id, [GeneratedParam(PassAs.Query, Name = "name")] string name, [GeneratedParam(PassAs.Query, Name = "age")] int age, [GeneratedParam(PassAs.Query, Name = "gender")] Gender gender, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "gender", gender },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/person/{Uri.EscapeUriString(id.ToString())}/{Uri.EscapeUriString(name)}/{Uri.EscapeUriString(age.ToString())}", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "CreateNonPersisablePerson", Returns = typeof(NonPersistablePerson), RouteTemplate = "nonpersistable-person/{id}/{name}/{age}", HttpMethod = "GET")]
        public async Task<NonPersistablePerson> CreateNonPersisablePersonAsync([GeneratedParam(PassAs.Query, Name = "id")] int id, [GeneratedParam(PassAs.Query, Name = "name")] string name, [GeneratedParam(PassAs.Query, Name = "age")] int age, [GeneratedParam(PassAs.Query, Name = "gender")] Gender gender, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "gender", gender },
            };

            return NonPersistablePerson.CreateFrom(await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/nonpersistable-person/{Uri.EscapeUriString(id.ToString())}/{Uri.EscapeUriString(name)}/{Uri.EscapeUriString(age.ToString())}", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity));
        }

        public async Task<JsonResponse> UnsafeCreateNonPersisablePersonAsync([GeneratedParam(PassAs.Query, Name = "id")] int id, [GeneratedParam(PassAs.Query, Name = "name")] string name, [GeneratedParam(PassAs.Query, Name = "age")] int age, [GeneratedParam(PassAs.Query, Name = "gender")] Gender gender, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "gender", gender },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/nonpersistable-person/{Uri.EscapeUriString(id.ToString())}/{Uri.EscapeUriString(name)}/{Uri.EscapeUriString(age.ToString())}", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "IncrementAge", Returns = typeof(Person), RouteTemplate = "IncrementAge", HttpMethod = "PUT")]
        public async Task<Person> IncrementAgeAsync([GeneratedParam(PassAs.Body)] Person person, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return Person.CreateFrom(await client.PutAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/IncrementAge", document: RoundtripDataHelper.Serialize(person), cancellationToken: _cancellationToken, logActivity: _logActivity));
        }

        public async Task<JsonResponse> UnsafeIncrementAgeAsync([GeneratedParam(PassAs.Body)] Person person, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.PutUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/IncrementAge", document: RoundtripDataHelper.Serialize(person), cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "DefaultInt", Returns = typeof(int), RouteTemplate = "DefaultInt", HttpMethod = "GET")]
        public async Task<int> DefaultIntAsync([GeneratedParam(PassAs.Query, Name = "value")] int value = 10, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != 10)
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/DefaultInt", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<int>();
        }

        public async Task<JsonResponse> UnsafeDefaultIntAsync([GeneratedParam(PassAs.Query, Name = "value")] int value = 10, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != 10)
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/DefaultInt", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "DefaultBool", Returns = typeof(bool), RouteTemplate = "DefaultBool", HttpMethod = "GET")]
        public async Task<bool> DefaultBoolAsync([GeneratedParam(PassAs.Query, Name = "value")] bool value = true, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != true)
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/DefaultBool", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<bool>();
        }

        public async Task<JsonResponse> UnsafeDefaultBoolAsync([GeneratedParam(PassAs.Query, Name = "value")] bool value = true, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != true)
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/DefaultBool", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "DefaultDouble", Returns = typeof(double), RouteTemplate = "DefaultDouble", HttpMethod = "GET")]
        public async Task<double> DefaultDoubleAsync([GeneratedParam(PassAs.Query, Name = "value")] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != 1.234)
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/DefaultDouble", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<double>();
        }

        public async Task<JsonResponse> UnsafeDefaultDoubleAsync([GeneratedParam(PassAs.Query, Name = "value")] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != 1.234)
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/DefaultDouble", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "DefaultString", Returns = typeof(string), RouteTemplate = "DefaultString", HttpMethod = "GET")]
        public async Task<string> DefaultStringAsync([GeneratedParam(PassAs.Query, Name = "value")] string value = "test", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != "test")
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/DefaultString", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeDefaultStringAsync([GeneratedParam(PassAs.Query, Name = "value")] string value = "test", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != "test")
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/DefaultString", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "DefaultEnum", Returns = typeof(MyEnum), RouteTemplate = "DefaultEnum", HttpMethod = "GET")]
        public async Task<MyEnum> DefaultEnumAsync([GeneratedParam(PassAs.Query, Name = "value")] MyEnum value = MyEnum.Three, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != MyEnum.Three)
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/DefaultEnum", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<MyEnum>();
        }

        public async Task<JsonResponse> UnsafeDefaultEnumAsync([GeneratedParam(PassAs.Query, Name = "value")] MyEnum value = MyEnum.Three, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != MyEnum.Three)
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/DefaultEnum", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalStringViaHeader_Null", Returns = typeof(string), RouteTemplate = "GetOptionalStringViaHeader_Null", HttpMethod = "GET")]
        public async Task<string> GetOptionalStringViaHeader_NullAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] string value = null, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != null)
            {
                _headers.Add("X-Test", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalStringViaHeader_Null", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalStringViaHeader_NullAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] string value = null, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != null)
            {
                _headers.Add("X-Test", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalStringViaHeader_Null", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalStringViaHeader_Value", Returns = typeof(string), RouteTemplate = "GetOptionalStringViaHeader_Value", HttpMethod = "GET")]
        public async Task<string> GetOptionalStringViaHeader_ValueAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] string value = "Hello World!", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != "Hello World!")
            {
                _headers.Add("X-Test", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalStringViaHeader_Value", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalStringViaHeader_ValueAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] string value = "Hello World!", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != "Hello World!")
            {
                _headers.Add("X-Test", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalStringViaHeader_Value", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalStringViaQuery_Null", Returns = typeof(string), RouteTemplate = "GetOptionalStringViaQuery_Null", HttpMethod = "GET")]
        public async Task<string> GetOptionalStringViaQuery_NullAsync([GeneratedParam(PassAs.Query, Name = "value")] string value = null, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != null)
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalStringViaQuery_Null", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalStringViaQuery_NullAsync([GeneratedParam(PassAs.Query, Name = "value")] string value = null, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != null)
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalStringViaQuery_Null", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalStringViaQuery_Value", Returns = typeof(string), RouteTemplate = "GetOptionalStringViaQuery_Value", HttpMethod = "GET")]
        public async Task<string> GetOptionalStringViaQuery_ValueAsync([GeneratedParam(PassAs.Query, Name = "value")] string value = "Hello World!", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != "Hello World!")
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalStringViaQuery_Value", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalStringViaQuery_ValueAsync([GeneratedParam(PassAs.Query, Name = "value")] string value = "Hello World!", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != "Hello World!")
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalStringViaQuery_Value", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalEnumViaHeader", Returns = typeof(MyEnum), RouteTemplate = "GetOptionalEnumViaHeader", HttpMethod = "GET")]
        public async Task<MyEnum> GetOptionalEnumViaHeaderAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] MyEnum value = MyEnum.Three, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != MyEnum.Three)
            {
                _headers.Add("X-Test", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalEnumViaHeader", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<MyEnum>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalEnumViaHeaderAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] MyEnum value = MyEnum.Three, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != MyEnum.Three)
            {
                _headers.Add("X-Test", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalEnumViaHeader", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalEnumViaQuery", Returns = typeof(MyEnum), RouteTemplate = "GetOptionalEnumViaQuery", HttpMethod = "GET")]
        public async Task<MyEnum> GetOptionalEnumViaQueryAsync([GeneratedParam(PassAs.Query, Name = "value")] MyEnum value = MyEnum.Three, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != MyEnum.Three)
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalEnumViaQuery", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<MyEnum>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalEnumViaQueryAsync([GeneratedParam(PassAs.Query, Name = "value")] MyEnum value = MyEnum.Three, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != MyEnum.Three)
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalEnumViaQuery", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalEnumViaBody", Returns = typeof(MyEnum), RouteTemplate = "GetOptionalEnumViaBody", HttpMethod = "PUT")]
        public async Task<MyEnum> GetOptionalEnumViaBodyAsync([GeneratedParam(PassAs.Body)] MyEnum value = MyEnum.Three, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return (await client.PutAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalEnumViaBody", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity)).As<MyEnum>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalEnumViaBodyAsync([GeneratedParam(PassAs.Body)] MyEnum value = MyEnum.Three, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.PutUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalEnumViaBody", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalDoubleViaHeader", Returns = typeof(double), RouteTemplate = "GetOptionalDoubleViaHeader", HttpMethod = "GET")]
        public async Task<double> GetOptionalDoubleViaHeaderAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != 1.234)
            {
                _headers.Add("X-Test", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalDoubleViaHeader", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<double>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalDoubleViaHeaderAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != 1.234)
            {
                _headers.Add("X-Test", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalDoubleViaHeader", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalDoubleViaQuery", Returns = typeof(double), RouteTemplate = "GetOptionalDoubleViaQuery", HttpMethod = "GET")]
        public async Task<double> GetOptionalDoubleViaQueryAsync([GeneratedParam(PassAs.Query, Name = "value")] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != 1.234)
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalDoubleViaQuery", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<double>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalDoubleViaQueryAsync([GeneratedParam(PassAs.Query, Name = "value")] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != 1.234)
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalDoubleViaQuery", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalDoubleViaBody", Returns = typeof(double), RouteTemplate = "GetOptionalDoubleViaBody", HttpMethod = "PUT")]
        public async Task<double> GetOptionalDoubleViaBodyAsync([GeneratedParam(PassAs.Body)] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return (await client.PutAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalDoubleViaBody", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity)).As<double>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalDoubleViaBodyAsync([GeneratedParam(PassAs.Body)] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.PutUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalDoubleViaBody", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalStringViaBody", Returns = typeof(string), RouteTemplate = "GetOptionalStringViaBody", HttpMethod = "PUT")]
        public async Task<string> GetOptionalStringViaBodyAsync([GeneratedParam(PassAs.Body)] string value = "Hello World!", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return (await client.PutAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalStringViaBody", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalStringViaBodyAsync([GeneratedParam(PassAs.Body)] string value = "Hello World!", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.PutUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetOptionalStringViaBody", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetStringList", Returns = typeof(global::System.Collections.Generic.List<string>), RouteTemplate = "GetStringList", HttpMethod = "PUT")]
        public async Task<global::System.Collections.Generic.List<string>> GetStringListAsync([GeneratedParam(PassAs.Body)] global::System.Collections.Generic.List<string> value, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return (await client.PutAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetStringList", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity)).As<global::System.Collections.Generic.List<string>>();
        }

        public async Task<JsonResponse> UnsafeGetStringListAsync([GeneratedParam(PassAs.Body)] global::System.Collections.Generic.List<string> value, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.PutUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetStringList", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetPersonList", Returns = typeof(global::System.Collections.Generic.List<Person>), RouteTemplate = "GetPersonList", HttpMethod = "PUT")]
        public async Task<global::System.Collections.Generic.List<Person>> GetPersonListAsync([GeneratedParam(PassAs.Body)] global::System.Collections.Generic.List<Person> value, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return (await client.PutAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetPersonList", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity)).As<global::System.Collections.Generic.List<Person>>();
        }

        public async Task<JsonResponse> UnsafeGetPersonListAsync([GeneratedParam(PassAs.Body)] global::System.Collections.Generic.List<Person> value, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.PutUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetPersonList", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetPersonArray", Returns = typeof(Person[]), RouteTemplate = "GetPersonArray", HttpMethod = "PUT")]
        public async Task<Person[]> GetPersonArrayAsync([GeneratedParam(PassAs.Body)] Person[] value, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return (await client.PutAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetPersonArray", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity)).As<Person[]>();
        }

        public async Task<JsonResponse> UnsafeGetPersonArrayAsync([GeneratedParam(PassAs.Body)] Person[] value, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.PutUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestAspNetFixture/GetPersonArray", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity);
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.global::Test.Neon.Models.Definitions.TestUxAspNetFixtureController

    [GeneratedClient("/TestUxAspNetFixture")]
    public partial class TestUxAspNetFixtureClient : IDisposable, IGeneratedServiceClient
    {
        /// <inheritdoc/>
        public string GeneratorVersion => "2.14.0:1";

        private JsonClient       client;
        private bool             isDisposed = false;
        private IRetryPolicy     retryPolicy;

        /// <summary>
        /// Used to construct a client for most situations, optionally specifying a custom <see cref="HttpMessageHandler"/> and/or
        /// <see cref="IRetryPolicy"/>.
        /// </summary>
        /// <param name="handler">An optional message handler.  This defaults to a reasonable handler with compression enabled.</param>
        /// <param name="disposeHandler">Indicates whether the handler passed will be disposed automatically (defaults to <c>false</c>).</param>
        /// <param name="retryPolicy">Optionally specifies a default retry policy (defaults to <see cref="NoRetryPolicy"/>).</param>
        public TestUxAspNetFixtureClient(HttpMessageHandler handler = null, bool disposeHandler = false, IRetryPolicy retryPolicy = null)
        {
            this.client = new JsonClient(handler, disposeHandler);
            this.retryPolicy = retryPolicy ?? NoRetryPolicy.Instance;
        }

        /// <summary>
        /// Used in special situations (like ASP.NET Blazor) where a special <see cref="HttpClient"/> needs
        /// to be created and provided.
        /// </summary>
        /// <param name="httpClient">The special <see cref="HttpClient"/> instance to be wrapped.</param>
        /// <param name="retryPolicy">Optionally specifies a default retry policy (defaults to <see cref="NoRetryPolicy"/>).</param>
        public TestUxAspNetFixtureClient(HttpClient httpClient, IRetryPolicy retryPolicy = null)
        {
            Covenant.Requires<ArgumentNullException>(httpClient != null, nameof(httpClient));

            this.client = new JsonClient(httpClient);
            this.retryPolicy = retryPolicy ?? NoRetryPolicy.Instance;
        }

        /// <summary>
        /// Finalizer.
        /// </summary>
        ~TestUxAspNetFixtureClient()
        {
             Dispose(false);
        }

        /// <inheritdoc/>
        public void Dispose()
        {
        }

        /// <summary>
        /// Releases any important resources associated with the instance.
        /// </summary>
        /// <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        protected void Dispose(bool disposing)
        {
            if (isDisposed)
            {
                return;
            }

            client.Dispose();

            if (disposing)
            {
                GC.SuppressFinalize(this);
            }

            isDisposed = true;
        }

        /// <summary>
        /// Returns the underlying <see cref="JsonClient"/>.
        /// </summary>
        public JsonClient JsonClient => client;

        /// <summary>
        /// Returns the underlying <see cref="HttpClient"/>.
        /// </summary>
        public HttpClient HttpClient => client.HttpClient;

        /// <summary>
        /// Accesses the underlying <see cref="HttpClient.Timeout"/>.
        /// </summary>
        public TimeSpan Timeout
        {
            get => client.Timeout;
            set => client.Timeout = value;
        }

        /// <summary>
        /// Accesses the underlying <see cref="HttpClient.BaseAddress"/>.
        /// </summary>
        public Uri BaseAddress
        {
            get => client.BaseAddress;
            set => client.BaseAddress = value;
        }

        /// <summary>
        /// Returns the underlying <see cref="HttpClient.DefaultRequestHeaders"/>.
        /// </summary>
        public HttpRequestHeaders DefaultRequestHeaders => client.DefaultRequestHeaders;

        /// <summary>
        /// Returns the underlying <see cref="HttpClient.DefaultRequestHeaders"/>.
        /// </summary>
        public IRetryPolicy RetryPolicy
        {
            get => this.retryPolicy;
            set => this.retryPolicy = value ?? global::Neon.Retry.NoRetryPolicy.Instance;
        }

        [GeneratedMethod(DefinedAs = "GetString", Returns = typeof(string), RouteTemplate = "GetString", HttpMethod = "GET")]
        public async Task<string> GetStringAsync([GeneratedParam(PassAs.Query, Name = "input")] string input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetString", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeGetStringAsync([GeneratedParam(PassAs.Query, Name = "input")] string input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetString", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetBool", Returns = typeof(bool), RouteTemplate = "GetBool", HttpMethod = "GET")]
        public async Task<bool> GetBoolAsync([GeneratedParam(PassAs.Query, Name = "input")] bool input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetBool", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<bool>();
        }

        public async Task<JsonResponse> UnsafeGetBoolAsync([GeneratedParam(PassAs.Query, Name = "input")] bool input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetBool", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetInt", Returns = typeof(int), RouteTemplate = "GetInt", HttpMethod = "GET")]
        public async Task<int> GetIntAsync([GeneratedParam(PassAs.Query, Name = "input")] int input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetInt", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<int>();
        }

        public async Task<JsonResponse> UnsafeGetIntAsync([GeneratedParam(PassAs.Query, Name = "input")] int input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetInt", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetDouble", Returns = typeof(double), RouteTemplate = "GetDouble", HttpMethod = "GET")]
        public async Task<double> GetDoubleAsync([GeneratedParam(PassAs.Query, Name = "input")] double input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetDouble", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<double>();
        }

        public async Task<JsonResponse> UnsafeGetDoubleAsync([GeneratedParam(PassAs.Query, Name = "input")] double input, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "input", input },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetDouble", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetTimeSpan", Returns = typeof(global::System.TimeSpan), RouteTemplate = "GetTimeSpan", HttpMethod = "GET")]
        public async Task<global::System.TimeSpan> GetTimeSpanAsync([GeneratedParam(PassAs.Query, Name = "timespan")] global::System.TimeSpan timespan, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "timespan", timespan },
            };

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetTimeSpan", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<global::System.TimeSpan>();
        }

        public async Task<JsonResponse> UnsafeGetTimeSpanAsync([GeneratedParam(PassAs.Query, Name = "timespan")] global::System.TimeSpan timespan, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "timespan", timespan },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetTimeSpan", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetVersion", Returns = typeof(global::System.Version), RouteTemplate = "GetVersion", HttpMethod = "GET")]
        public async Task<global::System.Version> GetVersionAsync([GeneratedParam(PassAs.Query, Name = "version")] global::System.Version version, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "version", version },
            };

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetVersion", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<global::System.Version>();
        }

        public async Task<JsonResponse> UnsafeGetVersionAsync([GeneratedParam(PassAs.Query, Name = "version")] global::System.Version version, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "version", version },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetVersion", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "CreatePerson", Returns = typeof(Person), RouteTemplate = "person/{id}/{name}/{age}", HttpMethod = "GET")]
        public async Task<Person> CreatePersonAsync([GeneratedParam(PassAs.Query, Name = "id")] int id, [GeneratedParam(PassAs.Query, Name = "name")] string name, [GeneratedParam(PassAs.Query, Name = "age")] int age, [GeneratedParam(PassAs.Query, Name = "gender")] Gender gender, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "gender", gender },
            };

            return Person.CreateFrom(await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/person/{Uri.EscapeUriString(id.ToString())}/{Uri.EscapeUriString(name)}/{Uri.EscapeUriString(age.ToString())}", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity));
        }

        public async Task<JsonResponse> UnsafeCreatePersonAsync([GeneratedParam(PassAs.Query, Name = "id")] int id, [GeneratedParam(PassAs.Query, Name = "name")] string name, [GeneratedParam(PassAs.Query, Name = "age")] int age, [GeneratedParam(PassAs.Query, Name = "gender")] Gender gender, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary()
            {
                { "gender", gender },
            };

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/person/{Uri.EscapeUriString(id.ToString())}/{Uri.EscapeUriString(name)}/{Uri.EscapeUriString(age.ToString())}", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "IncrementAge", Returns = typeof(Person), RouteTemplate = "IncrementAge", HttpMethod = "PUT")]
        public async Task<Person> IncrementAgeAsync([GeneratedParam(PassAs.Body)] Person person, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return Person.CreateFrom(await client.PutAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/IncrementAge", document: RoundtripDataHelper.Serialize(person), cancellationToken: _cancellationToken, logActivity: _logActivity));
        }

        public async Task<JsonResponse> UnsafeIncrementAgeAsync([GeneratedParam(PassAs.Body)] Person person, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.PutUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/IncrementAge", document: RoundtripDataHelper.Serialize(person), cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "DefaultInt", Returns = typeof(int), RouteTemplate = "DefaultInt", HttpMethod = "GET")]
        public async Task<int> DefaultIntAsync([GeneratedParam(PassAs.Query, Name = "value")] int value = 10, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != 10)
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/DefaultInt", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<int>();
        }

        public async Task<JsonResponse> UnsafeDefaultIntAsync([GeneratedParam(PassAs.Query, Name = "value")] int value = 10, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != 10)
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/DefaultInt", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "DefaultBool", Returns = typeof(bool), RouteTemplate = "DefaultBool", HttpMethod = "GET")]
        public async Task<bool> DefaultBoolAsync([GeneratedParam(PassAs.Query, Name = "value")] bool value = true, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != true)
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/DefaultBool", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<bool>();
        }

        public async Task<JsonResponse> UnsafeDefaultBoolAsync([GeneratedParam(PassAs.Query, Name = "value")] bool value = true, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != true)
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/DefaultBool", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "DefaultDouble", Returns = typeof(double), RouteTemplate = "DefaultDouble", HttpMethod = "GET")]
        public async Task<double> DefaultDoubleAsync([GeneratedParam(PassAs.Query, Name = "value")] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != 1.234)
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/DefaultDouble", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<double>();
        }

        public async Task<JsonResponse> UnsafeDefaultDoubleAsync([GeneratedParam(PassAs.Query, Name = "value")] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != 1.234)
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/DefaultDouble", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "DefaultString", Returns = typeof(string), RouteTemplate = "DefaultString", HttpMethod = "GET")]
        public async Task<string> DefaultStringAsync([GeneratedParam(PassAs.Query, Name = "value")] string value = "test", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != "test")
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/DefaultString", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeDefaultStringAsync([GeneratedParam(PassAs.Query, Name = "value")] string value = "test", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != "test")
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/DefaultString", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "DefaultEnum", Returns = typeof(MyEnum), RouteTemplate = "DefaultEnum", HttpMethod = "GET")]
        public async Task<MyEnum> DefaultEnumAsync([GeneratedParam(PassAs.Query, Name = "value")] MyEnum value = MyEnum.Three, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != MyEnum.Three)
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/DefaultEnum", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<MyEnum>();
        }

        public async Task<JsonResponse> UnsafeDefaultEnumAsync([GeneratedParam(PassAs.Query, Name = "value")] MyEnum value = MyEnum.Three, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != MyEnum.Three)
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/DefaultEnum", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalStringViaHeader_Null", Returns = typeof(string), RouteTemplate = "GetOptionalStringViaHeader_Null", HttpMethod = "GET")]
        public async Task<string> GetOptionalStringViaHeader_NullAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] string value = null, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != null)
            {
                _headers.Add("X-Test", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalStringViaHeader_Null", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalStringViaHeader_NullAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] string value = null, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != null)
            {
                _headers.Add("X-Test", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalStringViaHeader_Null", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalStringViaHeader_Value", Returns = typeof(string), RouteTemplate = "GetOptionalStringViaHeader_Value", HttpMethod = "GET")]
        public async Task<string> GetOptionalStringViaHeader_ValueAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] string value = "Hello World!", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != "Hello World!")
            {
                _headers.Add("X-Test", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalStringViaHeader_Value", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalStringViaHeader_ValueAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] string value = "Hello World!", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != "Hello World!")
            {
                _headers.Add("X-Test", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalStringViaHeader_Value", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalStringViaQuery_Null", Returns = typeof(string), RouteTemplate = "GetOptionalStringViaQuery_Null", HttpMethod = "GET")]
        public async Task<string> GetOptionalStringViaQuery_NullAsync([GeneratedParam(PassAs.Query, Name = "value")] string value = null, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != null)
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalStringViaQuery_Null", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalStringViaQuery_NullAsync([GeneratedParam(PassAs.Query, Name = "value")] string value = null, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != null)
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalStringViaQuery_Null", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalStringViaQuery_Value", Returns = typeof(string), RouteTemplate = "GetOptionalStringViaQuery_Value", HttpMethod = "GET")]
        public async Task<string> GetOptionalStringViaQuery_ValueAsync([GeneratedParam(PassAs.Query, Name = "value")] string value = "Hello World!", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != "Hello World!")
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalStringViaQuery_Value", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalStringViaQuery_ValueAsync([GeneratedParam(PassAs.Query, Name = "value")] string value = "Hello World!", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != "Hello World!")
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalStringViaQuery_Value", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalEnumViaHeader", Returns = typeof(MyEnum), RouteTemplate = "GetOptionalEnumViaHeader", HttpMethod = "GET")]
        public async Task<MyEnum> GetOptionalEnumViaHeaderAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] MyEnum value = MyEnum.Three, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != MyEnum.Three)
            {
                _headers.Add("X-Test", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalEnumViaHeader", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<MyEnum>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalEnumViaHeaderAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] MyEnum value = MyEnum.Three, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != MyEnum.Three)
            {
                _headers.Add("X-Test", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalEnumViaHeader", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalEnumViaQuery", Returns = typeof(MyEnum), RouteTemplate = "GetOptionalEnumViaQuery", HttpMethod = "GET")]
        public async Task<MyEnum> GetOptionalEnumViaQueryAsync([GeneratedParam(PassAs.Query, Name = "value")] MyEnum value = MyEnum.Three, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != MyEnum.Three)
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalEnumViaQuery", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<MyEnum>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalEnumViaQueryAsync([GeneratedParam(PassAs.Query, Name = "value")] MyEnum value = MyEnum.Three, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != MyEnum.Three)
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalEnumViaQuery", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalDoubleViaHeader", Returns = typeof(double), RouteTemplate = "GetOptionalDoubleViaHeader", HttpMethod = "GET")]
        public async Task<double> GetOptionalDoubleViaHeaderAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != 1.234)
            {
                _headers.Add("X-Test", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalDoubleViaHeader", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<double>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalDoubleViaHeaderAsync([GeneratedParam(PassAs.Header, Name = "X-Test")] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _headers = new ArgDictionary();

            if (value != 1.234)
            {
                _headers.Add("X-Test", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalDoubleViaHeader", headers: _headers, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalDoubleViaQuery", Returns = typeof(double), RouteTemplate = "GetOptionalDoubleViaQuery", HttpMethod = "GET")]
        public async Task<double> GetOptionalDoubleViaQueryAsync([GeneratedParam(PassAs.Query, Name = "value")] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != 1.234)
            {
                _args.Add("value", value);
            }

            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalDoubleViaQuery", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity)).As<double>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalDoubleViaQueryAsync([GeneratedParam(PassAs.Query, Name = "value")] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            var _args = new ArgDictionary();

            if (value != 1.234)
            {
                _args.Add("value", value);
            }

            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalDoubleViaQuery", args: _args, cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalDoubleViaBody", Returns = typeof(double), RouteTemplate = "GetOptionalDoubleViaBody", HttpMethod = "PUT")]
        public async Task<double> GetOptionalDoubleViaBodyAsync([GeneratedParam(PassAs.Body)] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return (await client.PutAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalDoubleViaBody", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity)).As<double>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalDoubleViaBodyAsync([GeneratedParam(PassAs.Body)] double value = 1.234, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.PutUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalDoubleViaBody", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetOptionalStringViaBody", Returns = typeof(string), RouteTemplate = "GetOptionalStringViaBody", HttpMethod = "PUT")]
        public async Task<string> GetOptionalStringViaBodyAsync([GeneratedParam(PassAs.Body)] string value = "Hello World!", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return (await client.PutAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalStringViaBody", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeGetOptionalStringViaBodyAsync([GeneratedParam(PassAs.Body)] string value = "Hello World!", CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.PutUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetOptionalStringViaBody", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetStringList", Returns = typeof(global::System.Collections.Generic.List<string>), RouteTemplate = "GetStringList", HttpMethod = "PUT")]
        public async Task<global::System.Collections.Generic.List<string>> GetStringListAsync([GeneratedParam(PassAs.Body)] global::System.Collections.Generic.List<string> value, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return (await client.PutAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetStringList", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity)).As<global::System.Collections.Generic.List<string>>();
        }

        public async Task<JsonResponse> UnsafeGetStringListAsync([GeneratedParam(PassAs.Body)] global::System.Collections.Generic.List<string> value, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.PutUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetStringList", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetPersonList", Returns = typeof(global::System.Collections.Generic.List<Person>), RouteTemplate = "GetPersonList", HttpMethod = "PUT")]
        public async Task<global::System.Collections.Generic.List<Person>> GetPersonListAsync([GeneratedParam(PassAs.Body)] global::System.Collections.Generic.List<Person> value, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return (await client.PutAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetPersonList", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity)).As<global::System.Collections.Generic.List<Person>>();
        }

        public async Task<JsonResponse> UnsafeGetPersonListAsync([GeneratedParam(PassAs.Body)] global::System.Collections.Generic.List<Person> value, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.PutUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetPersonList", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        [GeneratedMethod(DefinedAs = "GetPersonArray", Returns = typeof(Person[]), RouteTemplate = "GetPersonArray", HttpMethod = "PUT")]
        public async Task<Person[]> GetPersonArrayAsync([GeneratedParam(PassAs.Body)] Person[] value, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return (await client.PutAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetPersonArray", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity)).As<Person[]>();
        }

        public async Task<JsonResponse> UnsafeGetPersonArrayAsync([GeneratedParam(PassAs.Body)] Person[] value, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.PutUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/TestUxAspNetFixture/GetPersonArray", document: RoundtripDataHelper.Serialize(value), cancellationToken: _cancellationToken, logActivity: _logActivity);
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.global::Test.Neon.Models.Definitions.VerifyController0

    [GeneratedClient("")]
    public partial class VerifyController0Client : IDisposable, IGeneratedServiceClient
    {
        /// <inheritdoc/>
        public string GeneratorVersion => "2.14.0:1";

        private JsonClient       client;
        private bool             isDisposed = false;
        private IRetryPolicy     retryPolicy;

        /// <summary>
        /// Used to construct a client for most situations, optionally specifying a custom <see cref="HttpMessageHandler"/> and/or
        /// <see cref="IRetryPolicy"/>.
        /// </summary>
        /// <param name="handler">An optional message handler.  This defaults to a reasonable handler with compression enabled.</param>
        /// <param name="disposeHandler">Indicates whether the handler passed will be disposed automatically (defaults to <c>false</c>).</param>
        /// <param name="retryPolicy">Optionally specifies a default retry policy (defaults to <see cref="NoRetryPolicy"/>).</param>
        public VerifyController0Client(HttpMessageHandler handler = null, bool disposeHandler = false, IRetryPolicy retryPolicy = null)
        {
            this.client = new JsonClient(handler, disposeHandler);
            this.retryPolicy = retryPolicy ?? NoRetryPolicy.Instance;
        }

        /// <summary>
        /// Used in special situations (like ASP.NET Blazor) where a special <see cref="HttpClient"/> needs
        /// to be created and provided.
        /// </summary>
        /// <param name="httpClient">The special <see cref="HttpClient"/> instance to be wrapped.</param>
        /// <param name="retryPolicy">Optionally specifies a default retry policy (defaults to <see cref="NoRetryPolicy"/>).</param>
        public VerifyController0Client(HttpClient httpClient, IRetryPolicy retryPolicy = null)
        {
            Covenant.Requires<ArgumentNullException>(httpClient != null, nameof(httpClient));

            this.client = new JsonClient(httpClient);
            this.retryPolicy = retryPolicy ?? NoRetryPolicy.Instance;
        }

        /// <summary>
        /// Finalizer.
        /// </summary>
        ~VerifyController0Client()
        {
             Dispose(false);
        }

        /// <inheritdoc/>
        public void Dispose()
        {
        }

        /// <summary>
        /// Releases any important resources associated with the instance.
        /// </summary>
        /// <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        protected void Dispose(bool disposing)
        {
            if (isDisposed)
            {
                return;
            }

            client.Dispose();

            if (disposing)
            {
                GC.SuppressFinalize(this);
            }

            isDisposed = true;
        }

        /// <summary>
        /// Returns the underlying <see cref="JsonClient"/>.
        /// </summary>
        public JsonClient JsonClient => client;

        /// <summary>
        /// Returns the underlying <see cref="HttpClient"/>.
        /// </summary>
        public HttpClient HttpClient => client.HttpClient;

        /// <summary>
        /// Accesses the underlying <see cref="HttpClient.Timeout"/>.
        /// </summary>
        public TimeSpan Timeout
        {
            get => client.Timeout;
            set => client.Timeout = value;
        }

        /// <summary>
        /// Accesses the underlying <see cref="HttpClient.BaseAddress"/>.
        /// </summary>
        public Uri BaseAddress
        {
            get => client.BaseAddress;
            set => client.BaseAddress = value;
        }

        /// <summary>
        /// Returns the underlying <see cref="HttpClient.DefaultRequestHeaders"/>.
        /// </summary>
        public HttpRequestHeaders DefaultRequestHeaders => client.DefaultRequestHeaders;

        /// <summary>
        /// Returns the underlying <see cref="HttpClient.DefaultRequestHeaders"/>.
        /// </summary>
        public IRetryPolicy RetryPolicy
        {
            get => this.retryPolicy;
            set => this.retryPolicy = value ?? global::Neon.Retry.NoRetryPolicy.Instance;
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.global::Test.Neon.Models.Definitions.VerifyController1

    [GeneratedClient("/foo")]
    public partial class VerifyController1Client : IDisposable, IGeneratedServiceClient
    {
        /// <inheritdoc/>
        public string GeneratorVersion => "2.14.0:1";

        private JsonClient       client;
        private bool             isDisposed = false;
        private IRetryPolicy     retryPolicy;

        /// <summary>
        /// Used to construct a client for most situations, optionally specifying a custom <see cref="HttpMessageHandler"/> and/or
        /// <see cref="IRetryPolicy"/>.
        /// </summary>
        /// <param name="handler">An optional message handler.  This defaults to a reasonable handler with compression enabled.</param>
        /// <param name="disposeHandler">Indicates whether the handler passed will be disposed automatically (defaults to <c>false</c>).</param>
        /// <param name="retryPolicy">Optionally specifies a default retry policy (defaults to <see cref="NoRetryPolicy"/>).</param>
        public VerifyController1Client(HttpMessageHandler handler = null, bool disposeHandler = false, IRetryPolicy retryPolicy = null)
        {
            this.client = new JsonClient(handler, disposeHandler);
            this.retryPolicy = retryPolicy ?? NoRetryPolicy.Instance;
        }

        /// <summary>
        /// Used in special situations (like ASP.NET Blazor) where a special <see cref="HttpClient"/> needs
        /// to be created and provided.
        /// </summary>
        /// <param name="httpClient">The special <see cref="HttpClient"/> instance to be wrapped.</param>
        /// <param name="retryPolicy">Optionally specifies a default retry policy (defaults to <see cref="NoRetryPolicy"/>).</param>
        public VerifyController1Client(HttpClient httpClient, IRetryPolicy retryPolicy = null)
        {
            Covenant.Requires<ArgumentNullException>(httpClient != null, nameof(httpClient));

            this.client = new JsonClient(httpClient);
            this.retryPolicy = retryPolicy ?? NoRetryPolicy.Instance;
        }

        /// <summary>
        /// Finalizer.
        /// </summary>
        ~VerifyController1Client()
        {
             Dispose(false);
        }

        /// <inheritdoc/>
        public void Dispose()
        {
        }

        /// <summary>
        /// Releases any important resources associated with the instance.
        /// </summary>
        /// <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        protected void Dispose(bool disposing)
        {
            if (isDisposed)
            {
                return;
            }

            client.Dispose();

            if (disposing)
            {
                GC.SuppressFinalize(this);
            }

            isDisposed = true;
        }

        /// <summary>
        /// Returns the underlying <see cref="JsonClient"/>.
        /// </summary>
        public JsonClient JsonClient => client;

        /// <summary>
        /// Returns the underlying <see cref="HttpClient"/>.
        /// </summary>
        public HttpClient HttpClient => client.HttpClient;

        /// <summary>
        /// Accesses the underlying <see cref="HttpClient.Timeout"/>.
        /// </summary>
        public TimeSpan Timeout
        {
            get => client.Timeout;
            set => client.Timeout = value;
        }

        /// <summary>
        /// Accesses the underlying <see cref="HttpClient.BaseAddress"/>.
        /// </summary>
        public Uri BaseAddress
        {
            get => client.BaseAddress;
            set => client.BaseAddress = value;
        }

        /// <summary>
        /// Returns the underlying <see cref="HttpClient.DefaultRequestHeaders"/>.
        /// </summary>
        public HttpRequestHeaders DefaultRequestHeaders => client.DefaultRequestHeaders;

        /// <summary>
        /// Returns the underlying <see cref="HttpClient.DefaultRequestHeaders"/>.
        /// </summary>
        public IRetryPolicy RetryPolicy
        {
            get => this.retryPolicy;
            set => this.retryPolicy = value ?? global::Neon.Retry.NoRetryPolicy.Instance;
        }

        [GeneratedMethod(DefinedAs = "Hello", Returns = typeof(void), RouteTemplate = "Hello", HttpMethod = "GET")]
        public async Task HelloAsync(CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/foo/Hello", cancellationToken: _cancellationToken, logActivity: _logActivity);
        }

        public async Task<JsonResponse> UnsafeHelloAsync(CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/foo/Hello", cancellationToken: _cancellationToken, logActivity: _logActivity);
        }
    }

    //-------------------------------------------------------------------------
    // From: Test.Neon.Models.Definitions.global::Test.Neon.Models.Definitions.ComposedUserController
    // From: Test.Neon.Models.Definitions.global::Test.Neon.Models.Definitions.ComposedDeliveryController
    // From: Test.Neon.Models.Definitions.global::Test.Neon.Models.Definitions.ComposedController

    [GeneratedClient("/api/v1")]
    public partial class ComposedClient : IDisposable, IGeneratedServiceClient
    {
        /// <inheritdoc/>
        public string GeneratorVersion => "2.14.0:1";

        [GeneratedClient("/api/v1/user")]
        public partial class __User : IGeneratedServiceClient
        {
            private JsonClient       client;
            private IRetryPolicy     retryPolicy;

            internal __User(JsonClient client, IRetryPolicy retryPolicy = null)
            {
                this.client = client;
                this.retryPolicy = retryPolicy;
            }

            /// <inheritdoc/>
            public string GeneratorVersion => "2.14.0:1";

            [GeneratedMethod(DefinedAs = "Get", Returns = typeof(string), RouteTemplate = "{id}", HttpMethod = "GET")]
            public async Task<string> GetAsync([GeneratedParam(PassAs.Query, Name = "id")] int id, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
            {
                await SyncContext.ClearAsync;
                return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/api/v1/user/{Uri.EscapeUriString(id.ToString())}", cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
            }

            public async Task<JsonResponse> UnsafeGetAsync([GeneratedParam(PassAs.Query, Name = "id")] int id, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
            {
                await SyncContext.ClearAsync;
                return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/api/v1/user/{Uri.EscapeUriString(id.ToString())}", cancellationToken: _cancellationToken, logActivity: _logActivity);
            }

            [GeneratedMethod(DefinedAs = "List", Returns = typeof(string[]), RouteTemplate = "List", HttpMethod = "GET")]
            public async Task<string[]> ListAsync(CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
            {
                await SyncContext.ClearAsync;
                return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/api/v1/user/List", cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string[]>();
            }

            public async Task<JsonResponse> UnsafeListAsync(CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
            {
                await SyncContext.ClearAsync;
                return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/api/v1/user/List", cancellationToken: _cancellationToken, logActivity: _logActivity);
            }
        }

        [GeneratedClient("/api/v1/delivery")]
        public partial class __Delivery : IGeneratedServiceClient
        {
            private JsonClient       client;
            private IRetryPolicy     retryPolicy;

            internal __Delivery(JsonClient client, IRetryPolicy retryPolicy = null)
            {
                this.client = client;
                this.retryPolicy = retryPolicy;
            }

            /// <inheritdoc/>
            public string GeneratorVersion => "2.14.0:1";

            [GeneratedMethod(DefinedAs = "Get", Returns = typeof(string), RouteTemplate = "{id}", HttpMethod = "GET")]
            public async Task<string> GetAsync([GeneratedParam(PassAs.Query, Name = "id")] int id, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
            {
                await SyncContext.ClearAsync;
                return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/api/v1/delivery/{Uri.EscapeUriString(id.ToString())}", cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
            }

            public async Task<JsonResponse> UnsafeGetAsync([GeneratedParam(PassAs.Query, Name = "id")] int id, CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
            {
                await SyncContext.ClearAsync;
                return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/api/v1/delivery/{Uri.EscapeUriString(id.ToString())}", cancellationToken: _cancellationToken, logActivity: _logActivity);
            }

            [GeneratedMethod(DefinedAs = "List", Returns = typeof(string[]), RouteTemplate = "List", HttpMethod = "GET")]
            public async Task<string[]> ListAsync(CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
            {
                await SyncContext.ClearAsync;
                return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/api/v1/delivery/List", cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string[]>();
            }

            public async Task<JsonResponse> UnsafeListAsync(CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
            {
                await SyncContext.ClearAsync;
                return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/api/v1/delivery/List", cancellationToken: _cancellationToken, logActivity: _logActivity);
            }
        }

        private JsonClient       client;
        private bool             isDisposed = false;
        private IRetryPolicy     retryPolicy;

        /// <summary>
        /// Used to construct a client for most situations, optionally specifying a custom <see cref="HttpMessageHandler"/> and/or
        /// <see cref="IRetryPolicy"/>.
        /// </summary>
        /// <param name="handler">An optional message handler.  This defaults to a reasonable handler with compression enabled.</param>
        /// <param name="disposeHandler">Indicates whether the handler passed will be disposed automatically (defaults to <c>false</c>).</param>
        /// <param name="retryPolicy">Optionally specifies a default retry policy (defaults to <see cref="NoRetryPolicy"/>).</param>
        public ComposedClient(HttpMessageHandler handler = null, bool disposeHandler = false, IRetryPolicy retryPolicy = null)
        {
            this.client = new JsonClient(handler, disposeHandler);
            this.retryPolicy = retryPolicy ?? NoRetryPolicy.Instance;
            this.User = new __User(this.client);
            this.Delivery = new __Delivery(this.client);
        }

        /// <summary>
        /// Used in special situations (like ASP.NET Blazor) where a special <see cref="HttpClient"/> needs
        /// to be created and provided.
        /// </summary>
        /// <param name="httpClient">The special <see cref="HttpClient"/> instance to be wrapped.</param>
        /// <param name="retryPolicy">Optionally specifies a default retry policy (defaults to <see cref="NoRetryPolicy"/>).</param>
        public ComposedClient(HttpClient httpClient, IRetryPolicy retryPolicy = null)
        {
            Covenant.Requires<ArgumentNullException>(httpClient != null, nameof(httpClient));

            this.client = new JsonClient(httpClient);
            this.retryPolicy = retryPolicy ?? NoRetryPolicy.Instance;
            this.User = new __User(this.client, this.retryPolicy);
            this.Delivery = new __Delivery(this.client, this.retryPolicy);
        }

        /// <summary>
        /// Finalizer.
        /// </summary>
        ~ComposedClient()
        {
             Dispose(false);
        }

        /// <inheritdoc/>
        public void Dispose()
        {
        }

        /// <summary>
        /// Releases any important resources associated with the instance.
        /// </summary>
        /// <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        protected void Dispose(bool disposing)
        {
            if (isDisposed)
            {
                return;
            }

            client.Dispose();

            if (disposing)
            {
                GC.SuppressFinalize(this);
            }

            isDisposed = true;
        }

        /// <summary>
        /// Returns the underlying <see cref="JsonClient"/>.
        /// </summary>
        public JsonClient JsonClient => client;

        /// <summary>
        /// Returns the underlying <see cref="HttpClient"/>.
        /// </summary>
        public HttpClient HttpClient => client.HttpClient;

        /// <summary>
        /// Accesses the underlying <see cref="HttpClient.Timeout"/>.
        /// </summary>
        public TimeSpan Timeout
        {
            get => client.Timeout;
            set => client.Timeout = value;
        }

        /// <summary>
        /// Accesses the underlying <see cref="HttpClient.BaseAddress"/>.
        /// </summary>
        public Uri BaseAddress
        {
            get => client.BaseAddress;
            set => client.BaseAddress = value;
        }

        /// <summary>
        /// Returns the underlying <see cref="HttpClient.DefaultRequestHeaders"/>.
        /// </summary>
        public HttpRequestHeaders DefaultRequestHeaders => client.DefaultRequestHeaders;

        /// <summary>
        /// Returns the underlying <see cref="HttpClient.DefaultRequestHeaders"/>.
        /// </summary>
        public IRetryPolicy RetryPolicy
        {
            get => this.retryPolicy;
            set => this.retryPolicy = value ?? global::Neon.Retry.NoRetryPolicy.Instance;
        }

        /// <summary>
        /// <b>User</b> related service methods.
        /// </summary>x
        public __User User { get; private set; }

        /// <summary>
        /// <b>Delivery</b> related service methods.
        /// </summary>x
        public __Delivery Delivery { get; private set; }

        [GeneratedMethod(DefinedAs = "GetVersion", Returns = typeof(string), RouteTemplate = "GetVersion", HttpMethod = "GET")]
        public async Task<string> GetVersionAsync(CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return (await client.GetAsync(_retryPolicy ?? this.retryPolicy, $"/api/v1/GetVersion", cancellationToken: _cancellationToken, logActivity: _logActivity)).As<string>();
        }

        public async Task<JsonResponse> UnsafeGetVersionAsync(CancellationToken _cancellationToken = default, IRetryPolicy _retryPolicy = default, LogActivity _logActivity = default)
        {
            await SyncContext.ClearAsync;
            return await client.GetUnsafeAsync(_retryPolicy ?? this.retryPolicy, $"/api/v1/GetVersion", cancellationToken: _cancellationToken, logActivity: _logActivity);
        }
    }
}
